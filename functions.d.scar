---@meta function-declarations
---@diagnostic disable: missing-return



---@class Position
---@field x number
---@field y number
---@field z number


---@class Player
Player = {}
---@class Squad
Squad = {}
---@class Entity
Entity = {}
---@class PBG
PBG = {}
---@class AITacticType
AITacticType = {}
---@class EntityType
EntityType = {}
---@class SquadType
SquadType = {}
---@class UpgradeType
UpgradeType = {}
---@class Void
Void = {}
---@class Marker
Marker = {}
---@class SGroup
SGroup = {}
---@class EGroup
EGroup = {}
---@class UniqueID
UniqueID = {}
---@class ConstTargetHandle
ConstTargetHandle = {}
---@class Ability
Ability = {}
---@class EntityPBG
EntityPBG = {}
---@class AIScoreMultiplierID
AIScoreMultiplierID = {}
---@class StackVarTable
StackVarTable = {}
---@class RenderModel
RenderModel = {}
---@class Transform
Transform = {}
---@class SaveTriggerType
SaveTriggerType = {}
---@class lua_State
lua_State = {}
---@class ChallengeEventType
ChallengeEventType = {}
---@class RefTable
RefTable = {}
---@class ScarModifier
ScarModifier = {}
---@class ModifierApplicationType
ModifierApplicationType = {}
---@class ModifierUsageType
ModifierUsageType = {}
---@class ObjectiveType
ObjectiveType = {}
---@class ObjectiveFn
ObjectiveFn = {}
---@class State
State = {}
---@class Object
Object = {}
---@class ScarRacePBG
ScarRacePBG = {}
---@class SyncWeaponID
SyncWeaponID = {}
---@class LuaTable
LuaTable = {}
---@class Item
Item = {}
---@class OBJECT
OBJECT = {}
---@class a
a = {}
---@class the
the = {}
---@class Optional
Optional = {}
---@class stack_level
stack_level = {}
---@class path
path = {}
---@class t_test_group
t_test_group = {}
---@class FrontEnd_Layer
FrontEnd_Layer = {}
---@class DialogResult
DialogResult = {}
---@class DeploymentID
DeploymentID = {}
---@class WinReason
WinReason = {}
---@class KillPlayerReason
KillPlayerReason = {}
---@class AIMilitaryTargetType
AIMilitaryTargetType = {}
---@class CombatRangePolicy
CombatRangePolicy = {}
---@class AIEncounterID
AIEncounterID = {}
---@class AITaskID
AITaskID = {}
---@class ResourceAmount
ResourceAmount = {}
---@class TargetPreference
TargetPreference = {}
---@class ScarAIStateModelTuningsPBG
ScarAIStateModelTuningsPBG = {}
---@class LuaMap
LuaMap = {}
---@class ScarAIFormationCoordinatorPBG
ScarAIFormationCoordinatorPBG = {}
---@class PropertyBagGroupType
PropertyBagGroupType = {}
---@class Upgrade
Upgrade = {}
---@class CapType
CapType = {}
---@class CamouflageStanceID
CamouflageStanceID = {}
---@class EntityCommandType
EntityCommandType = {}
---@class PlayerCommandType
PlayerCommandType = {}
---@class SquadCommandType
SquadCommandType = {}
---@class LoopType
LoopType = {}
---@class StanceType
StanceType = {}
---@class WeaponPreference
WeaponPreference = {}
---@class Team
Team = {}
---@class COMPARISON
COMPARISON = {}
---@class Relationship
Relationship = {}
---@class winReason
winReason = {}
---@class GameUICore
GameUICore = {}
---@class List
List = {}
---@class TeamID
TeamID = {}
---@class EncounterData
EncounterData = {}
---@class SBP
SBP = {}
---@class SPAWN
SPAWN = {}
---@class GoalData
GoalData = {}
---@class HandleID
HandleID = {}
---@class ComponentDependencyIndex
ComponentDependencyIndex = {}
---@class CrushMode
CrushMode = {}
---@class TargetingType
TargetingType = {}
---@class ScarWeaponPBG
ScarWeaponPBG = {}
---@class ALL_UNITS
ALL_UNITS = {}
---@class ANY_MEMBER
ANY_MEMBER = {}
---@class ANY_SQUAD
ANY_SQUAD = {}
---@class modids
modids = {}
---@class MUT
MUT = {}
---@class Group
Group = {}
---@class AreaType
AreaType = {}
---@class BP
BP = {}
---@class Element
Element = {}
---@class SectorID
SectorID = {}
---@class Availability
Availability = {}
---@class SquadCombatBehaviourMoodMode
SquadCombatBehaviourMoodMode = {}
---@class Relation
Relation = {}
---@class BaseType
BaseType = {}
---@class AddResourceReason
AddResourceReason = {}
---@class ActorTable
ActorTable = {}
---@class ProxType
ProxType = {}
---@class TerrainSplatObject
TerrainSplatObject = {}
---@class RuleFilterContext
RuleFilterContext = {}
---@class RuleFilterOperator
RuleFilterOperator = {}
---@class Comparison
Comparison = {}
---@class ScarSlotItemPBG
ScarSlotItemPBG = {}
---@class SlotItemID
SlotItemID = {}
---@class ScarMoveTypePBG
ScarMoveTypePBG = {}
---@class GoalSequence
GoalSequence = {}
---@class InputEnabledFlag
InputEnabledFlag = {}
---@class VisibilityFlag
VisibilityFlag = {}
---@class target
target = {}
---@class unknown
unknown = {}
---@class ScarBriefingActorPBG
ScarBriefingActorPBG = {}
---@class sender
sender = {}
---@class event
event = {}
---@class visible
visible = {}
---@class enable
enable = {}
---@class when
when = {}
---@class ui
ui = {}
---@class Control
Control = {}
---@class EventCueVisibility
EventCueVisibility = {}
---@class UIEventType
UIEventType = {}
---@class same
same = {}
---@class delete
delete = {}
---@class GameEventID
GameEventID = {}
---@class ProductionItemType
ProductionItemType = {}
---@class ScarReticulePBG
ScarReticulePBG = {}
---@class HUDFeatureType
HUDFeatureType = {}
---@class ErrorMessage
ErrorMessage = {}
---@class argc
argc = {}

--- Create a AlliedCombatFitness scoring function.
--- Returns 1.0 to 0.0, based on how the allied combat fitness is. 1.0 if the allied fitness is at or below minFitness, 0.0 if fitness is above the maxFitness, smooth transition in between. If highFitnessIsGood, returns 0.0 to 1.0 instead. 0.0 if at or below minFitness and 1.0 if at or above maxFitness.
---@param aiPlayer Player
---@param minFitness number
---@param maxFitness number
---@param aiArmyType number
---@param highFitnessIsGood boolean
---@return unknown
function AIProductionScoring_AlliedCombatFitness(aiPlayer, minFitness, maxFitness, aiArmyType, highFitnessIsGood) end

--- Create a AlliedCombatFitness scoring function (versus strongest enemy).
--- Returns 1.0 to 0.0, based on how the allied combat fitness is. 1.0 if the fitness is at or below minFitness, 0.0 if fitness is above the maxFitness, smooth transition in between. If highFitnessIsGood, returns 0.0 to 1.0 instead. 0.0 if at or below minFitness and 1.0 if at or above maxFitness.
---@param aiPlayer Player
---@param minFitness number
---@param maxFitness number
---@param aiArmyType number
---@param highFitnessIsGood boolean
---@return unknown
function AIProductionScoring_AlliedCombatFitnessVsStrongestEnemy(aiPlayer, minFitness, maxFitness, aiArmyType, highFitnessIsGood) end

--- Create a AlliedCombatFitness scoring function (versus the weakest enemy).
--- Returns 1.0 to 0.0, based on how the allied combat fitness is. 1.0 if the fitness is at or below minFitness, 0.0 if fitness is above the maxFitness, smooth transition in between. If highFitnessIsGood, returns 0.0 to 1.0 instead. 0.0 if at or below minFitness and 1.0 if at or above maxFitness.
---@param aiPlayer Player
---@param minFitness number
---@param maxFitness number
---@param aiArmyType number
---@param highFitnessIsGood boolean
---@return unknown
function AIProductionScoring_AlliedCombatFitnessVsWeakestEnemy(aiPlayer, minFitness, maxFitness, aiArmyType, highFitnessIsGood) end

--- Create an AmountOfResourceNeeded scoring function.
--- If this building is a dropoff, this returns a value between 0 and 1 indicating how much of that resources is needed. Any amount >= maxResources will result in a value of 1.
---@param aiPlayer Player
---@param maxResources number
---@return unknown
function AIProductionScoring_AmountOfResourceNeeded(aiPlayer, maxResources) end

--- Check if now is an appropriate time to be making scoring functions.
--- Score functions should only be made within functions referenced by ProductionGroups
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_CanPushProductionScoringFunction(aiPlayer) end

--- Create a ClampedScoringFunction scoring function.
--- Clamps the returned value of the inner scoring function
---@param aiPlayer Player
---@param min number
---@param max number
---@param innerScoringFunction function
---@return unknown
function AIProductionScoring_ClampedScoringFunction(aiPlayer, min, max, innerScoringFunction) end

--- Create a CounterScore scoring function
--- If a item is a chosen counter it will get the score = (baseScoreContributuion + (1 - baseScoreContributuion) * counter score)
---@param aiPlayer Player
---@param baseScoreContributuion number
---@return unknown
function AIProductionScoring_CounterScore(aiPlayer, baseScoreContributuion) end

--- Create a DropOffScore scoring function.
--- Returns positive score if drop off is required to either serve gathering of a resource or improve existing gathering
---@param aiPlayer Player
---@param weight number
---@return unknown
function AIProductionScoring_DeficiencyScore(aiPlayer, weight) end

--- Create a EntityCombatUpgrade scoring function.
--- Returns positive score if entity's combat fitness is improved. The aforementioned entity is the entity that the upgrade is being produce on.
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_EntityCombatUpgrade(aiPlayer) end

--- Create a MinimumGameTime scoring function.
--- minGameTime is time from start in seconds. Returns 0.0 until minGameTime has passed, 1.0f after.
---@param aiPlayer Player
---@param minGameTime number
---@param increasePerSecond number
---@return unknown
function AIProductionScoring_IncreaseOverTime(aiPlayer, minGameTime, increasePerSecond) end

--- Create an InverseRandomIntScore scoring function.
--- Returns either 0.0f or 1.0f (inverse of RandomIntScore) based on a random number picked at the start of the game
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_InverseRandomIntScore(aiPlayer) end

--- Create an IslandNeedingExpansionBase scoring function.
--- Returns 1.0f if there is an island requiring an expansion base
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_IslandNeedingExpansionBase(aiPlayer) end

--- Create a LackOfSecuredResourceDeposits scoring function.
--- Returns between 0 and 1, 1 if the total sum of secured resource deposits is less or equal to scarce amount, 0 if the amount is equal to or greater than well off amount, lerps in between
---@param aiPlayer Player
---@param resourceType ResourceType
---@param scarceAmount number
---@param wellOffAmount number
---@return unknown
function AIProductionScoring_LackOfSecuredResourceDeposits(aiPlayer, resourceType, scarceAmount, wellOffAmount) end

--- Create a LuaScoringFunction scoring function.
--- Takes a reference to a lua function. Lua function will be called and passed AIPlayer and Pbg. Lua function is expected to return a value >= 0.0 DO NOT call any methods that do stuff to the AIPlayer in your referenced lua function. The referenced lua function must exist within the player's lua context
---@param aiPlayer Player
---@param scoringFunction function
---@return unknown
function AIProductionScoring_LuaScoringFunction(aiPlayer, scoringFunction) end

--- Create a MaximumGameTime scoring function.
--- minGameTime is time from start in seconds. Returns 1.0 until maxGameTime has passed, 0.0f after.
---@param aiPlayer Player
---@param maxGameTime number
---@return unknown
function AIProductionScoring_MaximumGameTime(aiPlayer, maxGameTime) end

--- Create a MaxPopCapPercentage scoring function
--- targetPopulationPercentageAlive should be in range 0.0 -> 1.0. Return 1.0f as long as the combined population of the production item /group does not exceed a percentage of the player's max pop cap. If groupPopulation == true then all members of the item's Production Group are counted towards the current population to be compared against the target population.
---@param aiPlayer Player
---@param targetPopulationPercentageAlive number
---@param groupPopulation boolean
---@return unknown
function AIProductionScoring_MaxPopCapPercentage(aiPlayer, targetPopulationPercentageAlive, groupPopulation) end

--- Create a MaxScoringFunction scoring function.
--- Returns the max value of the inner scoring functions
---@param aiPlayer Player
---@param innerScoringFunction table<function>
---@return unknown
function AIProductionScoring_MaxScoringFunction(aiPlayer, innerScoringFunction) end

--- Create a MaxWeaponDamage scoring function.
--- Units max weapon damage is normalized by max damage. (returns between 0.0 and 1.0)
---@param aiPlayer Player
---@param maxDamage number
---@return unknown
function AIProductionScoring_MaxWeaponDamage(aiPlayer, maxDamage) end

--- Create a MilitaryPlayerUpgrade scoring function.
--- Quantifies how a player upgrade will improve the current army's combat fitness. Result = 1 - (1  - combat_fitness_improvment)^upgradeExponent
---@param aiPlayer Player
---@param upgradeExponent number
---@return unknown
function AIProductionScoring_MilitaryPlayerUpgrade(aiPlayer, upgradeExponent) end

--- Create a MinimumGameTime scoring function.
--- minGameTime is time from start in seconds. Returns 0.0 until minGameTime has passed, 1.0f after.
---@param aiPlayer Player
---@param minGameTime number
---@return unknown
function AIProductionScoring_MinimumGameTime(aiPlayer, minGameTime) end

--- Create a MultipleProduced scoring function
--- Item will get a score of 1 +(additionalFactor * number of additional produced)
---@param aiPlayer Player
---@param additionalFactor number
---@return unknown
function AIProductionScoring_MultipleProduced(aiPlayer, additionalFactor) end

--- Create a MultiplyListScoringFunction scoring function.
--- Takes a list of scoring functions and multiplies them together. This scoring function can be paired with MaxScoringFunction to generate OR scoring expressions, such as Max(IslandNeedingExpansionBase, (ProductionQueueContention * TimeToAcquire))
---@param aiPlayer Player
---@param innerScoringFunction table<function>
---@return unknown
function AIProductionScoring_MultiplyListScoringFunction(aiPlayer, innerScoringFunction) end

--- Create a NavalTransportRequired scoring function.
--- Returns 0.0 -> 1.0, depending on strategic island decisions that would require transport
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_NavalTransportRequired(aiPlayer) end

--- Create an NotProducedEver scoring function.
--- Returns 1.0f has never been produced, 0.0f if it has been produced
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_NotProducedEver(aiPlayer) end

--- Create an NotProducedRecently scoring function.
--- Returns 1.0f if the item was not produced within the time period supplied, 0.0f otherwise
---@param aiPlayer Player
---@param timePeriodSeconds number
---@return unknown
function AIProductionScoring_NotProducedRecently(aiPlayer, timePeriodSeconds) end

--- Create a OnlyProduceOneAtATime scoring function.
--- Returns 0.0 while another item of the same type is being produced
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_OnlyProduceOneAtATime(aiPlayer) end

--- Create a PlannedPlacementScore scoring function.
--- Returns the value of the planned placement, returns 0.0 if no planned placement Will return 0.0 if placement score is below minPlacementScore. Set minPlacementScore < 0.0 to ignore this minimum filtering.
---@param aiPlayer Player
---@param minPlacementScore number
---@return unknown
function AIProductionScoring_PlannedPlacementScore(aiPlayer, minPlacementScore) end

--- Create a PlayerGatheringUpgrade scoring function
--- Result is gatheringImprovment * improvementScalingFactor
---@param aiPlayer Player
---@param improvementScalingFactor number
---@param approxDistToDeposit number
---@return unknown
function AIProductionScoring_PlayerGatheringUpgrade(aiPlayer, improvementScalingFactor, approxDistToDeposit) end

--- Create an AIPlayersOnDifferentIslands scoring function.
--- Returns 1.0 if any players are on different pathfinding islands, 0 if they are all on the same island
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_PlayersOnDifferentIslands(aiPlayer) end

--- Create a PopCapGenerator scoring function.
--- Returns 1.0 score if the item generates required pop cap
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_PopCapGenerator(aiPlayer) end

--- Create a PopulationPercentage scoring function
--- targetPopulationPercentageAlive should be in range 0.0 -> 1.0. Score will approach zero as an item's population (as a percentage of the global population) approaches the target, i.e. score =  1.0f - (currentPercentage / target)^dropOffFactor;  The global population is number of squads or structures belonging to the player alive. If groupPopulation == true then all members of the item's Production Group are counted towards the current population to be compared against the global population. if useSquadPopulation == true, number of squads will be used in calculation instead of checking if the item pbg corresponds to a squad or building
---@param aiPlayer Player
---@param targetPopulationPercentageAlive number
---@param scoreDropOffFactor number
---@param groupPopulation boolean
---@param useSquadPopulation boolean
---@return unknown
function AIProductionScoring_PopulationPercentage(aiPlayer, targetPopulationPercentageAlive, scoreDropOffFactor, groupPopulation, useSquadPopulation) end

--- Create a PresenceOfEnemyTypes scoring function
--- Every time a unit type is observed it's weight is added to the return value of this scoring function. if squadTypes == false, then entity types assumed. Max return value is 1.0
---@param aiPlayer Player
---@param weights number
---@param squadTypes boolean
---@return unknown
function AIProductionScoring_PresenceOfEnemyTypes(aiPlayer, weights, squadTypes) end

--- Create a PresenceOfMyTypes scoring function
--- Every time a unit type is observed it's weight is added to the return value of this scoring function. if squadTypes == false, then entity types assumed. Max return value is 1.0
---@param aiPlayer Player
---@param weights number
---@param squadTypes boolean
---@return unknown
function AIProductionScoring_PresenceOfMyTypes(aiPlayer, weights, squadTypes) end

--- Create a PresenceOfUpgradeableSquads scoring function.
--- For each player squad that this upgrade applies to the score is increased by the weight to a max of 1.0.
---@param aiPlayer Player
---@param weight number
---@return unknown
function AIProductionScoring_PresenceOfUpgradeableSquads(aiPlayer, weight) end

--- Create a ProductionQueueContention scoring function.
--- Returns a score of productionQueueContention / normalFactor. productionQueueContention is the number of contentions recorded for the associated item (which is a production building), normalFactor is clamped >= 1
---@param aiPlayer Player
---@param contentionThreshold number
---@param normalFactor number
---@return unknown
function AIProductionScoring_ProductionQueueContention(aiPlayer, contentionThreshold, normalFactor) end

--- Create an RandomIntScore scoring function.
--- Returns either 0.0f or 1.0f based on a random number picked at the start of the game
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_RandomIntScore(aiPlayer) end

--- Create an RemainingPersonnelPopCap scoring function.
--- Returns 1.0f if there is enough remaining personnel pop cap, 0.0f otherwise
---@param aiPlayer Player
---@param requiredRemainingPop number
---@return unknown
function AIProductionScoring_RemainingPersonnelPopCap(aiPlayer, requiredRemainingPop) end

--- Create a ResourceGeneratorScore scoring function.
--- Gives positive score if the item produces required resources
---@param aiPlayer Player
---@param depletionTimeThreshold number
---@return unknown
function AIProductionScoring_ResourceGeneratorScore(aiPlayer, depletionTimeThreshold) end

--- Create a DropOffScore scoring function.
--- Returns positive score if drop off is required to either serve gathering of a resource or improve existing gathering
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_ScarcityAndDeficiencyScore(aiPlayer) end

--- Create an AIShouldConsiderLimitedNaval scoring function.
--- Returns 1.0 if there are large bodies of water on the map
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_ShouldConsiderLimitedNaval(aiPlayer) end

--- Create an AIShouldConsiderNaval scoring function.
--- Returns 1.0 if players start on different islands or there are large bodies of water on the map
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_ShouldConsiderNaval(aiPlayer) end

--- Returns 1 if not a naval map, 0 otherwise
--- If shouldIncludeLimitedNaval is true, limited naval maps return 1, otherwise limited naval maps return 0
---@param aiPlayer Player
---@param shouldIncludeLimitedNaval boolean
---@return unknown
function AIProductionScoring_ShouldNotConsiderNaval(aiPlayer, shouldIncludeLimitedNaval) end

--- Create a StrategicIntention scoring function
--- Weights table format: { ["weight name"] = weight, } The score is the sum of current intention values * weight, divided by the sum of weights Ex: (currentSiegeIntention* siegeIntentionWeight)/siegeIntentionWeight
---@param aiPlayer Player
---@param weights number
---@return unknown
function AIProductionScoring_StrategicIntention(aiPlayer, weights) end

--- Create a TierUpgrade scoring function.
--- Returns 1.0f if the given BuildInfo is a Player Upgrade that unlocks higher tier of existing units
---@param aiPlayer Player
---@return unknown
function AIProductionScoring_TierUpgrade(aiPlayer) end

--- Create a TimeToAcquire scoring function
--- TimeToAcquire returns values between 0 and 1 and penalizes things that need lots of resources or prerequisites to be produced. Score will approach 0.01 as the time to build something approaches maxTimeSeconds. Time to build something is the sum of the time to gather the outstanding resources, time to build the item, and time to build the requirements of the item
---@param aiPlayer Player
---@param maxTimeSeconds number
---@param includeTimeToGather boolean
---@param includeTimeToBuildThis boolean
---@param includeTimeToBuildRequirements boolean
---@return unknown
function AIProductionScoring_TimeToAcquire(aiPlayer, maxTimeSeconds, includeTimeToGather, includeTimeToBuildThis, includeTimeToBuildRequirements) end

--- Create a ResourceDesireVsIncome scoring function.
--- Returns 0.0 if no safe trade routes exist, 1.0 otherwise.
---@param aiPlayer Player
---@param landRoute boolean
---@return unknown
function AIProductionScoring_TradeRouteExistsScore(aiPlayer, landRoute) end

--- Create a UnderCountLimit scoring function
--- Keeps an item within limits. If groupPopulation == true then all members of the item's Production Group are counted towards the current population to be compared against the limit.
---@param aiPlayer Player
---@param maxAlive number
---@param maxEverProduced number
---@param groupPopulation boolean
---@return unknown
function AIProductionScoring_UnderCountLimit(aiPlayer, maxAlive, maxEverProduced, groupPopulation) end

--- Create a UnderCountLimit scoring function
--- Keeps an item within limits. If groupPopulation == true then all members of the item's Production Group are counted towards the current population to be compared against the limit.
---@param aiPlayer Player
---@param keyMaxAlive string
---@return unknown
function AIProductionScoring_UnderCountLimitFromStateModel(aiPlayer, keyMaxAlive) end

--- Returns a boolean value from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelBool(aiPlayer, key) end

--- Returns a float value from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelFloat(aiPlayer, key) end

--- Returns an integer value from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelInt(aiPlayer, key) end

--- Returns a PropertyBagGroup value from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelPBG(aiPlayer, key) end

--- Returns a table of targets from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelTargetListEntries(aiPlayer, key) end

--- Clears a TargetHandle value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_ClearStateModelEnumTableTarget(aiSquad, key, tableRowIndex) end

--- Clears a TargetHandle value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_ClearStateModelTarget(aiSquad, key) end

--- Returns a boolean value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelBool(aiSquad, key) end

--- Returns an Entity value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelEntityTarget(aiSquad, key) end

--- Returns a boolean value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableBool(aiSquad, key, tableRowIndex) end

--- Returns an Entity value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableEntityTarget(aiSquad, key, tableRowIndex) end

--- Returns a float value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableFloat(aiSquad, key, tableRowIndex) end

--- Returns an integer value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableInt(aiSquad, key, tableRowIndex) end

--- Returns a pbg value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTablePBG(aiSquad, key, tableRowIndex) end

--- Returns a Player value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTablePlayerTarget(aiSquad, key, tableRowIndex) end

--- Returns a Squad value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableSquadTarget(aiSquad, key, tableRowIndex) end

--- Returns a Vector3f value from the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function AISquad_GetStateModelEnumTableVector3f(aiSquad, key, tableRowIndex) end

--- Returns a float value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelFloat(aiSquad, key) end

--- Returns an integer value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelInt(aiSquad, key) end

--- Returns a pbg value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelPBG(aiSquad, key) end

--- Returns a Player value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelPlayerTarget(aiSquad, key) end

--- Returns a Squad value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelSquadTarget(aiSquad, key) end

--- Returns a Vector3f value from the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@return unknown
function AISquad_GetStateModelVector3f(aiSquad, key) end

--- Sets a boolean value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value boolean
---@return unknown
function AISquad_SetStateModelBool(aiSquad, key, value) end

--- Sets an Entity TargetHandle value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value Entity
---@return unknown
function AISquad_SetStateModelEntityTarget(aiSquad, key, value) end

--- Sets a boolean value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value boolean
---@return unknown
function AISquad_SetStateModelEnumTableBool(aiSquad, key, tableRowIndex, value) end

--- Sets an Entity TargetHandle value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value Entity
---@return unknown
function AISquad_SetStateModelEnumTableEntityTarget(aiSquad, key, tableRowIndex, value) end

--- Sets a float value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function AISquad_SetStateModelEnumTableFloat(aiSquad, key, tableRowIndex, value) end

--- Sets an integer value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function AISquad_SetStateModelEnumTableInt(aiSquad, key, tableRowIndex, value) end

--- Sets a pbg value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value PBG
---@return unknown
function AISquad_SetStateModelEnumTablePBG(aiSquad, key, tableRowIndex, value) end

--- Sets a Player TargetHandle value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value Player
---@return unknown
function AISquad_SetStateModelEnumTablePlayerTarget(aiSquad, key, tableRowIndex, value) end

--- Sets a Squad TargetHandle value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value Squad
---@return unknown
function AISquad_SetStateModelEnumTableSquadTarget(aiSquad, key, tableRowIndex, value) end

--- Sets a Vector3f value in the AISquad's state model corresponding to the given key and table row index (0 based).
---@param aiSquad Squad
---@param key string
---@param tableRowIndex number
---@param value Position
---@return unknown
function AISquad_SetStateModelEnumTableVector3f(aiSquad, key, tableRowIndex, value) end

--- Sets a float value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value number
---@return unknown
function AISquad_SetStateModelFloat(aiSquad, key, value) end

--- Sets an integer value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value number
---@return unknown
function AISquad_SetStateModelInt(aiSquad, key, value) end

--- Sets a pbg value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value PBG
---@return unknown
function AISquad_SetStateModelPBG(aiSquad, key, value) end

--- Sets a Player TargetHandle value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value Player
---@return unknown
function AISquad_SetStateModelPlayerTarget(aiSquad, key, value) end

--- Sets a Squad TargetHandle value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value Squad
---@return unknown
function AISquad_SetStateModelSquadTarget(aiSquad, key, value) end

--- Sets a Vector3f value in the AISquad's state model corresponding to the given key.
---@param aiSquad Squad
---@param key string
---@param value Position
---@return unknown
function AISquad_SetStateModelVector3f(aiSquad, key, value) end

--- calculates a valid target position for a jump slide ability
---@param aiSquad Squad
---@param abilityPBG PBG
---@param slideOffset number
---@param targetPosition Position
---@return unknown
function AITactic_AdjustJumpSlideAbilityTarget(aiSquad, abilityPBG, slideOffset, targetPosition) end

--- Issue an AI move command to a squad
---@param aiSquad Squad
---@param target Position
---@param acceptableProximity number
---@param reverseMove boolean
---@return unknown
function AITactic_AICommandSquadMove(aiSquad, target, acceptableProximity, reverseMove) end

--- Get tactic priority for a squad.
--- Return -1 if the tactic type isn't found.
---@param pSquad Squad
---@param tacticType AITacticType
---@return unknown
function AITactic_GetTacticPriority(pSquad, tacticType) end

--- Get current AI player ID
---@return unknown
function AI_GetDebugAIPlayerID() end

--- Set current debug AI player to the next AI player
---@return unknown
function AI_ToggleDebugAIPlayer() end

--- Toggle cursor position distance drawring
---@return unknown
function Cursor_Distance() end

--- Toggle clearing of cursor over entity weapon shot history debug display
---@return unknown
function Cursor_GetClearWeaponShotHistory() end

--- Toggle cursor over entity weapon shot history debug display
---@return unknown
function Cursor_GetDrawWeaponShotHistory() end

--- Toggle cursor position information
---@return unknown
function Cursor_Info() end

--- Toggle cursor over entity weapon information
---@return unknown
function Cursor_WeaponInfo() end

--- Toggle cursor over entity weapon range information
---@return unknown
function Cursor_WeaponRanges() end

--- Toggles on or off under mouse check. If ignoring mouse check, all entities will have the enabled debug info displayed
---@return unknown
function Debug_IgnoreMouseOverCheck() end

--- Allows the local player to issue commands to any unit regardless of ownership.
---@return unknown
function Debug_ToggleControlAll() end

--- Toggles on or off all debug test activity
---@return unknown
function Debug_ToggleDebugTest() end

--- Query the display adapter database for a boolean setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckBoolOverride(setting) end

--- Query the display adapter database for a floating-point setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckFloatOverride(setting) end

--- Query the display adapter database for an integer setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckIntOverride(setting) end

--- Output the installed display adapter driver version, the required version for the current adapter, and whether or not the installed version is equal to or greater than the required one.
---@return unknown
function DisplayAdapterDatabase_CheckMinimumDriverVersion() end

--- Query the display adapter database for a uint16 setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckUint16Override(setting) end

--- Query the display adapter database for a uint8 setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckUint8Override(setting) end

--- Query the display adapter database for a uint32 setting override.
---@param setting string
---@return unknown
function DisplayAdapterDatabase_CheckUintOverride(setting) end

--- Query the display adapter database for information about a specified adapter.
---@param vendor string
---@param device string
---@param subsystem string
---@param revision string
---@return unknown
function DisplayAdapterDatabase_GetAdapterFromID(vendor, device, subsystem, revision) end

--- Output basic information about the current display adapter.
---@return unknown
function DisplayAdapterDatabase_GetAdapterID() end

--- Query the display adapter database for the minimum required driver version for a specified adapter.
---@param vendor string
---@param device string
---@param subsystem string
---@param revision string
---@return unknown
function DisplayAdapterDatabase_GetAdapterMinimumDriverVersion(vendor, device, subsystem, revision) end

--- Query the display adapter database for the performance class of the currently-installed display adapter.
---@return unknown
function DisplayAdapterDatabase_GetCurrentAdapterPerformanceClass() end

--- Output basic information about the currently installed display adapter driver.
---@return unknown
function DisplayAdapterDatabase_GetDriverInfo() end

--- Query the display adapter database for the performance class given a relative performance percentage.
---@param relativePerformance number
---@return unknown
function DisplayAdapterDatabase_GetPerformanceClass(relativePerformance) end

--- Toggle blockers info
---@return unknown
function FOW_Blockers() end

--- Force effects to be recreated.
---@return unknown
function fx_refresh() end

--- Get physics debug toggle value
---@return unknown
function GetPhysicsDebug() end

--- Get physics debug toggle value
---@return unknown
function GetPhysicsRaycastAsCapsuleDebug() end

--- Toggle hold info
---@return unknown
function Hold_Info() end

--- turns on the watcher and displays the lists if any
---@param on boolean
---@return unknown
function LCWatcher_Activate(on) end

--- Needs the proper luaConfig id, and looks through that list to add the filter.
---@param stateName string
---@param filter string
---@return unknown
function LCWatcher_AddFilter(stateName, filter) end

--- Needs the proper luaConfig id, returns true if filter exists.
---@param stateName string
---@param filter string
---@return unknown
function LCWatcher_FilterExists(stateName, filter) end

--- Returns true if LCWatcher is active.
---@return unknown
function LCWatcher_IsActive() end

--- Needs the proper luaConfig id, removes filter added by LCWatch_AddFilter.
---@param stateName string
---@param filter string
---@return unknown
function LCWatcher_RemoveFilter(stateName, filter) end

--- Selects a LuaConfig state to watch.  Returns true if state is registered and false if it has not.
---@param state string
---@return unknown
function LCWatcher_SelectState(state) end

--- Print text to specified file
---@param file string
---@param txt string
---@return unknown
function LogPrintTo(file, txt) end

--- Disable collecting and displaying render stats
---@return unknown
function MemoryStats_Disable() end

--- Enable collecting and displaying render stats
---@return unknown
function MemoryStats_Enable() end

--- Toggle collecting and displaying render stats
---@return unknown
function MemoryStats_Toggle() end

--- Clear entire draw pathfinding cell list
---@return unknown
function Path_ClearCells() end

--- Draw pathfinding impassable map
---@return unknown
function Path_DrawImpass() end

--- Toggle pathfinding entity path
---@return unknown
function Path_DrawPath() end

--- Draw pathfinding grid overlay
---@param onoff boolean
---@return unknown
function Path_DrawPathMap(onoff) end

--- Add pathfinding cell to draw cell list
---@param x number
---@param y number
---@return unknown
function Path_ShowCell(x, y) end

--- Add pathfinding precise cell to draw cell list
---@param x number
---@param y number
---@return unknown
function Path_ShowPreciseCell(x, y) end

--- Toggle pathfinding collision circles
---@return unknown
function Path_ToggleCollisionCircle() end

--- Reload mouse over entity's entire list of extension info's
---@return unknown
function PBG_ReloadMouseOverEntity() end

--- Reload mouse over squad's entire list of extension info's
---@return unknown
function PBG_ReloadMouseOverSquad() end

--- Reload mouse over squad's weapon property bag
---@return unknown
function PBG_ReloadMouseOverWeapon() end

--- Disable collecting and displaying render stats
---@return unknown
function RenderStats_Disable() end

--- Output the render stats to a CSV LogFile for viewing
---@return unknown
function RenderStats_DumpToLogFile() end

--- Enable collecting and displaying render stats
---@return unknown
function RenderStats_Enable() end

--- Set the render stats refresh update interval (seconds)
---@param time number
---@return unknown
function RenderStats_SetUpdateTime(time) end

--- Sort render stats by model instances (descending sort)
---@return unknown
function RenderStats_SortInstances() end

--- Sort render stats by render calls (descending sort)
---@return unknown
function RenderStats_SortRenderCalls() end

--- Sort render stats by shader changes (descending sort)
---@return unknown
function RenderStats_SortShaderChanges() end

--- Sort render stats by mesh triangles (descending sort)
---@return unknown
function RenderStats_SortTris() end

--- Toggle collecting and displaying render stats
---@return unknown
function RenderStats_Toggle() end

--- Toggle drawing debug info for scar markers
---@return unknown
function Scar_DrawMarkers() end

--- Toggle mouse over debug info on which group the entity belongs to
---@return unknown
function Scar_GroupInfo() end

--- Toggle a list of all egroups and sgroups in the game
---@return unknown
function Scar_GroupList() end

--- Disable collecting and displaying render stats
---@return unknown
function ShaderStats_Disable() end

--- Output the render stats to a CSV LogFile for viewing
---@return unknown
function ShaderStats_DumpToLogFile() end

--- Enable collecting and displaying render stats
---@return unknown
function ShaderStats_Enable() end

--- Set the render stats refresh update interval (seconds)
---@param time number
---@return unknown
function ShaderStats_SetUpdateTime(time) end

--- Sort render stats by model instances (descending sort)
---@return unknown
function ShaderStats_SortPixelCount() end

--- Sort render stats by model instances (descending sort)
---@return unknown
function ShaderStats_SortShaderNames() end

--- Toggle collecting and displaying render stats
---@return unknown
function ShaderStats_Toggle() end

--- Toggle check requirements information
---@return unknown
function Sim_CheckRequirements() end

--- Draw the current sim tick
---@return unknown
function Sim_DebugDrawSimTick() end

--- Toggle drawing debug info for the attention system
---@return unknown
function Sim_DrawAttention() end

--- Toggle the crush OBB
---@return unknown
function Sim_DrawEntityCrusherOBB() end

--- Toggle entity information
---@return unknown
function Sim_DrawEntityExtensions() end

--- Toggle entity move state debug drawing
---@return unknown
function Sim_DrawEntityStateMove() end

--- Toggle a list of all active abilities on the entity
---@return unknown
function Sim_EntityAbility() end

--- Draw the per-entity decision delay if there is one
---@return unknown
function Sim_EntityDelay() end

--- Toggle posture info text for selected entities
---@return unknown
function Sim_EntityDrawPosture() end

--- Toggle a list of all active modifiers on the entity
---@return unknown
function Sim_EntityHistory() end

--- Toggle entity information
---@return unknown
function Sim_EntityInfo() end

--- Toggle a list of all active modifiers on the entity
---@return unknown
function Sim_EntityModifier() end

--- Draw the OBBs for the entity
---@return unknown
function Sim_EntityOBB() end

--- Draw OOC target debug info
---@return unknown
function Sim_EntityOOCTarget() end

--- Toggle a list of all completed upgrades on the entity.
---@return unknown
function Sim_EntityUpgrades() end

--- Toggle a list of all active player abilities
---@return unknown
function Sim_PlayerInfo() end

--- Toggle a list of all active player modifiers
---@return unknown
function Sim_PlayerModifiers() end

--- Toggle simulation boxes for shot blockers only
---@return unknown
function Sim_ShotBlockers() end

--- Toggle simulation boxes for entities
---@return unknown
function Sim_SimBox() end

--- Toggle a list of all active modifiers on the entity
---@return unknown
function Sim_SquadHistory() end

--- Toggle squad information
---@return unknown
function Sim_SquadInfo() end

--- Toggle squad suppression information
---@return unknown
function Sim_SquadSuppression() end

--- Create a splat on the terrain
---@param _name string
---@param xpos number
---@param zpos number
---@param scale number
---@return unknown
function Terrain_CreateSplat(_name, xpos, zpos, scale) end

--- Draw a grid on the terrain with tunable increment
---@param increment number
---@return unknown
function Terrain_DrawGrid(increment) end

--- Draw lines on a grid on the terrain with tunable spacing
---@param spacing number
---@return unknown
function Terrain_DrawGridLines(spacing) end

--- Draw terrain material map cells
---@param onoff boolean
---@return unknown
function Terrain_DrawMaterialMap(onoff) end

--- Add a timer to be triggered every 'freqInSec'. the timer will then run the passed-in command
---@param command string
---@param freqInSec number
---@return unknown
function TimerAdd(command, freqInSec) end

--- Add a timer to be triggered every frame the timer will then run the passed-in command
---@param command string
---@return unknown
function TimerAddFrame(command) end

--- Add a timer to be triggered once after 'freqInSec' has elapsed. the timer will then run the passed-in command
---@param command string
---@param timeInSec number
---@return unknown
function TimerAddOnce(command, timeInSec) end

--- Remove specified timer
---@param command string
---@return unknown
function TimerDel(command) end

--- Toggles the scanning info from the ScanForTarget track for the debug entity
---@return unknown
function Toggle_Scanning_Info() end

--- Toggle physics debug drawing
---@param enable boolean
---@return unknown
function TogglePhysicsDebug(enable) end

--- Toggle physics debug drawing
---@param enable boolean
---@return unknown
function TogglePhysicsRaycastAsCapsuleDebug(enable) end

--- Toggles on or off vaulting debug drawing
---@return unknown
function Vaulting_DrawDebug() end

--- Toggle enabling all weapon gound attack
---@return unknown
function Weapon_AllWeaponAttackGround() end

--- Toggle weapon animation information
---@return unknown
function Weapon_AnimInfo() end

--- Toggle weapon attack radii around the entities
---@return unknown
function Weapon_AttackRadii() end

--- Toggle weapon firing lines
---@return unknown
function Weapon_Firing() end

--- Toggle weapon hard point information
---@return unknown
function Weapon_HardPointInfo() end

--- Toggle weapon state and calculation information
---@return unknown
function Weapon_Info() end

--- Toggle weapon best target result
---@return unknown
function Weapon_PrintBestTarget() end

--- Toggle weapon priority information (must TAG entity you want info about)
---@return unknown
function Weapon_PriorityInfo() end

--- Toggle weapon projectile denotation timer
---@return unknown
function Weapon_ProjectileDetonateTimer() end

--- Toggle weapon projectile information
---@return unknown
function Weapon_ProjectileInfo() end

--- Toggle weapon scatter target information
---@return unknown
function Weapon_ScatterInfo() end

--- Toggle weapon tracking lines and maximum angles
---@return unknown
function Weapon_Tracking() end

--- Draw line. If you don't pass in a name, TerrainLine is used.
---@param pos0 Position
---@param pos1 Position
---@param r number
---@param g number
---@param b number
---@param svar any
---@return unknown
function dr_drawline(pos0, pos1, r, g, b, svar) end

--- Draw circle on terrain.
---@param pos Position
---@param radius number
---@param r number
---@param g number
---@param b number
---@param divs number
---@param frame string
---@return unknown
function dr_terraincircle(pos, radius, r, g, b, divs, frame) end

--- Draw circle on terrain with lifetime.
---@param pos Position
---@param radius number
---@param r number
---@param g number
---@param b number
---@param divs number
---@param frame string
---@param lifetime number
---@return unknown
function dr_terraincirclewithlifetime(pos, radius, r, g, b, divs, frame, lifetime) end

--- Draw rectangle on terrian.
---@param pos Position
---@param w number
---@param h number
---@param r number
---@param g number
---@param b number
---@param rads number
---@return unknown
function dr_terrainrect(pos, w, h, r, g, b, rads) end

--- Gets the type of game we are playing ( GT_SP = 0, GT_MP = 1, GT_Skirmish = 2)
---@return unknown
function getgametype() end

--- Returns the local player index
---@return unknown
function getlocalplayer() end

--- Returns the scenario name (shortname version eg. "2P Semois")
---@return unknown
function getmapname() end

--- Returns the current simulation rate.
---@return unknown
function getsimrate() end

--- Run the specified scar script file
---@param scriptName string
---@return unknown
function Scar_DoFile(scriptName) end

--- Run the specified scar command
---@param str string
---@return unknown
function Scar_DoString(str) end

--- Reload all scar scripts
---@return unknown
function Scar_Reload() end

--- Pause the simulation.
---@return unknown
function setsimpause() end

--- DO NOT call this function directly, use Event_Save(STT_Auto) instead
---@return unknown
function __Internal_Game_Autosave() end

--- DO NOT call this function directly, use Event_Save(STT_Quick) instead
---@return unknown
function __Internal_Game_Quicksave() end

--- DO NOT call this function directly, use Event_SaveWithName(STT_Standard) instead
---@return unknown
function __Internal_Game_SaveGame() end

--- DO NOT call this function directly, use Event_SaveWithName(STT_Dev) instead
---@return unknown
function __Internal_Game_SaveToFileDev() end

--- Set whether or not an action marker is visible.
---@param name string
---@param visible boolean
---@return unknown
function ActionMarker_SetVisible(name, visible) end

--- Start the given action marker's FX.
---@param name string
---@return unknown
function ActionMarker_StartAction(name) end

--- Stop the given action marker's FX.
---@param name string
---@return unknown
function ActionMarker_StopAction(name) end

--- Adds a prefab to the AIPrefab system. Target must be set up in a follow up call with returned ID
---@param player Player
---@param name string
---@param behaviourName string
---@param radius number
---@param minDifficulty number
---@param maxDifficulty number
---@param canReassign boolean
---@param active boolean
---@return unknown
function AI_AddPrefab(player, name, behaviourName, radius, minDifficulty, maxDifficulty, canReassign, active) end

--- Log the combat result features of all squads owned by a player for a given conflict
---@param conflictID number
---@param playerA Player
---@param playerB Player
---@return unknown
function AI_CacheCombatFeatureTrainingData(conflictID, playerA, playerB) end

--- Get combat fitness estimate. Return value will be between 1.0 and 0.0. 1.0 means teamA wins outright, 0.0 means teamB wins outright.
--- Buildings will be filtered from attacking team
---@param teamASquads SGroup
---@param teamAEntities EGroup
---@param teamAPBGs PBG
---@param teamBSquads SGroup
---@param teamBEntities EGroup
---@param teamBPBGs PBG
---@param aiPlayerA Player
---@param playerB Player
---@param playerAIsAttacker boolean
---@return unknown
function AI_CalculateCombatFitnessEstimate(teamASquads, teamAEntities, teamAPBGs, teamBSquads, teamBEntities, teamBPBGs, aiPlayerA, playerB, playerAIsAttacker) end

--- Checks if this entity can cause suppression
---@param aiPlayer Player
---@param entity Entity
---@return unknown
function AI_CanEntityCauseSuppression(aiPlayer, entity) end

--- Check if the entity can load squad and shoot its target after loading (This function should only be called by AI)
---@param entity Entity
---@param squad Squad
---@param bCheckSquadState boolean
---@param bOverload boolean
---@return unknown
function AI_CanLoadSquadAndAttackCurrentTarget(entity, squad, bCheckSquadState, bOverload) end

--- Checks if this squad can cause suppression
---@param aiPlayer Player
---@param pSquad Squad
---@return unknown
function AI_CanSquadCauseSuppression(aiPlayer, pSquad) end

--- Checks if this squad can decrew the entity
---@param pDriverSquad Squad
---@param pDecrewTargetEntity Entity
---@return unknown
function AI_CanSquadDecrew(pDriverSquad, pDecrewTargetEntity) end

--- Clear a combat entry from the cache, typically done instead of logging it
---@param conflictID number
---@return unknown
function AI_ClearCombatTrainingCacheEntry(conflictID) end

--- Clear all intents associated with this AIPrefab
---@param prefabId UniqueID
---@param player Player
---@return unknown
function AI_ClearPrefabAIIntents(prefabId, player) end

--- Returns true if the configured input feature calculators characterizes this squad
---@param player Player
---@param squadPBG PBG
---@return unknown
function AI_CombatFitnessCharacterizesSquad(player, squadPBG) end

--- Returns the defensive upgrades for this structure archetype member
---@param memberPBG PBG
---@return unknown
function AI_CombatFitnessGetDefensiveUpgradesForStructureArchetypeMember(memberPBG) end

--- Returns healer feature option pbgs
---@return unknown
function AI_CombatFitnessGetHealerPBGs() end

--- Returns the offensive upgrades for this structure archetype member
---@param memberPBG PBG
---@return unknown
function AI_CombatFitnessGetOffensiveUpgradesForStructureArchetypeMember(memberPBG) end

--- Returns the player upgrades configured in the player upgrade input calculator
---@return unknown
function AI_CombatFitnessGetPlayerUpgrades() end

--- Returns squad pbgs for all squad archetypes
---@return unknown
function AI_CombatFitnessGetSquadArchetypeNames() end

--- Returns squad pbgs for a given archetype (assuming that archetype is composed of squad pbgs)
---@param archtypeNameStr string
---@return unknown
function AI_CombatFitnessGetSquadArchetypePBGs(archtypeNameStr) end

--- Returns entity pbgs for a given archetype (assuming that archetype is composed of entity pbgs)
---@param archtypeNameStr string
---@return unknown
function AI_CombatFitnessGetStructureArchetypePBGs(archtypeNameStr) end

--- Create the combat feature logs in the game log directory
---@return unknown
function AI_CreateAICombatFitnessLogs() end

--- Prints detailed rating debug info in the AILog for all squads and entities in the groups
---@param sgroup SGroup
---@param egroup EGroup
---@param player Player
---@return unknown
function AI_DebugLogGroupCombatRatings(sgroup, egroup, player) end

--- Prints detailed rating debug info in the AILog for all the PBGs in the list
---@param pbgList PBG
---@param player Player
---@return unknown
function AI_DebugLogPBGCombatRatings(pbgList, player) end

--- Find the closest open position from a given position for a given ability blueprint
---@param caster ConstTargetHandle
---@param pAbilityPBG PBG
---@param posIn Position
---@return unknown
function AI_FindClosestOpenPositionForAbility(caster, pAbilityPBG, posIn) end

--- Find the closest open position from a given position and ability blueprint, taking into account a min
---@param caster ConstTargetHandle
---@param pAbilityPBG PBG
---@param posIn Position
---@param minDist number
---@param maxDist number
---@return unknown
function AI_FindClosestOpenPositionForAbilityWithinRange(caster, pAbilityPBG, posIn, minDist, maxDist) end

--- Find the closest open position from a given position for a given Entity blueprint
---@param aiPlayer Player
---@param pEntityPBG PBG
---@param posIn Position
---@return unknown
function AI_FindClosestOpenPositionForStructure(aiPlayer, pEntityPBG, posIn) end

--- Returns the maximum number of targets for the given ability, or -1 if the ability is invalid.
---@param ability Ability
---@return unknown
function AI_GetAbilityMaxNumTargets(ability) end

--- Returns the current squad target for the given squad (null if no target, or target is non-squad entity)
---@param pSquad Squad
---@return unknown
function AI_GetAnySquadCombatTarget(pSquad) end

--- Log the combat input features of all squads owned by two players for a given conflict
---@param conflictID number
---@param playerA Player
---@param playerB Player
---@param score number
---@return unknown
function AI_LogCombatTrainingData(conflictID, playerA, playerB, score) end

--- Push an ai intent to an existing AIPrefab. Requires an ai_prefab_intent pbg name
---@param prefabId UniqueID
---@param player Player
---@param aiPrefabIntentBagName string
---@return unknown
function AI_PushPrefabAIIntent(prefabId, player, aiPrefabIntentBagName) end

--- Set the active status of an existing AIPrefab
---@param prefabId UniqueID
---@param player Player
---@param active boolean
---@return unknown
function AI_SetPrefabActive(prefabId, player, active) end

--- Set the can_reassign state of an existing AIPrefab
---@param prefabId UniqueID
---@param player Player
---@param canReassign boolean
---@return unknown
function AI_SetPrefabCanReassign(prefabId, player, canReassign) end

--- Set the squad selection of an existing AIPrefab by SGROUP
---@param prefabId UniqueID
---@param player Player
---@param squads SGroup
---@return unknown
function AI_SetPrefabSelection_SGroup(prefabId, player, squads) end

--- Set the target of an existing AIPrefab by EGROUP
---@param prefabId UniqueID
---@param player Player
---@param entities EGroup
---@return unknown
function AI_SetPrefabTarget_EGroup(prefabId, player, entities) end

--- Set the target of an existing AIPrefab by Position
---@param prefabId UniqueID
---@param player Player
---@param position Position
---@return unknown
function AI_SetPrefabTarget_Position(prefabId, player, position) end

--- Set the target of an existing AIPrefab by SGROUP
---@param prefabId UniqueID
---@param player Player
---@param squads SGroup
---@return unknown
function AI_SetPrefabTarget_SGroup(prefabId, player, squads) end

--- Set the target of an existing AIPrefab via waypoints
---@param prefabId UniqueID
---@param player Player
---@param waypointName string
---@return unknown
function AI_SetPrefabTarget_Waypoints(prefabId, player, waypointName) end

--- Checks if the cached path crosses known enemy territory
---@param aiPlayer Player
---@param requestingID number
---@param minDistToEnemyTerritory number
---@param unused boolean
---@return unknown
function AIPlayer_CachedPathCrossesEnemyTerritory(aiPlayer, requestingID, minDistToEnemyTerritory, unused) end

--- Test if player can see entity
---@param aiPlayer Player
---@param canSee Entity
---@return unknown
function AIPlayer_CanSeeEntity(aiPlayer, canSee) end

--- Delete the cached path with this ID, please remember to do this
---@param player Player
---@param requestingID number
---@return unknown
function AIPlayer_ClearCachedPath(player, requestingID) end

--- returns true if enemy territory has been detected
---@param player Player
---@return unknown
function AIPlayer_EnemyTerritoryDetected(player) end

--- Tests to see if any entity in the group is part of a wall that matches the supplied conditions eGroup contains list of entities to test, minSections is minimum number of connected wall sections, unbreached means all sections must be unbroken.  Returns closest entity to refPosition
---@param player Player
---@param eGroup EGroup
---@param minSections number
---@param unbreached boolean
---@param refPosition Position
---@return unknown
function AIPlayer_FindClosestSiegeTarget(player, eGroup, minSections, unbreached, refPosition) end

--- Find a clump containing the given position, or return -1 if there isn't one.
---@param aiPlayer Player
---@param pos Position
---@param targetFilterFlags number
---@return unknown
function AIPlayer_FindClumpContainingPosition(aiPlayer, pos, targetFilterFlags) end

--- Returns the anchor build position
---@param aiPlayer Player
---@return unknown
function AIPlayer_GetAnchorPosition(aiPlayer) end

--- returns a 0-based index of the best clump of enemy squads within the given tolerance to the position passed in
---@param pPlayer Player
---@param position Position
---@param pAbilityPBG PBG
---@param minRange number
---@param maxRange number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestClumpForPositionIdx(pPlayer, position, pAbilityPBG, minRange, maxRange, targetFilterFlags, minNumSquads) end

--- returns a 0-based index of the best clump of enemy squads within the given tolerance to the AI squad
---@param pPlayer Player
---@param pSquad Squad
---@param pAbilityPBG PBG
---@param minRange number
---@param maxRange number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestClumpForSquadIdx(pPlayer, pSquad, pAbilityPBG, minRange, maxRange, targetFilterFlags, minNumSquads) end

--- returns a 0-based index of the best clump of allied or enemy squads within the given tolerance to the AI player
---@param pPlayer Player
---@param minRange number
---@param maxRange number
---@param clumpSelectionGlobalBestMinRatio number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestClumpIdx(pPlayer, minRange, maxRange, clumpSelectionGlobalBestMinRatio, targetFilterFlags, minNumSquads) end

--- returns a 0-based index of the best clump of allied or enemy squads within the given tolerance to the AI player
---@param pPlayer Player
---@param pAbilityPBG PBG
---@param minRange number
---@param maxRange number
---@param clumpSelectionGlobalBestMinRatio number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestClumpIdxForAbility(pPlayer, pAbilityPBG, minRange, maxRange, clumpSelectionGlobalBestMinRatio, targetFilterFlags, minNumSquads) end

--- returns a 0-based index of the best clump of owned squads within the given tolerance to the AI player
---@param pPlayer Player
---@param minRange number
---@param maxRange number
---@param clumpSelectionGlobalBestMinRatio number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestOwnedClumpIdx(pPlayer, minRange, maxRange, clumpSelectionGlobalBestMinRatio, targetFilterFlags, minNumSquads) end

--- returns a 0-based index of the best clump of owned squads within the given tolerance to the AI player
---@param pPlayer Player
---@param pAbilityPBG PBG
---@param minRange number
---@param maxRange number
---@param clumpSelectionGlobalBestMinRatio number
---@param targetFilterFlags number
---@param minNumSquads number
---@return unknown
function AIPlayer_GetBestOwnedClumpIdxForAbility(pPlayer, pAbilityPBG, minRange, maxRange, clumpSelectionGlobalBestMinRatio, targetFilterFlags, minNumSquads) end

--- Get the distance of the path requested with the given ID. < 0 means invalid request.
---@param player Player
---@param requestingID number
---@return unknown
function AIPlayer_GetCachedPathLength(player, requestingID) end

--- Return the path points of the calculated path from a previous pathfinding request if the result was successful and the path has at least two points.
---@param player Player
---@param requestingID number
---@return unknown
function AIPlayer_GetCachedPathPoints(player, requestingID) end

--- Returns an EGroup containing all capture points on the map owned by a player with the specified
---@param aiPlayer Player
---@param relationshipEnum any
---@param onlyCanPlaceSecuringStructure boolean
---@param egroupOut EGroup
---@return unknown
function AIPlayer_GetCapturePoints(aiPlayer, relationshipEnum, onlyCanPlaceSecuringStructure, egroupOut) end

--- Used for tactics; returns a "special error position" on failure that's nowhere inside the world
---@param pPlayer Player
---@param clumpIndex number
---@param targetFilterFlags number
---@return unknown
function AIPlayer_GetClumpPosition(pPlayer, clumpIndex, targetFilterFlags) end

--- returns how close a position is to enemy territory
---@param player Player
---@param position Position
---@return unknown
function AIPlayer_GetDistanceToEnemyTerritory(player, position) end

--- Calculate product of all multipliers in tableName
--- The result is intended to be applied to the tuning value corresponding to tableName, for use in the AI military target scoring function Allowable strings for tableName: front_line
---@param aiPlayer Player
---@param tableName string
---@return unknown
function AIPlayer_GetDynamicMultiplier(aiPlayer, tableName) end

--- Calculate product of all unit type multipliers that match the entity's unit types
--- The result is intended to be used in the AI military target scoring function
---@param aiPlayer Player
---@param targetEntity Entity
---@return unknown
function AIPlayer_GetDynamicUnitTypeMultipliersForEntity(aiPlayer, targetEntity) end

--- Calculate product of all unit type multipliers that match a unit type of an entity in the squad
--- The result is intended to be used in the AI military target scoring function
---@param aiPlayer Player
---@param targetSquad Squad
---@return unknown
function AIPlayer_GetDynamicUnitTypeMultipliersForSquad(aiPlayer, targetSquad) end

--- Returns a list of all resource deposit entities seen by the AI player
---@param aiPlayer Player
---@param resourceType string
---@param includeDepleted boolean
---@return unknown
function AIPlayer_GetKnownResourceDeposits(aiPlayer, resourceType, includeDepleted) end

--- Returns the local AIPlayer given a PlayerId (1000 and up)
---@param playerId number
---@return unknown
function AIPlayer_GetLocal(playerId) end

--- Returns the local AIPlayer given a Player pointer
---@param pPlayerIn Player
---@return unknown
function AIPlayer_GetLocalFromPlayer(pPlayerIn) end

--- Get a homebase at the given position. If one doesn't exist it will be created.
---@param aiPlayer Player
---@param targetPosition Position
---@return unknown
function AIPlayer_GetOrCreateHomebase(aiPlayer, targetPosition) end

--- Used for tactics; returns a "special error position" on failure that's nowhere inside the world
---@param pPlayer Player
---@param clumpIndex number
---@return unknown
function AIPlayer_GetOwnedClumpPosition(pPlayer, clumpIndex) end

--- Returns an EGroup listing all military points owned by a player within a certain range of the position passed in that match a certain type
---@param militaryPointPBG EntityPBG
---@param position Position
---@param range number
---@return unknown
function AIPlayer_GetOwnedMilitaryPointEntitiesInRange(militaryPointPBG, position, range) end

--- Returns all positions of military points allied with a player
---@param aiPlayer Player
---@param relationshipEnum any
---@return unknown
function AIPlayer_GetPositionsOfMilitaryPointsWithRelation(aiPlayer, relationshipEnum) end

--- Returns the utility of building the squad specified by the PBG, or 0 if not found
---@param aiPlayer Player
---@param squadPBG Squad
---@return unknown
function AIPlayer_GetSquadPBGProductionUtility(aiPlayer, squadPBG) end

--- Has path to target passes through a netural damaged structure
---@param aiPlayer Player
---@param squad Squad
---@param structurePbg PBG
---@param damagePercentage number
---@param searchRadius number
---@param targetPosition Position
---@return unknown
function AIPlayer_IsDamagedStructureOnPathToTarget(aiPlayer, squad, structurePbg, damagePercentage, searchRadius, targetPosition) end

--- Returns whether the player is on an island (naval map) or not
---@return unknown
function AIPlayer_IsOnAnIsland() end

--- Has the requested path been processed
---@param aiPlayer Player
---@param requestedPathRequestID number
---@return unknown
function AIPlayer_IsPathProcessed(aiPlayer, requestedPathRequestID) end

--- Returns whether or not a point is threatened (from the perspective of the player passed in)
--- If enemy builds are not filtered, allied will be. ThresholdFitness is from allied perspective. Typically you want to filter enemy buildings when defending, allied when attacking
---@param aiPlayer Player
---@param pos Position
---@param filterEnemyBuildings boolean
---@param thresholdFitness number
---@return unknown
function AIPlayer_IsPointThreatened(aiPlayer, pos, filterEnemyBuildings, thresholdFitness) end

--- Remove a multiplier previously applied to change the weight of a criteria in target scoring
--- The multiplier will be removed from the table for the given tuningValueName. Pass in the multiplier id returned from AIPlayer_PushScoreMultiplier. Allowable strings for tuningValueName: front_line
---@param aiPlayer Player
---@param tuningValueName string
---@param id AIScoreMultiplierID
---@return unknown
function AIPlayer_PopScoreMultiplier(aiPlayer, tuningValueName, id) end

--- Remove a multiplier previously applied to a unit type for target scoring
--- The multiplier will be removed from the table for the given unitTypeName. Pass in the multiplier id used earlier with AIPlayer_PushScoreMultiplier.
---@param aiPlayer Player
---@param unitTypeName string
---@param id AIScoreMultiplierID
---@return unknown
function AIPlayer_PopUnitTypeScoreMultiplier(aiPlayer, unitTypeName, id) end

--- Was the processed path successful? Only supply requestID for a processed path
---@param aiPlayer Player
---@param processedPathRequestID number
---@return unknown
function AIPlayer_ProcessedPathSuccessful(aiPlayer, processedPathRequestID) end

--- Add a multiplier to change the weight of a criteria in target scoring
--- The multiplier will be pushed to a table for the given tuningValueName. All multipliers in the table will be multiplied together and applied to the corresponding static tuning value. The  multiplierID passed in can be passed to AIPlayer_PopScoreMultiplier to remove it. Allowable strings for tuningValueName: front_line DefendStructure AttackStructure EnemyClump
---@param aiPlayer Player
---@param tuningValueName string
---@param multiplier number
---@param multiplierID AIScoreMultiplierID
---@return unknown
function AIPlayer_PushScoreMultiplier(aiPlayer, tuningValueName, multiplier, multiplierID) end

--- Add a multiplier to give weight to a unit type in target scoring
--- The multiplier will be pushed to a table for the given unitTypeName. All multipliers in the table will be multiplied together and applied to targets with the corresponding unit type. multiplierId identifies the
---@param aiPlayer Player
---@param unitTypeName string
---@param multiplier number
---@param multiplierID AIScoreMultiplierID
---@return unknown
function AIPlayer_PushUnitTypeScoreMultiplier(aiPlayer, unitTypeName, multiplier, multiplierID) end

--- Remove entities (buildings) homebase assignment. Entities must be owned by player.
---@param aiPlayer Player
---@param eGroup EGroup
---@return unknown
function AIPlayer_RemoveEntityHomebase(aiPlayer, eGroup) end

--- Remove squads homebase assignment. Squads must be owned by player.
---@param aiPlayer Player
---@param sGroup SGroup
---@return unknown
function AIPlayer_RemoveSquadHomebase(aiPlayer, sGroup) end

--- Request a high path between the start and destination, supply a unique ID and the PBG of the largest entity that will be following the path.
---@param player Player
---@param requestingID number
---@param start Position
---@param _end Position
---@param pathingEntityPBG PBG
---@param requiresPartialPath boolean
---@return unknown
function AIPlayer_RequestHighPath(player, requestingID, start, _end, pathingEntityPBG, requiresPartialPath) end

--- Clears the ability priority override
---@param player Player
---@param abilityPBG PBG
---@return unknown
function AIPlayer_ResetAbilityPriorityOverride(player, abilityPBG) end

--- Clears the ability priority override for all the abilities contained in the AIAbilityBag
---@param player Player
---@param aiAbilityPBG PBG
---@return unknown
function AIPlayer_ResetAIAbilityPriorityOverride(player, aiAbilityPBG) end

--- Sets the ability priority override for all the AISquads owned by the player. -1 to disable the ability. NOTE: Encounter overrides have higher priority.
---@param player Player
---@param abilityPBG PBG
---@param priority number
---@return unknown
function AIPlayer_SetAbilityPriorityOverride(player, abilityPBG, priority) end

--- Sets the ability priority override for all the abilities contained in the AIAbilityBag for all the AISquads owned by the player. -1 to disable the ability. NOTE: Encounter overrides have higher priority.
---@param player Player
---@param aiAbilityPBG PBG
---@param priority number
---@return unknown
function AIPlayer_SetAIAbilityPriorityOverride(player, aiAbilityPBG, priority) end

--- Add entities (buildings) to a homebase. Entities must be owned by player.
---@param aiPlayer Player
---@param eGroup EGroup
---@param homeBaseID number
---@return unknown
function AIPlayer_SetEntityHomebase(aiPlayer, eGroup, homeBaseID) end

--- Add squads to a homebase. Squads must be owned by player.
---@param aiPlayer Player
---@param sGroup SGroup
---@param homeBaseID number
---@return unknown
function AIPlayer_SetSquadHomebase(aiPlayer, sGroup, homeBaseID) end

--- Set the base strategic intention of a player
---@param player Player
---@param intentionName string
---@param value number
---@return unknown
function AIPlayer_SetStrategicBaseIntention(player, intentionName, value) end

--- Toggle debug draw for the specified path, -1 will draw all of them
---@param requestingID number
---@param on boolean
---@return unknown
function AIPlayer_ToggleDrawCachedPath(requestingID, on) end

--- Updates what the skirmish AI is wanting to gather
---@param pPlayer Player
---@return unknown
function AIPlayer_UpdateGathering(pPlayer) end

--- Requests the skirmish AI to update attack encounters and capture tasks
---@param pPlayer Player
---@return unknown
function AIPlayer_UpdateSkirmishAttackAndCaptureTasks(pPlayer) end

--- Requests the skirmish AI to update player abilities
---@param pPlayer Player
---@return unknown
function AIPlayer_UpdateSkirmishPlayerAbilities(pPlayer) end

--- Updates what the skirmish AI is trying to produce
---@param pPlayer Player
---@return unknown
function AIPlayer_UpdateSkirmishProduction(pPlayer) end

--- Requests the skirmish AI to update scout encounters
---@param pPlayer Player
---@return unknown
function AIPlayer_UpdateSkirmishScoutingTasks(pPlayer) end

--- Tries to find cover within a certain radius of a position, traveling a max distance to get there, and possibly comparing against current position's cover. If no cover is found, it returns an invalid position
---@param player Player
---@param aiSquad Squad
---@param maxPathDistanceFromGoal number
---@param compareToCurrentCover boolean
---@return unknown
function AISquad_FindFilteredCoverCompareCurrent(player, aiSquad, maxPathDistanceFromGoal, compareToCurrentCover) end

--- Returns the closest cuttable obstruction entity to the given squad
---@param pSquad Squad
---@param radius number
---@return unknown
function AISquad_GetClosestCuttableObstruction(pSquad, radius) end

--- Returns the closest obstruction entity to the given squad
---@param pSquad Squad
---@param radius number
---@param bFilterAllied boolean
---@return unknown
function AISquad_GetClosestObstruction(pSquad, radius, bFilterAllied) end

--- Returns the closest obstruction entity to the given squad
---@param pSquad Squad
---@param radius number
---@param pbgtype PBG
---@return unknown
function AISquad_GetClosestObstructionOfType(pSquad, radius, pbgtype) end

--- Get the position on the far side of the given clump relative to the given squad.
---@param aiSquad Squad
---@param clumpIndex number
---@param targetFilterFlags number
---@return unknown
function AISquad_GetClumpFarBound(aiSquad, clumpIndex, targetFilterFlags) end

--- returns the current fallback position
---@param aiSquad Squad
---@return unknown
function AISquad_GetCurrentFallBackPosition(aiSquad) end

--- Checks if the squad has been attacked within this time
---@param pAISquad Squad
---@param historyTicks number
---@return unknown
function AISquad_HasBeenAttacked(pAISquad, historyTicks) end

--- Checks if the squad has fired its weapon within this time
---@param pAISquad Squad
---@param historyTicks number
---@return unknown
function AISquad_HasFiredWeapon(pAISquad, historyTicks) end

--- Returns true if a path shorter than maxDistance between the AISquad and the target exists
---@param aiSquad Squad
---@param targetPosition Position
---@param maxDistance number
---@return unknown
function AISquad_HasPathWithinDistance(aiSquad, targetPosition, maxDistance) end

--- Checks if the squad should fall back or brace itself given the current situation.
---@param pAISquad Squad
---@return unknown
function AISquad_ShouldFallBackOrBraceSelf(pAISquad) end

--- Get the number of seconds on an objective timer.
---@param objectiveID number
---@return unknown
function AITactic_GetObjectiveTimerSeconds(objectiveID) end

--- Returns all ScarMarkers from the Scenario Editor with the given name. If you don't care about the type, pass in an empty string ( "" )
--- The type is defined on the ScarMarkerBlueprint in the Scenario Editor\n
---@param name string
---@param type string
---@return unknown
function AllMarkers_FromName(name, type) end

--- Remove the movie mode framerate restriction
---@return unknown
function App_ClearMovieModeFramerate() end

--- Return the current app time
---@return unknown
function app_currenttime() end

--- Set the ideal frame rate for the game. Set to 0 if an unbounded frame rate is desired.
---@param frameRate number
---@return unknown
function app_setidealframerate(frameRate) end

--- Run the game at specified frame rate (for capturing movies). Only works with 60 or 120, other rates are defaulted to 60. Setting it to 0 disables movie mode
---@param frameRate number
---@return unknown
function App_SetMovieModeFramerate(frameRate) end

--- Clamps the camera's target position to a marker.
---@param marker Marker
---@return unknown
function Camera_ClampToMarker(marker) end

--- Execute spline pan based on queued control points. Use B-Spline interpolation of points
---@param totalT number
---@param controlRotation boolean
---@return unknown
function Camera_ExecuteBSplinePan(totalT, controlRotation) end

--- Executes a camera pan that was captured using the Capture Tool. Expects that the "camera_spline" Camera set was pushed to the CameraSwitchboard, using Camera_Push("camera_spline") Returns the duration of the spline, so that the user can call Camera_Pop()
---@param cameraPanTable StackVarTable
---@return unknown
function Camera_ExecuteCaptureCameraPan(cameraPanTable) end

--- Execute spline pan based on queued control points. Use Catmull-Rom interpolation of points
---@param totalT number
---@param controlRotation boolean
---@return unknown
function Camera_ExecuteCatromSplinePan(totalT, controlRotation) end

--- Execute spline pan based on queued control points. Use linear interpolation between points
---@param totalT number
---@param controlRotation boolean
---@return unknown
function Camera_ExecuteLinearSplinePan(totalT, controlRotation) end

--- Focus the camera on the specified position.
---@param position Position
---@return unknown
function Camera_FocusOnPosition(position) end

--- Make the camera follow the specified entity.
---@param entity Entity
---@return unknown
function Camera_FollowEntity(entity) end

--- Make the camera follow the current full selection.
---@return unknown
function Camera_FollowSelection() end

--- Make the camera follow the specified squad.
---@param squad Squad
---@return unknown
function Camera_FollowSquad(squad) end

--- Get the current position for the camera. (Where the the camera currently is.)
---@return unknown
function Camera_GetCurrentPos() end

--- Get the current target position for the camera. (Where the the camera currently is.)
---@return unknown
function Camera_GetCurrentTargetPos() end

--- Get the current camera declination (tilt).
---@return unknown
function Camera_GetDeclination() end

--- Get the default camera orbit (rotation).
---@return unknown
function Camera_GetDefaultOrbit() end

--- Get the current camera orbit (rotation).
---@return unknown
function Camera_GetOrbit() end

--- Get the pivot of the camera. (The position about which the camera is pivoting).
--- For autodeclinate camera, this is the lookat position.
---@return unknown
function Camera_GetPivot() end

--- Get the desired target position for the camera. (Where the camera is trying to get to.)
---@return unknown
function Camera_GetTargetPos() end

--- Get the current zoom distance for the camera.
---@return unknown
function Camera_GetZoomDist() end

--- Hide the camera mesh.
---@return unknown
function Camera_HideMesh() end

--- Returns the enabled/disabled state of the camera input.  (not deterministic)
---@return unknown
function Camera_IsInputEnabled() end

--- Is the camera mesh being shown?
---@return unknown
function Camera_IsMeshShown() end

--- Queue a spline control point by position relative to the last queued position. Pan is deferred until requested by an execution function
---@param deltaPos Position
---@return unknown
function Camera_QueueRelativeSplinePanPos(deltaPos) end

--- Queue a spline control point by absolute position. Pan is deferred until requested by an execution function
---@param pos Position
---@return unknown
function Camera_QueueSplinePanPos(pos) end

--- Make the camera stop following anything.
---@return unknown
function Camera_ResetFocus() end

--- Set the current camera orbit relative to the current orbit (relative rotation).
---@return unknown
function Camera_ResetOrbit() end

--- Reset camera position to default home position
---@return unknown
function Camera_ResetToDefault() end

--- Set the current camera declination (tilt).
---@param declination number
---@return unknown
function Camera_SetDeclination(declination) end

--- Set the default camera declination (tilt).
---@param declination number
---@return unknown
function Camera_SetDefaultDeclination(declination) end

--- Set the default camera orbit (rotation).
---@param orbit number
---@return unknown
function Camera_SetDefaultOrbit(orbit) end

--- Set the default zoom distance for the camera.
---@param distance number
---@return unknown
function Camera_SetDefaultZoomDist(distance) end

--- Set the current camera field of view (fov)
---@param fov number
---@return unknown
function Camera_SetFov(fov) end

--- Enables/disables camera input.
---@param enabled boolean
---@return unknown
function Camera_SetInputEnabled(enabled) end

--- Set the current camera orbit (rotation).
---@param orbit number
---@return unknown
function Camera_SetOrbit(orbit) end

--- Set the current camera orbit relative to the current orbit (relative rotation).
---@param deltaOrbit number
---@return unknown
function Camera_SetOrbitRelative(deltaOrbit) end

--- Set the current zoom distance for the camera.
---@param distance number
---@return unknown
function Camera_SetZoomDist(distance) end

--- Show the camera mesh.
---@return unknown
function Camera_ShowMesh() end

--- Orbit the camera a given number of degrees clockwise from the current orbit position in a given amount of time.
---@param deltaOrbit number
---@param totalT number
---@return unknown
function Camera_StartDeltaOrbit(deltaOrbit, totalT) end

--- Orbit the camera to an end orbit position from the current orbit position in a given amount of time. Will choose shortest rotational direction.
---@param endOrbit number
---@param totalT number
---@return unknown
function Camera_StartOrbit(endOrbit, totalT) end

--- Pan the camera between two positions in a given amount of time. Interpolates the camera to the given zoom.
---@param startPos Position
---@param endPos Position
---@param totalT number
---@param zoomDistance number
---@return unknown
function Camera_StartPan(startPos, endPos, totalT, zoomDistance) end

--- Pan the camera to a position in a given amount of time from the position in front of the queue.
---@param endPos Position
---@param totalT number
---@param zoomDistance number
---@return unknown
function Camera_StartPanTo(endPos, totalT, zoomDistance) end

--- Pan the camera by some amount in a given amount of time. This is relative to the position in front of the queue.
---@param deltaPos Position
---@param totalT number
---@param zoomDistance number
---@return unknown
function Camera_StartRelativePan(deltaPos, totalT, zoomDistance) end

--- Start a transition to a relative zoom distance over a certain amount of time.
---@param deltaZoomDist number
---@param totalT number
---@return unknown
function Camera_StartRelativeZoomDist(deltaZoomDist, totalT) end

--- Start a transition from one zoom distance to another over a certain amount of time.
---@param startZoomDist number
---@param endZoomDist number
---@param totalT number
---@return unknown
function Camera_StartZoomDist(startZoomDist, endZoomDist, totalT) end

--- Start a transition to a zoom distance over a certain amount of time.
---@param endZoomDist number
---@param totalT number
---@return unknown
function Camera_StartZoomDistTo(endZoomDist, totalT) end

--- Stop an ongoing camera pan.
---@return unknown
function Camera_StopPan() end

--- Toggle the debug free camera
---@return unknown
function Camera_ToggleDebugCamera() end

--- Toggle the camera mesh.
---@param show boolean
---@return unknown
function Camera_ToggleMeshShown(show) end

--- Frees up the camera (so it's not clamped to a marker anymore).
---@return unknown
function Camera_Unclamp() end

--- Cheat to award all ribbons and medals
---@return unknown
function Cheat_GrantAllRibbonsAndMedals() end

--- Cheat to reset all achievement progress
---@return unknown
function Cheat_ResetAchievementProgress() end

--- Get the value for a command line arg.
---@param name string
---@return unknown
function cmdline_string(name) end

--- Hide the cursor
---@return unknown
function cursor_hide() end

--- Set the cursor position
---@param x number
---@param y number
---@return unknown
function cursor_setposition(x, y) end

--- Show the cursor
---@return unknown
function cursor_show() end

--- Get dca variable value for an entity. Can be used to validate presentation state from lua.
---@param pEntity Entity
---@param variableName string
---@return unknown
function dca_get_variable_value(pEntity, variableName) end

--- Returns the current decal id in use; used in conjunction with Decal_RemoveAllDecalsAfterId
---@return unknown
function Decal_GetNextDecalId() end

--- Erases all placed decals after id (inclusive); used in conjunction with Decal_GetNextDecalId
---@param id number
---@return unknown
function Decal_RemoveAllDecalsAfterId(id) end

--- Clear debug rendering.
---@param frame string
---@return unknown
function dr_clear(frame) end

--- Draw a circle, positioned in 3D, aligned to scren.
---@param frame string
---@param x number
---@param y number
---@param z number
---@param radius number
---@param r number
---@param g number
---@param b number
---@return unknown
function dr_drawCircle(frame, x, y, z, radius, r, g, b) end

--- Set auto clear for named frame.
---@param frame string
---@param bEnable boolean
---@return unknown
function dr_setautoclear(frame, bEnable) end

--- Set display of named frame.
---@param frame string
---@param bEnable boolean
---@return unknown
function dr_setdisplay(frame, bEnable) end

--- Draw text, positioned in 2D, aligned to the screen.
--- (x,y) gives position in normalized screen coordinates cmd is the text to print r,g,b give colour values from 0-255
---@param frame string
---@param x number
---@param y number
---@param cmd string
---@param r number
---@param g number
---@param b number
---@return unknown
function dr_text2d(frame, x, y, cmd, r, g, b) end

--- Draw text, positioned in 3D, aligned to screen.
---@param frame string
---@param x number
---@param y number
---@param z number
---@param cmd string
---@param r number
---@param g number
---@param b number
---@return unknown
function dr_text3d(frame, x, y, z, cmd, r, g, b) end

--- Draw the ref-posed OBB of a model
---@param pModel RenderModel
---@param transform Transform
---@return unknown
function DrawOBB(pModel, transform) end

--- Calls an Entity_ function on every entity in an egroup
--- Example: EGroup_CallEntityFunction( eg_emplacements, Entity_SetAnimatorAction, actionName ) will call Entity_SetAnimatorAction( entity, actionName ) for every entity in eg_emplacements The first parameter of the supplied function must be EntityID
---@param egroup EGroup
---@param entityFunction function
---@param argument_list any
---@return unknown
function EGroup_CallEntityFunction(egroup, entityFunction, argument_list) end

--- Returns whether ALL or ANY entities in an egroup satisfy a condition, using an Entity_ function to perform the query on each entity
--- Example: EGroup_CallEntityFunctionAllOrAny( eg_emplacements, ANY, Misc_IsEntityOnScreen, pct ) will call Misc_IsEntityOnScreen( entity, pct ) to determine whether ANY entity in eg_emplacements is on screen The first parameter of the supplied function must be EntityID
---@param egroup EGroup
---@param all boolean
---@param entityFunction function
---@param argument_list any
---@return unknown
function EGroup_CallEntityFunctionAllOrAny(egroup, all, entityFunction, argument_list) end

--- Starts a save event the same way as Event_Start, but automatically sets highest priority and promotes the request
--- up the queue automatically. It waits for the existing event to finish, and does not cancel the existing event. STT_Quick: Saves the game by user request. Name is generated from campaign mission or skirmish preset name. STT_Auto: Campaign only. Saves the game by script request. Name is generated from campaign mission. STT_Standard: Saves the game using the name provided, overwriting if necessary - a suitable filename will be generated - saves to Campaign or Skirmish folder depending on currently running scenario STT_Dev: Saves the game using the filename provided - for development and testing only
---@param type SaveTriggerType
---@return unknown
function Event_Save(type) end

--- Starts a save event the same way as Event_Save, but with a filename specified.
--- STT_Quick: Saves the game by user request. Name is generated from campaign mission or skirmish preset name. Supplied filename is ignored. STT_Auto: Campaign only. Saves the game by script request. Name is generated from campaign mission. Supplied filename is ignored. STT_Standard: Saves the game using the name provided, overwriting if necessary - a suitable filename will be generated - saves to Campaign or Skirmish folder depending on currently running scenario STT_Dev: Saves the game using the filename provided - for development and testing only
---@param type SaveTriggerType
---@param fileName string
---@return unknown
function Event_SaveWithName(type, fileName) end

--- Calculate the dimensions and centre offset of a formation for given squads.  Returns as a ScarPosition {x = Width, y = Height, z = centre offset along forward (Height) direction}.  Returns a zero vector if error.
---@param sgroup SGroup
---@return unknown
function Formation_GetDimensionsAndOffset(sgroup) end

--- Place an SGroup or table of SGroups in formation
---@param sgroup SGroup
---@param position Position
---@param direction Position
---@return unknown
function Formation_PlaceSquadGroupsInFormation(sgroup, position, direction) end

--- Calculate formation positions and set the squads' positions to the formation positions
---@param sgroup SGroup
---@param position Position
---@param direction Position
---@return unknown
function Formation_PlaceSquadsInFormation(sgroup, position, direction) end

--- force the gamma
---@return unknown
function fx_dump() end

--- force the LOD of the FX system (use 0 to enable dynamic LOD)
---@param lod number
---@return unknown
function fx_forcelod(lod) end

--- enable logging of fx, it it wasn't already
---@param enable boolean
---@return unknown
function fx_logenable(enable) end

--- toggle effects on or off
---@return unknown
function fx_toggle() end

--- toggle effects rendering on or off
---@return unknown
function fx_toggleRendering() end

--- use the debugshader, which will render all fx green
---@param enable boolean
---@return unknown
function fx_usedebugshader(enable) end

--- Take over control of the local player
---@return unknown
function Game_AIControlLocalPlayer() end

--- deletes save game(s), even if it is not loadable with the current version of the game
---@param filename string
---@return unknown
function Game_DeleteSaveGameDev(filename) end

--- Enables/Disables all input EXCEPT for ESC and F10.
---@param enable boolean
---@return unknown
function Game_EnableInput(enable) end

--- Fast forward all production queues as if x seconds passed, returns info about what has been produced Returns a lua table of the format { (string)PlayerID : { (string)EntityProducerName : { "research" : { (string)researchedItemName : (int)number of times researched }, "production" : { (string)producedItemName : (int)number of items produced }, }, }, } for each player present, for each entity that produced after fast forwarding, for each item researched and produced
---@param secondsForward number
---@return unknown
function Game_FastForwardProduction(secondsForward) end

--- For all players fast forwards their resource income as if x seconds passed
---@param secondsForward number
---@return unknown
function Game_FastForwardResourceIncome(secondsForward) end

--- get the simulation update rate
---@return unknown
function Game_GetSimRate() end

--- Returns current single player difficulty. Values are GD_EASY, GD_NORMAL, GD_HARD, GD_EXPERT.
---@return unknown
function Game_GetSPDifficulty() end

--- injects terrain type values into passed table to use for terrain creation
---@param terrainVars StackVarTable
---@return unknown
function Game_GetTerrainTypeVariables(terrainVars) end

--- Returns lock state of stored data at location named by dataID.
---@param dataID string
---@return unknown
function Game_IsDataLocked(dataID) end

--- check if scenario has FTUE boolean set in match setup
---@return unknown
function Game_IsFtue() end

--- Use to test whether the game is running in RTM mode or not. Using -rtm from the command line will cause this function to also return true in non-RTM builds.
---@return unknown
function Game_IsRTM() end

--- Checks that the save system has a save queued or is actively saving.
---@return unknown
function Game_IsSaving() end

--- load this scenario as an single player match
---@param biomePbgName string
---@param layoutPbgName string
---@param sizePbgName string
---@param difficulty number
---@param terrainResult StackVarTable
---@return unknown
function Game_LaunchSPGeneratedMap(biomePbgName, layoutPbgName, sizePbgName, difficulty, terrainResult) end

--- Load data store to disk
---@param id string
---@param path string
---@param binary boolean
---@return unknown
function Game_LoadDataStore(id, path, binary) end

--- load this game as a single player match, full path is expected excluding extension
---@param filename string
---@return unknown
function Game_LoadFromFileDev(filename) end

--- load the savegame with the given internal name from Campaign or Skirmish folder depending on currently running scenario
---@param name string
---@return unknown
function Game_LoadGame(name) end

--- load this scenario as an single player match
---@param scenarioName string
---@param difficulty number
---@return unknown
function Game_LoadSP(scenarioName, difficulty) end

--- If you are running something that is non-deterministic like a getlocalplayer conditional, you can lock the random to make sure no one down the callstack will throw the game random index out of sync and cause a sync error. REMEMBER TO UNLOCK WHEN YOU ARE DONE
---@return unknown
function Game_LockRandom() end

--- Quits the app immediately
---@return unknown
function Game_QuitApp() end

--- Quits the app immediately with the given exitCode
---@param exitCode number
---@return unknown
function Game_QuitAppWithCode(exitCode) end

--- Removes the data store at the given path.
---@param path string
---@return unknown
function Game_RemoveTableData(path) end

--- Loads table data stored at datastore[dataID] into global lua table var named <dataID>. Set clearFromStorage to true to clear data from store.
---@param dataID string
---@param clearFromStorage boolean
---@return unknown
function Game_RetrieveTableData(dataID, clearFromStorage) end

--- Save data store to disk
---@param id string
---@param path string
---@param binary boolean
---@return unknown
function Game_SaveDataStore(id, path, binary) end

--- checks if the save game exists in dev folder and is loadable, filename is expected excluding folder and extension
---@param filename string
---@return unknown
function Game_SaveGameExistsDev(filename) end

--- Fades the screen to a given RGBA colour over a number of seconds
---@param r number
---@param g number
---@param b number
---@param a number
---@param timeSecs number
---@return unknown
function Game_ScreenFade(r, g, b, a, timeSecs) end

--- Updates the status of an in-game achievement or challenge.
---@param player Player
---@param eventType ChallengeEventType
---@param amount number
---@return unknown
function Game_SendCustomChallengeEvent(player, eventType, amount) end

--- sets lock state for stored data at location named by dataID.
---@param dataID string
---@param lock boolean
---@return unknown
function Game_SetDataLock(dataID, lock) end

--- set the simulation update rate
---@param rate number
---@return unknown
function Game_SetSimRate(rate) end

--- Brings up the pause menu. The game does not get paused until the end of the current sim tick, so anything that comes after Game_ShowPauseMenu in your function will still get executed, as well as any rules set to run during that frame.
---@return unknown
function Game_ShowPauseMenu() end

--- Stores provided table into long-lived data store at location named by dataID.
---@param dataID string
---@param table RefTable
---@return unknown
function Game_StoreTableData(dataID, table) end

--- Transitions to another atmosphere. Overwrites current transitions. Uses predefined atmosphere settings (only compatible with EEditor maps).
---@param stateName string
---@param transitionTimeSec number
---@return unknown
function Game_TransitionToState(stateName, transitionTimeSec) end

--- unlock the random from a previous lockrandom call only
---@return unknown
function Game_UnLockRandom() end

--- get camera name from PBG path
---@param pbgPath string
---@return unknown
function GetCameraNameFromPbgName(pbgPath) end

--- A class-like object used as a Singleton to read and write a JSON file
--- Initializes based on command line parameter -test_result_file <alias:path>. Checks for temporary logs on creation and inserts them into the result data. NOTE: A lot of information in the file is redundant to make it easier to process and easier to read for a human.
---@return unknown
function Initialize() end

--- Dump content of inventory to a file
---@return unknown
function inv_dump() end

--- Returns true if the pbg class list contains a type that has economic utility
---@param pbg PBG
---@return unknown
function IsEconomyClassStructure_CS(pbg) end

--- Can this structure be used to secure territory
---@param pbg PBG
---@return unknown
function IsSecuringStructure_CS(pbg) end

--- Can this structure be used to secure territory
---@param pbg PBG
---@return unknown
function IsSecuringStructurePlacedOnPoint_CS(pbg) end

--- Returns true if this object is a structure (something with a site_ext)
---@param pbg PBG
---@return unknown
function IsStructure_CS(pbg) end

--- Print all players information.
---@return unknown
function listplayers() end

--- Get the player's equipped elite at the specified index for their currently set race
---@param player Player
---@param index number
---@return unknown
function Loadout_GetEquippedArmyUnitAtIndex(player, index) end

--- Get the number of elites currently equipped for the player's current race
---@param player Player
---@return unknown
function Loadout_GetEquippedArmyUnitsCount(player) end

--- DEV ONLY: Converts ansi text to localized text.
--- Your text will have to get localized properly at some point before final. When converting text with this function you will get LOC: prefixed to your text
---@param string string
---@return unknown
function LOC(string) end

--- Returns an empty localized string.
---@return unknown
function Loc_Empty() end

--- Returns a localized string containing the integer.
---@param integer number
---@return unknown
function Loc_FormatInteger(integer) end

--- Returns a localized string containing the number to the specified number of decimal places.
---@param number number
---@param numDecimalPlaces number
---@return unknown
function Loc_FormatNumber(number, numDecimalPlaces) end

--- Returns a formatted time string in hours, minutes, and seconds. can omit leading zeroes.
---@param secs number
---@param leading_zeroes boolean
---@return unknown
function Loc_FormatTime_H_M_S(secs, leading_zeroes) end

--- Returns a formatted time string in minutes and seconds. can omit leading zeroes.
---@param secs number
---@param leading_zeroes boolean
---@return unknown
function Loc_FormatTime_M_S(secs, leading_zeroes) end

--- Returns a formatted time string in minutes, seconds, and milliseconds. can omit leading zeroes.
---@param secs number
---@param leading_zeroes boolean
---@return unknown
function Loc_FormatTime_M_S_MS(secs, leading_zeroes) end

--- Returns the localized string identified by the specified id.
---@param id any
---@return unknown
function Loc_GetString(id) end

--- Run simulation and presentation in lockstep, with simulation ticked every frame (useful for debugging sync errors)
---@return unknown
function lockstep_simulation_presentation_toggle() end

--- Start an Action at the given position.  Returns the id so the Action can be stopped using Marker_StopActionById.
---@param name string
---@param pos Position
---@return unknown
function Marker_StartActionAt(name, pos) end

--- Stop an Action by id.  Marker_StartActionAt returns an id that can be used here.
---@param id number
---@return unknown
function Marker_StopActionById(id) end

--- Write the OS map of allocated memory to the log folder
---@return unknown
function memdump() end

--- Write the OS map of allocated memory to the log folder
---@param foldername string
---@return unknown
function memdumpf(foldername) end

--- Returns the numbers of memory pools
---@return unknown
function mempoolcount() end

--- Given a poolID it will return the current memory in use
---@param int number
---@return unknown
function mempoolinuse(int) end

--- Given a poolID it will return the max amount of memory this pool has allocated
---@param int number
---@return unknown
function mempoolmax(int) end

--- Given a poolID it will return the name of the pool
---@param poolid number
---@return unknown
function mempoolname(poolid) end

--- Ask the OS to reduce the memory allocated to the game
---@return unknown
function memshrink() end

--- Write to a file all allocation content for specified pool
---@param pool string
---@return unknown
function memtofile(pool) end

--- Abort straight out of the game to the frontend, without asking the user
---@return unknown
function Misc_AbortToFE() end

--- Let AI take over local player
---@return unknown
function Misc_AIControlLocalPlayer() end

--- Appends given string to a file expects to receive a filename with an alias conserves existing file content \return Number returned is # bytes successfully written
---@param filename string
---@param text string
---@return unknown
function Misc_AppendToFile(filename, text) end

--- Returns true if the app has had any keyboard input in the last second
---@param sinceTime number
---@return unknown
function Misc_DetectKeyboardInput(sinceTime) end

--- Returns true if the app has had any mouse input in the last second
---@param sinceTime number
---@return unknown
function Misc_DetectMouseInput(sinceTime) end

--- Turn on or off the performance test monitoring
---@param toEnable boolean
---@return unknown
function Misc_EnablePerformanceTest(toEnable) end

--- Returns the string argument for a command line option. ex: for "-init test.lua" it would return "test.lua"
---@param option string
---@return unknown
function Misc_GetCommandLineString(option) end

--- returns the size of the file expects to receive a filename with an alias \return file size OR 0 if the file can not be read
---@param filename string
---@return unknown
function Misc_GetFileSize(filename) end

--- Returns true if -option is specified on the command line
---@param option string
---@return unknown
function Misc_IsCommandLineOptionSet(option) end

--- Returns whether the game is running in dev mode.
---@return unknown
function Misc_IsDevMode() end

--- Check if position is on screen, (1 being the entire screen, 0.5 being 50% of the screen from the center point)
---@param pos Position
---@param percent number
---@return unknown
function Misc_IsPosOnScreen(pos, percent) end

--- Assumes 'data:' as root; Returns a table containing the names of files matching the supplied path.
--- Wildcards are allowed.
---@param pathQuery string
---@param recursiveFind boolean
---@return unknown
function Misc_QueryDataDirectory(pathQuery, recursiveFind) end

--- Returns a table containing the names of files matching the supplied path.
--- Wildcards are allowed.
---@param pathQuery string
---@param recursiveFind boolean
---@return unknown
function Misc_QueryDirectory(pathQuery, recursiveFind) end

--- Reads the file as string expects to receive a filename with an alias \return file content OR empty string if the file can not be read
---@param filename string
---@return unknown
function Misc_ReadFile(filename) end

--- Deletes the given file expects to receive a filename with an alias \return true if file was deleted or did not exist in the first place, false otherwise
---@param filename string
---@return unknown
function Misc_RemoveFile(filename) end

--- Save a screenshot
---@return unknown
function Misc_Screenshot() end

--- Set the graphic file type for screenshot (.jpg, .tga)
---@param fileExtension string
---@return unknown
function Misc_ScreenshotExt(fileExtension) end

--- Sets the current autotest being used.  Used to set default text in the crash reports
---@param description string
---@return unknown
function Misc_SetCurrentAutotest(description) end

--- Shows or hides designer splats, which are splats in the UI folder
---@param bVisible boolean
---@return unknown
function Misc_SetDesignerSplatsVisibility(bVisible) end

--- Writes the given string to a file expects to receive a filename with an alias overwrites any existing file content \return Number returned is # bytes successfully written
---@param filename string
---@param text string
---@return unknown
function Misc_WriteFile(filename, text) end

--- Applies an entity modifier to an entity. Use a duration of 0 for an indefinite modifier.
---@param modifier ScarModifier
---@param entity Entity
---@param durationSeconds number
---@return unknown
function Modifier_ApplyToEntity(modifier, entity, durationSeconds) end

--- Applies a player modifier to a player. Use a duration of 0 for an indefinite modifier.
---@param modifier ScarModifier
---@param player Player
---@param durationSeconds number
---@return unknown
function Modifier_ApplyToPlayer(modifier, player, durationSeconds) end

--- Applies a squad modifier to a squad. Use a duration of 0 for an indefinite modifier.
---@param modifier ScarModifier
---@param squad Squad
---@param durationSeconds number
---@return unknown
function Modifier_ApplyToSquad(modifier, squad, durationSeconds) end

--- Returns a modifier that you can apply to stuff.
--- applicationType : MAT_EntityType, MAT_Entity, MAT_Player, MAT_Squad, MAT_SquadType, MAT_Weapon, MAT_EntityTypeAndDescendants,\n or MAT_SquadTypeAndDescendants.\n modtype : Name of modifier from the modifiers table in the attribute editor.\n usageType : MUT_Addition, MUT_Multiplication, MUT_MultiplyAdd or MUT_Enable.\n exclusive : This field is not currently used for modifiers created through script. \n value : The value for the modifier.\n extname : The name of the entity/squad blueprint for when the applicationType is MAT_EntityType, MAT_SquadType,\n MAT_EntityTypeAndDescendants or MAT_SquadTypeAndDescendants
---@param applicationType ModifierApplicationType
---@param modtype string
---@param usageType ModifierUsageType
---@param exclusive boolean
---@param value number
---@param v any
---@return unknown
function Modifier_Create(applicationType, modtype, usageType, exclusive, value, v) end

--- Set up tables to track modifiers that are applied per resource
--- The game specific <game_title>/modifiers.scar file should define tables with an entry per resource and pass them as arguments
---@return unknown
function Modifier_InitResourceBasedModifierTables() end

--- Checks whether the modifier is enabled (requires an Entity and an Entity enable/disable modifier)
---@param pEntity Entity
---@param modtype string
---@param bEnabledByDefault boolean
---@return unknown
function Modifier_IsEnabled(pEntity, modtype, bEnabledByDefault) end

--- Start capturing a movie, optionally downscaling to low resolution.
---@param lowResolution boolean
---@return unknown
function MovieCapture_Start(lowResolution) end

--- Stop a previously started movie capture.
---@return unknown
function MovieCapture_Stop() end

--- toggle the outstanding network call information
---@return unknown
function network_show_calls() end

--- toggle the network statgraph
---@return unknown
function network_show_statgraph() end

--- Create an objective and returns the unique ID for it
--- titleLocID and descLocID are the localization IDs for the title and description text. icon is the path to the objective icon type could be OT_Primary, OT_Secondary, OT_Bonus OT_Information
---@param player Player
---@param title string
---@param desc string
---@param icon string
---@param dataTemplate string
---@param faction string
---@param type ObjectiveType
---@param parentID number
---@param telemetryTitle string
---@return unknown
function Obj_Create(player, title, desc, icon, dataTemplate, faction, type, parentID, telemetryTitle) end

--- Delete the objective with the specified ID
---@param objectiveID number
---@return unknown
function Obj_Delete(objectiveID) end

--- Delete all objectives
---@return unknown
function Obj_DeleteAll() end

--- Get the count of the counter on the objective.
---@param objectiveID number
---@return unknown
function Obj_GetCounterCount(objectiveID) end

--- Get the maximum count of the counter on the objective.
---@param objectiveID number
---@return unknown
function Obj_GetCounterMax(objectiveID) end

--- Get the counter type of an objective.
---@param objectiveID number
---@return unknown
function Obj_GetCounterType(objectiveID) end

--- Get objective progress bar value
---@param objectiveID number
---@return unknown
function Obj_GetProgress(objectiveID) end

--- Get objective progress bar visibility  (not deterministic)
---@param objectiveID number
---@return unknown
function Obj_GetProgressVisible(objectiveID) end

--- Get objective state ( OS_Off, OS_Incomplete, OS_Complete, OS_Failed ) (not deterministic)
---@param objectiveID number
---@return unknown
function Obj_GetState(objectiveID) end

--- Get objective visibility  (not deterministic)
---@param objectiveID number
---@return unknown
function Obj_GetVisible(objectiveID) end

--- Set colour of objective. In order red, green, blue, alpha.
---@param objectiveID number
---@param red number
---@param green number
---@param blue number
---@param alpha number
---@return unknown
function Obj_SetColour(objectiveID, red, green, blue, alpha) end

--- Set the count of the counter on the objective.
---@param objectiveID number
---@param count number
---@return unknown
function Obj_SetCounterCount(objectiveID, count) end

--- Set the maximum count of the counter on the objective.
---@param objectiveID number
---@param max number
---@return unknown
function Obj_SetCounterMax(objectiveID, max) end

--- Set the number of seconds on an objective with a timer. Only used to inform the UI.
---@param objectiveID number
---@param timerSeconds number
---@return unknown
function Obj_SetCounterTimerSeconds(objectiveID, timerSeconds) end

--- Set the counter type of an objective.
---@param objectiveID number
---@param counterType number
---@return unknown
function Obj_SetCounterType(objectiveID, counterType) end

--- Set description text localization ID for the objective
---@param objectiveID number
---@param desc string
---@return unknown
function Obj_SetDescription(objectiveID, desc) end

--- Set icon path for the objective
---@param objectiveID number
---@param icon string
---@return unknown
function Obj_SetIcon(objectiveID, icon) end

--- Set callback functions for the objective.  (not deterministic)
--- FN_OnActivate is for triggering situation report. FN_OnShow is used to assign UI element when tactical map is open. FN_OnSelect is used to assign UI element when the objective is highlighted
---@param id number
---@param fnType ObjectiveFn
---@param f function
---@return unknown
function Obj_SetObjectiveFunction(id, fnType, f) end

--- Set objective progress bar value
---@param objectiveID number
---@param progress number
---@return unknown
function Obj_SetProgress(objectiveID, progress) end

--- Set objective progress bar visibility
---@param objectiveID number
---@param visible boolean
---@return unknown
function Obj_SetProgressVisible(objectiveID, visible) end

--- Set objective state ( OS_Off, OS_Incomplete, OS_Complete, OS_Failed )
--- Objectives must be visible for state changes to take effect.
---@param objectiveID number
---@param state State
---@return unknown
function Obj_SetState(objectiveID, state) end

--- Set title text localization ID for the objective
---@param objectiveID number
---@param title string
---@return unknown
function Obj_SetTitle(objectiveID, title) end

--- Set objective visibility
---@param objectiveID number
---@param visible boolean
---@return unknown
function Obj_SetVisible(objectiveID, visible) end

--- Disable displaying the Essence Profiler
---@return unknown
function PerfStats_Disable() end

--- Dump the Essence Profiler data onto a file
---@return unknown
function PerfStats_Dump() end

--- Enable displaying the Essence Profiler
---@return unknown
function PerfStats_Enable() end

--- Get perf stats toggle value
---@return unknown
function PerfStats_IsEnabled() end

--- Toggle displaying the Essence Profiler
---@return unknown
function PerfStats_Toggle() end

--- Returns the number of rigid bodies in the physical world
---@return unknown
function Physics_GetNumRBodies() end

--- Returns true if the current specs allows for physics to play
---@return unknown
function Physics_IsEnabled() end

--- Returns the current game state of the player.
---@param pPlayer Player
---@return unknown
function Player_GetState(pPlayer) end

--- Returns the current game state of the player.
---@return unknown
function Player_GetTributeIncrementModifier() end

--- Prints a message on the screen
--- Prints the given message on the screen. It will stay there until you call PrintOnScreen_RemoveFromScreen() or print another message on the screen to replace it.
---@param text string
---@return unknown
function PrintOnScreen(text) end

--- Prints the lua content of an object on the screen
--- Prints the given message on the screen. If you would like to print multiple messages without clearing them you can assign them unique ID's. Must use PrintOnScreen_Remove(id) to remove each instance
---@param object Object
---@param id string
---@param style string | nil
---@return unknown
function PrintOnScreen_Add(object, id, style) end

--- Removes the PrintOnScreen text of a given ID
---@param id string
---@return unknown
function PrintOnScreen_Remove(id) end

--- Remove any messages from the screen
--- Removes from the screen any messages put there with PrintOnScreen()
---@return unknown
function PrintOnScreen_RemoveFromScreen() end

--- Exit to windows
---@return unknown
function quit() end

--- Disable rendering and render update
---@return unknown
function render_viewport_toggle() end

--- Restart a single player game, skirmish game, or the front end. (doesn't work in multiplayer games)
---@return unknown
function restart() end

--- Activate the scar RulesProfiler
---@param on boolean
---@return unknown
function RulesProfiler_Activate(on) end

--- Enable the scar RulesProfiler so it runs in the background. Call this before RulesProfiler_Activate
---@param on boolean
---@return unknown
function RulesProfiler_Enable(on) end

--- Returns true if the scar RulesProfiler is active
---@return unknown
function RulesProfiler_IsActive() end

--- Don't filter the RulesProfiler displayed rules.
---@return unknown
function RulesProfiler_ResetTypeFilter() end

--- Filter the RulesProfiler to filter displayed rules to given type. E.g., "SCAR", "AI"
---@param filter string
---@return unknown
function RulesProfiler_SetTypeFilter(filter) end

--- execute command string in cheat menu domain. Will only work if dev mode is enabled! (it's OFF by default in RTM builds)
---@param command string
---@return unknown
function Scar_DebugCheatMenuExecute(command) end

--- execute console command string. Will only work if dev mode is enabled! (it's OFF by default in RTM builds)
---@param command string
---@return unknown
function Scar_DebugConsoleExecute(command) end

--- Returns ST_NIL,ST_BOOLEAN,ST_NUMBER,ST_STRING,ST_TABLE,ST_FUNCTION,ST_SCARPOS,ST_EGROUP,ST_ENTITY,ST_SGROUP,ST_SQUAD,ST_TEAM,ST_MARKER, ST_PBG, or ST_UNKNOWN
---@param v any
---@return unknown
function scartype(v) end

--- Returns a string representing the scartype when passed a scartype enum value
---@param v any
---@return unknown
function scartype_enum_tostring(v) end

--- Returns a string representing the scartype
---@param v any
---@return unknown
function scartype_tostring(v) end

--- Set the simulation rate
---@param fcap number
---@return unknown
function setsimframecap(fcap) end

--- Set the simulation rate
---@param rate number
---@return unknown
function setsimrate(rate) end

--- Fill table with win condition options - schema is loaded from .win file
---@param outOptions StackVarTable
---@return unknown
function Setup_GetWinConditionOptions(outOptions) end

--- Set the UI name of a given player.
---@param player Player
---@param name string
---@return unknown
function Setup_SetPlayerName(player, name) end

--- Set the race for a given player.  Use World_GetRaceBlueprint() to get the race id from the ME name.
---@param player Player
---@param racePBG ScarRacePBG
---@return unknown
function Setup_SetPlayerRace(player, racePBG) end

--- Set the starting position of a given player.
---@param player Player
---@param pos Position
---@return unknown
function Setup_SetPlayerStartingPosition(player, pos) end

--- Put a player in a team. Use TEAM_NEUTRAL as the team_id to set the player as neutral
---@param p Player
---@param team_id number
---@return unknown
function Setup_SetPlayerTeam(p, team_id) end

--- Calls an Entity_ function on every entity in an sgroup
--- Example: SGroup_CallEntityFunction( sg_riflemen, Entity_SetCrushable, false ) will call Entity_SetCrushable( entity, false ) for every entity in sg_riflemen. The first parameter of the supplied function must be EntityID
---@param sgroup SGroup
---@param entityFunction function
---@param argument_list any
---@return unknown
function SGroup_CallEntityFunction(sgroup, entityFunction, argument_list) end

--- Calls a Squad_ function on every squad in an sgroup
--- Example: SGroup_CallSquadFunction( sg_riflemen, Squad_IncreaseVeterancyRank, 2, true ) will call Squad_IncreaseVeterancyRank( squad, 2, true ) for every squad in sg_riflemen. The first parameter of the supplied function must be SquadID
---@param sgroup SGroup
---@param squadFunction function
---@param argument_list any
---@return unknown
function SGroup_CallSquadFunction(sgroup, squadFunction, argument_list) end

--- Returns whether ALL or ANY squads in an sgroup satisfy a condition, using a Squad_ function to perform the query on each squad
--- Example: SGroup_CallSquadFunctionAllOrAny( sg_commandos, ANY, Misc_IsSquadOnScreen, pct ) will call Misc_IsSquadOnScreen( squad, pct ) to determine whether ANY squad in sg_commandos is on screen The first parameter of the supplied function must be SquadID
---@param sgroup SGroup
---@param all boolean
---@param squadFunction function
---@param argument_list any
---@return unknown
function SGroup_CallSquadFunctionAllOrAny(sgroup, all, squadFunction, argument_list) end

--- Is the Market info currently being drawn?
---@return unknown
function Sim_GetDrawMarketInfo() end

--- Clears the egroup, then finds and adds all trade entities registered with an entity endpoint
--- Returns the number of entities found
---@param endpoint Entity
---@param egroup EGroup
---@return unknown
function Sim_GetTradeEntitiesFromEndpoint(endpoint, egroup) end

--- Add a settlement to the market trade manager with specified ID. Settlement will be marked 'not trading' with all players.
---@param settlement Entity
---@return unknown
function Sim_MarketAddSettlement(settlement) end

--- Attempts to execute a trade on behalf of the specified player, for the specified resource, of the specified type.
---@param player Player
---@param resourceName string
---@param tradeTypeString string
---@return unknown
function Sim_MarketExecuteTrade(player, resourceName, tradeTypeString) end

--- Sets market trade status between two players, using the array index they appear at in PlayerManager::GetPlayers_CS()
---@param firstPlayer Player
---@param secondPlayer Player
---@param status boolean
---@return unknown
function Sim_MarketSetTradeStatusPlayer(firstPlayer, secondPlayer, status) end

--- Sets trade status between a player number and a settlement ID.
---@param player Player
---@param settlement Entity
---@param status boolean
---@return unknown
function Sim_MarketSetTradeStatusSettlement(player, settlement, status) end

--- Set/clear drawing of the market info.
---@param bEnable boolean
---@return unknown
function Sim_SetDrawMarketInfo(bEnable) end

--- Play the specified movie.
---@param url string
---@return unknown
function SitRep_PlayMovie(url) end

--- Stop the currently playing movie.
---@return unknown
function SitRep_StopMovie() end

--- Toggles the display of the terrain audio environment zones on/off.
---@param enable boolean
---@return unknown
function Sound_Debug_ShowAudioRegions(enable) end

--- Returns true if the sound associated with the handle is currently playing.
---@param handle number
---@return unknown
function Sound_IsPlaying(handle) end

--- Plays a 2D sound. Returns a handle to the sound event.
--- The sound will be 2D \Sound_Play2D( "VictoryEvent" )\n
---@param eventName string
---@return unknown
function Sound_Play2D(eventName) end

--- Plays a 3D sound on the entity. Returns a handle to the sound event.
--- The sound will be 3D. \Sound_Play3D( "AddOnComplete", TheActor )\n
---@param eventName string
---@param actor Entity
---@return unknown
function Sound_Play3D(eventName, actor) end

--- Posts an event on an already playing sound. Returns a handle to the new sound event.
--- Can be used to e.g. call a stop event or enable/disable effects on playing sounds. \Sound_PostEvent( "VictoryEvent", handle )\n
---@param eventName string
---@param handle number
---@return unknown
function Sound_PostEvent(eventName, handle) end

--- Stops sound associated with the handle.
---@param handle number
---@return unknown
function Sound_Stop(handle) end

--- A closure-based class-like object for performing unit-tests and outputting test-results
--- unique_name 			A name used as identifier in the json result file unit_tests 				A table containing UnitTest objects which this driver manages is_long_test 			(Optional, default is false) The driver will only run if the command line argument -TestLong is set
---@param unique_name_Table_unit_tests_Boolean_is_long_test string
---@return unknown
function standard_test(unique_name_Table_unit_tests_Boolean_is_long_test) end

--- A closure-based class-like object defining a single unit test
--- unique_name 		- Unique name of the test. It is used as a key in the JSON result file. description 		- Description of this test and the feature it tests. start_function 		- Executed at test start to setup any preconditions to running the test (e.g. spawning a unit) update_function 	- Function which is repeatedly executed to test when the test should end. Should return true when the test needs to continue and false when the test needs to end. e.g. a timer which returns true until 5 seconds have elapsed, a predicate which returns true while a unit is still alive etc. finish_function 	- A predicate which tests the success of the test. This is invoked when the test is finished (indicated by the update function). If finish returns true then the test is successful otherwise the test is a failure. timeout_seconds 	- A timeout will result in test termination and the test will be considered a failure.
---@param unique_name_String_description_Function_start_function_Function_update_function_Function_finish_function_Number_timeout_seconds string
---@return unknown
function standard_test(unique_name_String_description_Function_start_function_Function_update_function_Function_finish_function_Number_timeout_seconds) end

--- Run a global state tree on an entity
--- The state tree will be queued to run when safe to do so. A global state tree has its own lifetime, separate from any other state trees running on the target. parameters: - keepAlive: whether the state tree should restart if it finishes running - openingBranchName: name of state tree node to run - entity: the entity to run the tree on. This will be the context owner for the spawned state controller
---@param keepAlive boolean
---@param openingBranchName string
---@param entity Entity
---@return unknown
function StateTree_QueueGlobalStateTreeEntity(keepAlive, openingBranchName, entity) end

--- Run a global state tree on a player
--- The state tree will be queued to run when safe to do so. A global state tree has its own lifetime, separate from any other state trees running on the target. parameters: - keepAlive: whether the state tree should restart if it finishes running - openingBranchName: name of state tree node to run - player: the player to run the tree on. This will be the context owner for the spawned state controller
---@param keepAlive boolean
---@param openingBranchName string
---@param player Player
---@return unknown
function StateTree_QueueGlobalStateTreePlayer(keepAlive, openingBranchName, player) end

--- Run a global state tree on a squad
--- The state tree will be queued to run when safe to do so. A global state tree has its own lifetime, separate from any other state trees running on the target. parameters: - keepAlive: whether the state tree should restart if it finishes running - openingBranchName: name of state tree node to run - squad: the squad to run the tree on. This will be the context owner for the spawned state controller
---@param keepAlive boolean
---@param openingBranchName string
---@param squad Squad
---@return unknown
function StateTree_QueueGlobalStateTreeSquad(keepAlive, openingBranchName, squad) end

--- Save the statgraph output to a file
---@param begin boolean
---@return unknown
function statgraph_save(begin) end

--- Predicate testing if a value is of specific type
--- e.g. f = std.TypePredicate(); f() => 1; f() => 2 ...
---@return unknown
function std() end

--- Performs basic type-checking on [value]
--- e.g. foo = 7; std.Validate(foo, 'foo', T_NUMBER, false)
---@return unknown
function std() end

--- Makes an assertion. If the assertion turns out to be false, raises an error.
--- e.g. foo = 7; assert(foo ~= nil, 'foo should not be nil!', 'If foo is nil we don't know how many bars to spawn!'') This is intended to be a more scripter friendly version of LUA assert.
---@return unknown
function std() end

--- Change the local player.
---@param state lua_State
---@return unknown
function switchplayer(state) end

--- Checks whether a sync weapon can attack a target without moving or turning.
---@param weapon SyncWeaponID
---@param target EGroup
---@return unknown
function SyncWeapon_CanAttackNow(weapon, target) end

--- Returns true if a sync weapon still exists in the game world
---@param weapon SyncWeaponID
---@return unknown
function SyncWeapon_Exists(weapon) end

--- Returns the EntityID of a sync weapon, or nil if it's been destroyed
---@param weapon SyncWeaponID
---@return unknown
function SyncWeapon_GetEntity(weapon) end

--- Registers the sync weapon in the egroup and returns a SyncWeaponID you can use to keep track of it
---@param egroup EGroup
---@return unknown
function SyncWeapon_GetFromEGroup(egroup) end

--- Registers the sync weapon in the sgroup and returns a SyncWeaponID you can use to keep track of it
---@param sgroup SGroup
---@return unknown
function SyncWeapon_GetFromSGroup(sgroup) end

--- Returns the position of a sync weapon, or nil if it's been destroyed
---@param weapon SyncWeaponID
---@return unknown
function SyncWeapon_GetPosition(weapon) end

--- Checks whether or not the actual sync weapon in a squad attacking.
---@param weapon SyncWeaponID
---@param time number
---@return unknown
function SyncWeapon_IsAttacking(weapon, time) end

--- Returns true if the specified player owns the sync weapon. Use a playerid of nil to see if it's unonwed.
--- If player is not specified, then the code will check to see if the SyncWeapon is owned by the world.
---@param weapon SyncWeaponID
---@param player Player | nil
---@return unknown
function SyncWeapon_IsOwnedByPlayer(weapon, player) end

--- Sets whether a weapon to auto-target things or not
---@param weapon SyncWeaponID
---@param hardpoint string
---@param enable boolean
---@return unknown
function SyncWeapon_SetAutoTargetting(weapon, hardpoint, enable) end

--- Creates a third table that points to every element in table1 and table2, in that order
---@param table1 LuaTable
---@param table2 LuaTable
---@return unknown
function Table_Concatenate(table1, table2) end

--- Checks if a table contains the specified item
---@param OriginalTable LuaTable
---@param item Item
---@return unknown
function Table_Contains(OriginalTable, item) end

--- Copies the contents of the original table returns a new table with the contents of that table
---@param OriginalTable LuaTable
---@return unknown
function Table_Copy(OriginalTable) end

--- Updates myTable by applying default values from the myDefaults table for any items that are not explicitly declared already
--- If the myDefaults table has any item with the value REQUIRED_DATA, then you are declaring that there is no default for this item and that you REQUIRE the user provides a value. You will get a Fatal Scar Error if these are left out, listing exactly which required keys are missing.
---@param myTable table
---@param myDefaults table
---@param errorMessage string | nil
---@return unknown
function Table_FillWithDefaultValues(myTable, myDefaults, errorMessage) end

--- Returns a random item from a table. You can return multiple items (without duplicates) by passing in an optional number parameter.
---@param table table
---@param numberofitems number | nil
---@return unknown
function Table_GetRandomItem(table, numberofitems) end

--- CHecks if a table contains the specified key
---@param table LuaTable
---@param key any
---@return unknown
function Table_HasKey(table, key) end

--- Makes a table read-only. This can be done recursively to also apply to any subtables.
--- Any attempts to write to this table after this has been called will trigger a Fatal SCAR Error. You can customize the error message that will be given with the "error" parameter.
---@param table table
---@param recursive boolean | nil
---@param errorMessage string | nil
---@return unknown
function Table_MakeReadOnly(table, recursive, errorMessage) end

--- Finds the first instance of a given item in the given table and removes it
---@param table table
---@param toRemove OBJECT
---@return unknown
function Table_RemoveFirstItem(table, toRemove) end

--- Reverse the order of items in a table.
---@param table table
---@return unknown
function Table_Reverse(table) end

--- Randomizes the order of items in a table.
---@param table table
---@return unknown
function Table_Shuffle(table) end

--- Takes a ScarPosition and returns a number representing the cover type at this position
---@param pos Position
---@return unknown
function Terrain_GetCoverType_AsNumber(pos) end

--- Takes a ScarPosition and returns a string representing the cover type at this position
---@param pos Position
---@return unknown
function Terrain_GetCoverType_AsString(pos) end

--- Verify that a provided SBP spawns in game correctly
---@param table_of_tests_to_pass_blueprint_name a
---@param name_of_the_SBP_to_spawn_expected_population the
---@param value_to_provide_the_expected_population_cost_of_the_unit_timeout_seconds Optional
---@param how_long_before_the_test_times_out Optional
---@return unknown
function Test_SpawnSquad(table_of_tests_to_pass_blueprint_name, name_of_the_SBP_to_spawn_expected_population, value_to_provide_the_expected_population_cost_of_the_unit_timeout_seconds, how_long_before_the_test_times_out) end

--- optional expect_kill overrides automatic targeting discovery
---@return unknown
function Test_SquadAttackMove() end

--- optional expect_kill overrides automatic targeting discovery
---@return unknown
function Test_SquadAttackMoveEntity() end

--- Movement test designed to allow for optional facing
--- Spawns a given unit blueprint and moves them to the given target destination, rotating the unit to the optional given facing if given upon arrival.
---@param t_test_group_string_blueprint_name_table_move_and_face_targets_float_move_pos_x_float_move_pos_z_float_face_pos_x__optional__float_face_pos_z__optional__int_timeout_seconds__optional___default_20__int_desired_tick_rate__optional__float_move_target_acceptable_distance__optional___default_0_5__float_facing_tolerance_degrees__optional___default_5__float_spawn_pos_x__optional___default_7_5__float_spawn_pos_z__optional___default_7_5__float_deviation_tolerance__optional___default_1_0_ table
---@return unknown
function Test_SquadMoveWithOptionalFacing(t_test_group_string_blueprint_name_table_move_and_face_targets_float_move_pos_x_float_move_pos_z_float_face_pos_x__optional__float_face_pos_z__optional__int_timeout_seconds__optional___default_20__int_desired_tick_rate__optional__float_move_target_acceptable_distance__optional___default_0_5__float_facing_tolerance_degrees__optional___default_5__float_spawn_pos_x__optional___default_7_5__float_spawn_pos_z__optional___default_7_5__float_deviation_tolerance__optional___default_1_0_) end

--- Auto generates a test configuration template and stores it for later saving. This is a debug feature.
--- The system tries to gather the parameters of the calling function and auto generates a template for it. The resulting template is added to a list which is written to cache:AutoConfig.json (see TestConfig_SaveCachedTestTemplates() above). If you use a non json compatible type you need to update _SerializeParameters above. See example for ScarPos.
---@param _optional__target_stack_level_to_grab_the_parameters_from_name_____optional__give_the_test_a_name_to_make_it_easier_to_identify_in_logs_config_files stack_level
---@return unknown
function TestConfig_AutoGenerateTestTemplate(_optional__target_stack_level_to_grab_the_parameters_from_name_____optional__give_the_test_a_name_to_make_it_easier_to_identify_in_logs_config_files) end

--- Tries to load the test configuration from the command line argument. See TEST_CONFIG_ARGUMENT_TEST_CONFIG above. See definition of TestConfig_LoadFromFile.
---@return unknown
function TestConfig_LoadFromCommandLine() end

--- Tries to load the test configuration from the given file.
--- The test configuration file is a json file containing groups of tests. Each test is defined with a function to call and its parameters. The system parses the file and tries to invoke the functions in the global space (by calling _G[function_string] ). Tests marked as active: false are skipped. Parameters either need to be json compatible (strings,  numbers, boolean) or have a 'constructor' function associated to them. e.g: 2D positions { "parameters": [ 0, -20 ], "func": "Util_ScarPos" }
---@param path__containing_alias__to_the_file_e_g__cache_AutoConfig_json path
---@return unknown
function TestConfig_LoadFromFile(path__containing_alias__to_the_file_e_g__cache_AutoConfig_json) end

--- Writes the tests to a json file.
---@return unknown
function TestConfig_SaveCachedTestTemplates() end

--- expect_destruction=nil will let the test determine this value based on entity targeting settings
--- expect_destruction=nil will let the test determine this value based on entity targeting settings
---@return unknown
function TestGroup_BuildingBasics() end

--- idx used to should be unique per run to prevent entity stacking
--- expect_destruction=nil will let the test determine this value based on entity targeting settings
---@return unknown
function TestGroup_SquadBasics() end

--- small version of TestGroup_SquadBasics() without the combat-specific tests
---@return unknown
function TestGroup_SquadBasics_NoCombat() end

--- spawns instances of an unit in a grid, then kills it to trigger physics destruction. Fails if to rigid bodies where created. params table : testName, unitPath, quantity, spacing, slowdown,  timeout_seconds, use_telemetry
---@return unknown
function TestPhysics_Destruction() end

--- Calls given method/parameter combinations one at a time to avoid blocking for long calls.
--- Expects to receive a table in the format of {{func=<function>,params=<table-containing-parameters in order}}. Calls one function at a time and queues the next function after completing the call. This allows the engine to simulate in between and will not block the other threads for extended amounts of time. Useful for tests that spawn a large amount of squads and entities and need to give them commands. Giving a callback to notify when the list has been processed is optional.
---@param t_function_parameter_function_callback table
---@return unknown
function TestUtil_CallWithoutBlocking(t_function_parameter_function_callback) end

--- Destroy neutral entities like wrecks, gaia, etc
---@return unknown
function TestUtil_DestroyAllNeutralEntities() end

--- Destroy player squads and entities
---@param player Player
---@return unknown
function TestUtil_DestroyAllPlayerSquadsAndEntities(player) end

--- Destorys all player owned squads and every player or neutral entity
---@return unknown
function TestUtil_DestroyAllSquadsAndEntities() end

--- Destroy specified player squads and entities from the blueprint list
--- Destroys all squads and entities belonging to player that match one of the
---@param player Player
---@param t_blueprintsToDestroy string
---@return unknown
function TestUtil_DestroySpecifiedPlayerSquadsAndEntities(player, t_blueprintsToDestroy) end

--- Returns all blueprints that match the given filters.
--- Filters the property bags inside attrib/instances and returns the paths that match the filters. After matching the base filter this part of the path is removed and the detail filter is applied. Example: base_filter "sbps\\races\\eng\\" will match all english units. detail filter "archer" will return return a table with "unit_archer_2_eng", "unit_archer_3_eng", "unit_archer_4_eng"
---@param do_entity___true_for_entity_blueprints boolean
---@param for_squad_blueprints_string_base_filter___specify_a_string_that_matches_a_path_inside_attrib_instances_usually_used_to_match_a_folder_table_of_strings___specify_a_black_list_filter_after_the_base_filter_has_been_applied_usually_used_to_exclude_files_based_on_string_matches__e_g___villager_armed__ false
---@return unknown
function TestUtil_GetAllBlueprintNames(do_entity___true_for_entity_blueprints, for_squad_blueprints_string_base_filter___specify_a_string_that_matches_a_path_inside_attrib_instances_usually_used_to_match_a_folder_table_of_strings___specify_a_black_list_filter_after_the_base_filter_has_been_applied_usually_used_to_exclude_files_based_on_string_matches__e_g___villager_armed__) end

--- Draws a circle at the given location.
--- calls a render debug function in a way that creates a visible outline on terrain. Any provided colour value that isn't within the char bit range (0 - 255) will be adjusted. The colour, segment and thickness parameters are optional and will default to reasonable values if excluded.
---@param position_real_radius_real_opt_lifetime_real_opt_red_value_real_opt_green_value_real_opt_blue_value_real_opt_number_of_circle_segments_int_opt_thickness_of_circle_border Position
---@return unknown
function TestUtil_HighlightCircleRadius(position_real_radius_real_opt_lifetime_real_opt_red_value_real_opt_green_value_real_opt_blue_value_real_opt_number_of_circle_segments_int_opt_thickness_of_circle_border) end

--- Applies a modifier making player 1 build the given ebp faster. The modifier is returned.
---@param ebpname_building string
---@return unknown
function TestUtil_MakeBuildingFast(ebpname_building) end

--- Prints the location and health of all player owned squads and entities
--- Iterates over all players and prints the position and health of all squads and entities the player owns.
---@return unknown
function TestUtil_PrintAllSquadsAndEntities() end

--- Prints the location and health of all entities owned by a player
--- Iterates over all entities a player owns and prints their blueprint name, position and health.
---@param player Player
---@return unknown
function TestUtil_PrintPlayerEntities(player) end

--- Prints the location and health of all squads owned by a player
--- Iterates over all squads a player owns and prints their blueprint name, position and health.
---@param player Player
---@return unknown
function TestUtil_PrintPlayerSquads(player) end

--- Create a new unit test and add it to the given table
--- Once all tests have been added using this function, the test group passed to t_test_group should be passed
---@param a_table_of_tests_to_be_run_by_the_same_driver t_test_group
---@return unknown
function TestUtil_RegisterTest(a_table_of_tests_to_be_run_by_the_same_driver) end

--- Spawn entities in a grid based on a list of blueprint names.
--- Grabs one entry of the given blueprint list each iteration and spawns it. Then it creates a new timed rule requesting to be called again as soon as possible. This gives the engine time to update in between calls so that the other threads are not blocked in case a huge list of units needs to get spawned. Once every unit is spawned the given callback function will be called. The spawning grid starts at the given top left corner and spawns in an axis aligned grid based on the given spacing. The grid expands towards positive x/z
---@param player_EGroup_egroup Player
---@param t_ebpnames_Position_pos_top_left_Number_spacing_function_callback table
---@return unknown
function TestUtil_SpawnEntitiesInGridWithoutBlocking(player_EGroup_egroup, t_ebpnames_Position_pos_top_left_Number_spacing_function_callback) end

--- Spawn squads based on a list of blueprint names.
--- Grabs one entry of the given blueprint list each iteration and spawns it. Then it creates a new timed rule requesting to be called again as soon as possible. This gives the engine time to update in between calls so that the other threads are not blocked in case a huge list of units needs to get spawned. Once every unit is spawned the given callback function will be called.
---@param player_SGroup_sgroup Player
---@param t_sbpnames_Position_pos_spawn_function_callback table
---@return unknown
function TestUtil_SpawnSquadsInGridWithoutBlocking(player_SGroup_sgroup, t_sbpnames_Position_pos_spawn_function_callback) end

--- Compare two values and print to standard_test if they are close enough
--- Uses equality if acceptable_difference is nil or 0
---@param value1 any
---@param value2 any
---@param acceptable_difference number | nil
---@param value1_name string | nil
---@param value2_name string | nil
---@return unknown
function TestUtil_TestClose(value1, value2, acceptable_difference, value1_name, value2_name) end

--- Compare two values using the given comparator
---@param value1 any
---@param value2 any
---@param value1_name string | nil
---@param value2_name string | nil
---@return unknown
function TestUtil_TestCompare(value1, value2, value1_name, value2_name) end

--- Checks if directions are equal and prints message to standard_test if they are not
--- The items must of of types that can have a direction resolved on them with Util_GetDirection()
---@param item1 EGroup
---@param item2 EGroup
---@return unknown
function TestUtil_TestDirectionsSame(item1, item2) end

--- Compare two values and print to standard_test if they are equal
--- Uses equality if acceptable_difference is nil or 0
---@param value1 any
---@param value2 any
---@param value1_name string | nil
---@param value2_name string | nil
---@return unknown
function TestUtil_TestEqual(value1, value2, value1_name, value2_name) end

--- Checks if positions are equal and prints message to standard_test if they are not
---@param object1 EGroup
---@param object2 EGroup
---@param max_accepted_difference number
---@return unknown
function TestUtil_TestPositionsSame(object1, object2, max_accepted_difference) end

--- Add a new child named childName and of type typeName to elementName.
---@param elementName string
---@param typeName string
---@param childName string
---@param propertyTable StackVarTable
---@return unknown
function UI_AddChild(elementName, typeName, childName, propertyTable) end

--- Adds a command binding for groupName.bindingName to global function callbackName.
---@param groupName string
---@param bindingName string
---@param callbackName string
---@return unknown
function UI_AddCommandBinding(groupName, bindingName, callbackName) end

--- Adds the event handler on elementName for event eventName to global function callbackName(elementName, eventName).
--- The callback function should take two arguments, the element name and the event name.
---@param elementName string
---@param eventName string
---@param callbackName string
---@return unknown
function UI_AddEventHandler(elementName, eventName, callbackName) end

--- Add text to elementName.
---@param elementName string
---@param text string
---@return unknown
function UI_AddText(elementName, text) end

--- Clear the contents of elementName.
---@param elementName string
---@return unknown
function UI_Clear(elementName) end

--- Check if content is loaded for a specific layer
---@param layer FrontEnd_Layer
---@param contentPath string
---@return unknown
function UI_IsLayerContentLoaded(layer, contentPath) end

--- If the message box is activated, close it.  The callback will receive the button parameter given.
---@param dialogResult DialogResult
---@return unknown
function UI_MessageBoxHide(dialogResult) end

--- Reset message box data set by previous calls (to display a new message box).
---@return unknown
function UI_MessageBoxReset() end

--- Set the text/tooltip/enabled state of a button on the dialog.
---@param dialogResult DialogResult
---@param text string
---@param tooltip string
---@param icon string
---@param isEnabled boolean
---@return unknown
function UI_MessageBoxSetButton(dialogResult, text, tooltip, icon, isEnabled) end

--- Set the title and message body of the dialog.
---@param title string
---@param message string
---@return unknown
function UI_MessageBoxSetText(title, message) end

--- Remove elementName from its parent.
---@param elementName string
---@return unknown
function UI_Remove(elementName) end

--- Removes a command binding for groupName.bindingName.
---@param groupName string
---@param bindingName string
---@return unknown
function UI_RemoveCommandBinding(groupName, bindingName) end

--- Removes the event handler on elementName for event eventName to global function callbackName(elementName, eventName).
--- The callback function should take two arguments, the element name and the event name.
---@param elementName string
---@param eventName string
---@param callbackName string
---@return unknown
function UI_RemoveEventHandler(elementName, eventName, callbackName) end

--- Converts table to a data context for bindings of elementName.
---@param elementName string
---@param table StackVarTable
---@return unknown
function UI_SetDataContext(elementName, table) end

--- Converts table to a data context exposed through entity models.
---@param entity Entity
---@param table StackVarTable
---@return unknown
function UI_SetEntityDataContext(entity, table) end

--- Sets the property propertyName on elementName to value stackVar.
---@param elementName string
---@param propertyName string
---@param stackVar any
---@return unknown
function UI_SetPropertyValue(elementName, propertyName, stackVar) end

--- Sets the properties on elementName to the key/value pairs in propertyTable.
---@param elementName string
---@param propertyTable StackVarTable
---@return unknown
function UI_SetPropertyValues(elementName, propertyTable) end

--- Converts table to a data context exposed through squad models.
---@param squad Squad
---@param table StackVarTable
---@return unknown
function UI_SetSquadDataContext(squad, table) end

--- Forces ALL in-process deployments to complete instantly.
---@return unknown
function UnitEntry_CompleteAllDeploymentsImmediately() end

--- Forces a specific in-process deployment to complete instantly.
---@param deployment DeploymentID
---@return unknown
function UnitEntry_CompleteDeploymentImmediately(deployment) end

--- Create and spawn a set of units (a "deployment") in one go.
--- See details here: http://relicwiki/display/EE/Core+Unit+Entry+Framework
---@param player Player
---@param sgroup SGroup
---@param units table
---@param spawn Marker | Position
---@param entryMethod table | nil
---@param stagger number | nil
---@param options table | nil
---@return unknown
function UnitEntry_DeploySquads(player, sgroup, units, spawn, entryMethod, stagger, options) end

--- Returns a spawnLocation and Facing. If the unit has a custom spawn, it uses that, otherwise it gets it from deployment
---@return unknown
function UnitEntry_ResolveSpawnLocation() end

--- Wins/loses a single team mission for the local teams, with given win reason
---@param localPlayerWon boolean
---@param winReason WinReason
---@return unknown
function World_EndSP(localPlayerWon, winReason) end

--- Is the game over?
---@return unknown
function World_IsGameOver() end

--- Kills the player with a reason.
---@param player Player
---@param reason KillPlayerReason
---@return unknown
function World_KillPlayer(player, reason) end

--- Quit the game without declaring it over and return to frontend.
---@return unknown
function World_LeaveGameMatch() end

--- Sets the player to a lose state, with a reason for losing, and kills the player
---@param player Player
---@return unknown
function World_SetPlayerLose(player) end

--- Sets the player to a win state.
---@param player Player
---@return unknown
function World_SetPlayerWin(player) end

--- Sets every player on a team to a win state, with a reason for winning. Also sets all other players to a lose state, and kills them (if they're not already dead)
---@param winningTeam number
---@param winReason WinReason
---@return unknown
function World_SetTeamWin(winningTeam, winReason) end

--- overrides the Heavy Cover Occupancy for the passed EBP
---@param pPlayer Player
---@param ebp Entity
---@param occupancyOverride number
---@return unknown
function AI_AddHeavyCoverEbpOccupancyOverride(pPlayer, ebp, occupancyOverride) end

--- This clears the repair priority value for a given squad or building PBG.
--- pbgShortname is the PBG of the squad or building to clear its priority value.
---@param pPlayer Player
---@param pbgShortname string
---@return unknown
function AI_ClearPBGRepairPriority(pPlayer, pbgShortname) end

--- Converts an AIEntity into an Entity
---@param pAIEntity Entity
---@return unknown
function AI_ConvertToSimEntity(pAIEntity) end

--- Converts an AIPlayer into a Player
---@param pAIPlayer Player
---@return unknown
function AI_ConvertToSimPlayer(pAIPlayer) end

--- Converts an AISquad into a Squad
---@param pAISquad Squad
---@return unknown
function AI_ConvertToSimSquad(pAISquad) end

--- Create a new encounter for player
--- EncounterType is one of: AIEncounterType_DefendArea, AIEncounterType_AttackArea, AIEncounterType_Move, AIEncounterType_Ability,
---@param pPlayer Player
---@param encounterType number
---@return unknown
function AI_CreateEncounter(pPlayer, encounterType) end

--- Enables/disables debugging of AI Attack Encounter Encounter Position Scoring
---@param enable boolean
---@return unknown
function AI_DebugAttackEncounterPositionScoringEnable(enable) end

--- Returns true if AI Attack Encounter Position Scoring is enabled
---@return unknown
function AI_DebugAttackEncounterPositionScoringIsEnabled() end

--- Enables/disables AI Lua Debugging
---@param enable boolean
---@return unknown
function AI_DebugLuaEnable(enable) end

--- Returns true if AI Lua Debugging is enabled
---@return unknown
function AI_DebugLuaIsEnabled() end

--- Enables/disables AI Construction Debugging
---@param enable boolean
---@return unknown
function AI_DebugRatingEnable(enable) end

--- Returns true if AI Construction Debugging is enabled
---@return unknown
function AI_DebugRatingIsEnabled() end

--- Enables/disables AI Rendering of All Task Children
---@param enable boolean
---@return unknown
function AI_DebugRenderAllTaskChildrenEnable(enable) end

--- Returns true if AI Rendering of All Task Children is enabled
---@return unknown
function AI_DebugRenderAllTaskChildrenIsEnabled() end

--- Enables/disables AI Skirmish ForwardDeploy Debugging
---@param enable boolean
---@return unknown
function AI_DebugSkirmishForwardDeployEnable(enable) end

--- Returns true if AI Skirmish ForwardDeploy Debugging is enabled
---@return unknown
function AI_DebugSkirmishForwardDeployIsEnabled() end

--- Disable all of the economy overrides for the AI player
---@param pPlayer Player
---@return unknown
function AI_DisableAllEconomyOverrides(pPlayer) end

--- Execute a string as lua in the given player's AI LuaConfig
---@param playerID number
---@param string string
---@return unknown
function AI_DoString(playerID, string) end

--- Enables or Disables an AI player
---@param pPlayer Player
---@param enable boolean
---@return unknown
function AI_Enable(pPlayer, enable) end

--- Enables or Disables all AI players
---@param enable boolean
---@return unknown
function AI_EnableAll(enable) end

--- Enable or disable the economy override for the AI player
---@param pPlayer Player
---@param overrideName string
---@param enable boolean
---@return unknown
function AI_EnableEconomyOverride(pPlayer, overrideName, enable) end

--- Finds an AISquad owned by the specified player
---@param pPlayer Player
---@param UID number
---@return unknown
function AI_FindAISquadByID(pPlayer, UID) end

--- Find the current best producible Entity PBG corresponding to the specified Entity Types.
---@param player Player
---@param entityTypeNames string
---@return unknown
function AI_FindBestProducibleEntityPBGforEntityTypes(player, entityTypeNames) end

--- Find the current best producible Squad PBG corresponding to the specified Squad Types.
---@param player Player
---@param squadTypeNames string
---@return unknown
function AI_FindBestProducibleSquadPBGforSquadTypes(player, squadTypeNames) end

--- Find a valid construction location for a pbg, using a spiral search. Returns INVALID_POS if it fails.
---@param pPlayer Player
---@param pPbg PBG
---@param position Position
---@return unknown
function AI_FindConstructionLocation(pPlayer, pPbg, position) end

--- Stores entities of a specific type owned by a player in an egroup parameter
---@param pAIPlayer Player
---@param type AIMilitaryTargetType
---@param egroup EGroup
---@return unknown
function AI_GetAllMilitaryPointsOfType(pAIPlayer, type, egroup) end

--- Get and reserve the next available AITaskID (which can be used to create an AIEncounter from SCAR).
---@param player Player
---@return unknown
function AI_GetAndReserveNextTaskID(player) end

--- Gets the difficulty level of this AI player
--- Levels can be one of: GD_Easy, GD_Normal, GD_Hard, GD_Expert, GD_INVALID
---@param pPlayer Player
---@return unknown
function AI_GetDifficulty(pPlayer) end

--- Get the personality name of this AI player
---@param pPlayer Player
---@return unknown
function AI_GetPersonality(pPlayer) end

--- Get the personality lua file name of this AI player
---@param pPlayer Player
---@return unknown
function AI_GetPersonalityLuaFileName(pPlayer) end

--- Returns true if player is an AI player
---@param pPlayer Player
---@return unknown
function AI_IsAIPlayer(pPlayer) end

--- Returns true if player is an AIPlayer and is targetable by other AI players.
---@param pPlayer Player
---@return unknown
function AI_IsAITargetable(pPlayer) end

--- Checks if the AI debug display is enabled
---@param pPlayer Player
---@return unknown
function AI_IsDebugDisplay(pPlayer) end

--- Returns true if player is a AIPlayer and is enabled
---@param pPlayer Player
---@return unknown
function AI_IsEnabled(pPlayer) end

--- Returns true if the player is an AIPlayer running on the local machine
---@param pPlayer Player
---@return unknown
function AI_IsLocalAIPlayer(pPlayer) end

--- Returns true when position in a sector that is adjacent to an in-supply sector
---@param aiPlayer Player
---@param position Position
---@return unknown
function AI_IsPositionNearInSupplySector(aiPlayer, position) end

--- Checks if this is a valid AISquad
---@param pSquadAI Squad
---@return unknown
function AI_IsSquadValid(pSquadAI) end

--- Locks the entity and disables its tactics (if any) and the AI will no longer use this object
---@param pPlayer Player
---@param pEntity Entity
---@return unknown
function AI_LockEntity(pPlayer, pEntity) end

--- Locks the squad and disables its tactics (if any) and the AI will no longer use this object
---@param pPlayer Player
---@param pSquad Squad
---@return unknown
function AI_LockSquad(pPlayer, pSquad) end

--- Locks the squads and disables its tactics (if any) and the AI will no longer use these objects
---@param pPlayer Player
---@param squads SGroup
---@return unknown
function AI_LockSquads(pPlayer, squads) end

--- Pauses or unpauses currently running tasks
---@param pPlayer Player
---@param pause boolean
---@return unknown
function AI_PauseCurrentTasks(pPlayer, pause) end

--- Add an Exclusion area to the AI Player
---@param pPlayer Player
---@param position Position
---@param noPathRadius number
---@param noTargetRadius number
---@return unknown
function AI_PlayerAddExclusionArea(pPlayer, position, noPathRadius, noTargetRadius) end

--- Set a named bool value in the AIPlayer DataDictionary
---@param player Player
---@param varName string
---@param value boolean
---@return unknown
function AI_PlayerDataDictionarySetBool(player, varName, value) end

--- Set a named number value in the AIPlayer DataDictionary
---@param player Player
---@param varName string
---@param value number
---@return unknown
function AI_PlayerDataDictionarySetNumber(player, varName, value) end

--- Set a named PBG value in the AIPlayer DataDictionary
---@param player Player
---@param varName string
---@param value PBG
---@return unknown
function AI_PlayerDataDictionarySetPBG(player, varName, value) end

--- Remove the Exclusion area from the AI Player
---@param pPlayer Player
---@param position Position
---@param noPathRadius number
---@param noTargetRadius number
---@return unknown
function AI_PlayerRemoveExclusionArea(pPlayer, position, noPathRadius, noTargetRadius) end

--- This clears the importance bonus on this capture point
---@param pPlayer Player
---@param pEntity Entity
---@return unknown
function AI_RemoveCapturePointHighPriority(pPlayer, pEntity) end

--- Restarts the AI
---@param pPlayer Player
---@return unknown
function AI_RestartSCAR(pPlayer) end

--- Restores the default personality and difficulty settings of this AI player
---@param pPlayer Player
---@return unknown
function AI_RestoreDefaultPersonalitySettings(pPlayer) end

--- Set Combat Range Policy for the AISquad, overrides the one set at Encounter/task level
--- policy is one of: AICombatRangePolicy_Default, AICombatRangePolicy_Ranged_MinRange, AICombatRangePolicy_Ranged_MaxRange, AICombatRangePolicy_MeleeRange
---@param pSquadAI Squad
---@param policy CombatRangePolicy
---@return unknown
function AI_SetAISquadCombatRangePolicyTaskOverride(pSquadAI, policy) end

--- Enables or Disables an AI player to be targetable by other AI players.
---@param pPlayer Player
---@param targetable boolean
---@return unknown
function AI_SetAITargetable(pPlayer, targetable) end

--- This sets importance bonus of the given capture point
---@param pPlayer Player
---@param pEntity Entity
---@return unknown
function AI_SetCapturePointAsHighPriority(pPlayer, pEntity) end

--- Enable or disable the AI debug display
---@param pPlayer Player
---@param enable boolean
---@return unknown
function AI_SetDebugDisplay(pPlayer, enable) end

--- Set the difficulty level of this AI player
--- Levels can be one of: GD_Easy, GD_Normal, GD_Hard, GD_Expert
---@param pPlayer Player
---@param difficultyLevel number
---@return unknown
function AI_SetDifficulty(pPlayer, difficultyLevel) end

--- This sets the repair priority value for a given squad or building PBG.
--- pbgShortname is the PBG of the squad or building to change its priority value. priorityValue must be within range [0, 1], with higher value being more desirable to repair.
---@param pPlayer Player
---@param pbgShortname string
---@param priorityValue number
---@return unknown
function AI_SetPBGRepairPriority(pPlayer, pbgShortname, priorityValue) end

--- Set the personality name of this AI player
---@param pPlayer Player
---@param personalityName string
---@return unknown
function AI_SetPersonality(pPlayer, personalityName) end

--- Set an AI Player's desired income of specified resource type at specified value. This will affect the AI resource gathering, building construction and production priority in trying to achieve the specified resource income.
---@param player Player
---@param resourceType number
---@param desiredIncome number
---@return unknown
function AI_SetResourceIncomeDesire(player, resourceType, desiredIncome) end

--- Clear a named Squad in the AISquad DataDictionary
---@param squad Squad
---@param varName string
---@return unknown
function AI_SquadDataDictionaryClearSquad(squad, varName) end

--- Get a named bool value in the AISquad DataDictionary, returns false if the value doesn't exist
---@param squad Squad
---@param varName string
---@return unknown
function AI_SquadDataDictionaryGetBool(squad, varName) end

--- Get a named number value in the AISquad DataDictionary, returns 0 if the value doesn't exist
---@param squad Squad
---@param varName string
---@return unknown
function AI_SquadDataDictionaryGetNumber(squad, varName) end

--- Get a named Squad in the AISquad DataDictionary, returns null if the entry doesn't exist
---@param squad Squad
---@param varName string
---@return unknown
function AI_SquadDataDictionaryGetSquad(squad, varName) end

--- Set a named bool value in the AISquad DataDictionary
---@param squad Squad
---@param varName string
---@param value boolean
---@return unknown
function AI_SquadDataDictionarySetBool(squad, varName, value) end

--- Set a named number value in the AISquad DataDictionary
---@param squad Squad
---@param varName string
---@param value number
---@return unknown
function AI_SquadDataDictionarySetNumber(squad, varName, value) end

--- Set a named PBG value in the AISquad DataDictionary
---@param squad Squad
---@param varName string
---@param value PBG
---@return unknown
function AI_SquadDataDictionarySetPBG(squad, varName, value) end

--- Set a named Squad in the AISquad DataDictionary
---@param squad Squad
---@param varName string
---@param targetSquad Squad
---@return unknown
function AI_SquadDataDictionarySetSquad(squad, varName, targetSquad) end

--- Toggles the AI debug display
---@param pPlayer Player
---@return unknown
function AI_ToggleDebugDisplay(pPlayer) end

--- Unlocks all designer locked squads for player
---@param pPlayer Player
---@return unknown
function AI_UnlockAll(pPlayer) end

--- Unlocks this entity so that AI can use it again
---@param pPlayer Player
---@param pEntity Entity
---@return unknown
function AI_UnlockEntity(pPlayer, pEntity) end

--- Unlocks the given squad so the AI can use it again
---@param pPlayer Player
---@param pSquad Squad
---@return unknown
function AI_UnlockSquad(pPlayer, pSquad) end

--- Locks the squads and disables its tactics (if any) and the AI will no longer use these objects
---@param pPlayer Player
---@param squads SGroup
---@return unknown
function AI_UnlockSquads(pPlayer, squads) end

--- Re-updates the AI in regards to all the static objects in the world (if SCAR creates new strategic points dynamically this will need to be called)
---@param pPlayer Player
---@return unknown
function AI_UpdateStatics(pPlayer) end

--- Set ability for ability encounter
---@param pEncounter AIEncounterID
---@param abilityPBG PBG
---@return unknown
function AIAbilityEncounter_AbilityGuidance_SetAbilityPBG(pEncounter, abilityPBG) end

--- Ends the encounter and deletes it.
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_Cancel(pEncounter) end

--- add the EGroup to the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param egroup EGroup
---@return unknown
function AIEncounter_CombatGuidance_AddForcedCombatTargetEGroup(pEncounter, egroup) end

--- add the Entity to the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param pEntity Entity
---@return unknown
function AIEncounter_CombatGuidance_AddForcedCombatTargetEntity(pEncounter, pEntity) end

--- add the SGroup to the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param sgroup SGroup
---@return unknown
function AIEncounter_CombatGuidance_AddForcedCombatTargetSGroup(pEncounter, sgroup) end

--- add the Squad to the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@return unknown
function AIEncounter_CombatGuidance_AddForcedCombatTargetSquad(pEncounter, pSquad) end

--- Clear the encounter Forced Combat Targets
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_CombatGuidance_ClearForcedCombatTargets(pEncounter) end

--- Enables/disables squads in combat garrisoning.
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_CombatGuidance_EnableCombatGarrison(pEncounter, enable) end

--- remove the EGroup from the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param egroup EGroup
---@return unknown
function AIEncounter_CombatGuidance_RemoveForcedCombatTargetEGroup(pEncounter, egroup) end

--- remove the Entity from the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param pEntity Entity
---@return unknown
function AIEncounter_CombatGuidance_RemoveForcedCombatTargetEntity(pEncounter, pEntity) end

--- remove the SGroup from the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param sgroup SGroup
---@return unknown
function AIEncounter_CombatGuidance_RemoveForcedCombatTargetSGroup(pEncounter, sgroup) end

--- remove the Squad from the Encounter forced target list. NOTE: supported only by the Attack Encounter
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@return unknown
function AIEncounter_CombatGuidance_RemoveForcedCombatTargetSquad(pEncounter, pSquad) end

--- Set Combat Range Policy for the encounter
--- policy is one of: AICombatRangePolicy_Default, AICombatRangePolicy_Ranged_MinRange, AICombatRangePolicy_Ranged_MaxRange, AICombatRangePolicy_MeleeRange
---@param pEncounter AIEncounterID
---@param policy CombatRangePolicy
---@return unknown
function AIEncounter_CombatGuidance_SetCombatRangePolicy(pEncounter, policy) end

--- Set if the Attack Encounter should spread the attackers on multiple targets
---@param pEncounter AIEncounterID
---@param value boolean
---@return unknown
function AIEncounter_CombatGuidance_SetSpreadAttackers(pEncounter, value) end

--- Set a named bool value in the Encounter DataDictionary
---@param pEncounter AIEncounterID
---@param varName string
---@param value boolean
---@return unknown
function AIEncounter_DataDictionarySetBool(pEncounter, varName, value) end

--- Set a named number value in the Encounter DataDictionary
---@param pEncounter AIEncounterID
---@param varName string
---@param value number
---@return unknown
function AIEncounter_DataDictionarySetNumber(pEncounter, varName, value) end

--- Set a named PBG value in the Encounter DataDictionary
---@param pEncounter AIEncounterID
---@param varName string
---@param value PBG
---@return unknown
function AIEncounter_DataDictionarySetPBG(pEncounter, varName, value) end

--- Enables/disables idle squads garrisoning.
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_DefenseGuidance_EnableIdleGarrison(pEncounter, enable) end

--- Adds a setup location and facing direction for this encounter not specifically assigned to any squad
---@param pEncounter AIEncounterID
---@param pos Position
---@param facingDir Position
---@return unknown
function AIEncounter_EngagementGuidance_AddEncouterSetupLocation(pEncounter, pos, facingDir) end

--- clears the encounter setup locations
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_EngagementGuidance_ClearSetupLocationOverrides(pEncounter) end

--- Enable / disable aggressive move into engagement area
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_EnableAggressiveEngagementMove(pEncounter, enable) end

--- Enable construction in Town Life encounters
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_EnableConstruction(pEncounter, enable) end

--- Enable setup locations in attack and defend encounters
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_EnableSetupLocations(pEncounter, enable) end

--- Sets a TownLife Encounter whether to allow resource gathering from deposits outside of Encounter leash.
---@param pEncounter AIEncounterID
---@param allowOutsideLeash boolean
---@return unknown
function AIEncounter_EngagementGuidance_SetAllowResourceGatheringOutsideLeash(pEncounter, allowOutsideLeash) end

--- Enable encounter to return to previous stages if they fail to meet conditions for current stage.
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_SetAllowReturnToPreviousStages(pEncounter, enable) end

--- Enable coordinated arrival in attack encounters
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_SetCoordinatedSetup(pEncounter, enable) end

--- Enables/disables sniper reactions
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_SetEnableSniperReactions(pEncounter, enable) end

--- Enables/disables SubEngagementAreas
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_EngagementGuidance_SetEnableSubEngagementAreas(pEncounter, enable) end

--- Sets max time, in seconds, to accomplish encounter, once the target is engaged.
---@param pEncounter AIEncounterID
---@param seconds number
---@return unknown
function AIEncounter_EngagementGuidance_SetMaxEngagementTime(pEncounter, seconds) end

--- Sets max time, in seconds, to remain idle at encounter target, once engaged.
---@param pEncounter AIEncounterID
---@param seconds number
---@return unknown
function AIEncounter_EngagementGuidance_SetMaxIdleTime(pEncounter, seconds) end

--- set the sbp setup location priority override
---@param pEncounter AIEncounterID
---@param sbp Squad
---@param priority number
---@return unknown
function AIEncounter_EngagementGuidance_SetSetupLocationSbpPriority(pEncounter, sbp, priority) end

--- set the squad setup location and facing direction
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@param pos Position
---@param facingDir Position
---@return unknown
function AIEncounter_EngagementGuidance_SetSquadSetupLocation(pEncounter, pSquad, pos, facingDir) end

--- Enable/Disable Reinforce during combat
---@param pEncounter AIEncounterID
---@param value boolean
---@return unknown
function AIEncounter_FallbackGuidance_EnableReinforceDuringCombat(pEncounter, value) end

--- Enable retreat to break pinned.
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_FallbackGuidance_EnableRetreatOnPinned(pEncounter, enable) end

--- Enable retreat to break suppression.
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_FallbackGuidance_EnableRetreatOnSuppression(pEncounter, enable) end

--- Set entities remaining threshold of encounter [-1 to N] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetEntitiesRemainingThreshold(pEncounter, value) end

--- Set capacity threshold [-1 to 1] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetFallbackCapacityPercentage(pEncounter, value) end

--- Set combat rating threshold of area [0.0 to 1.0] to fallback at. (0.0 disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetFallbackCombatRating(pEncounter, value) end

--- Set Squad health threshold [-1 to 1] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param fallbackStartValue number
---@param fallbackEndValue number
---@return unknown
function AIEncounter_FallbackGuidance_SetFallbackSquadHealthPercentage(pEncounter, fallbackStartValue, fallbackEndValue) end

--- Set Squad Shield threshold [-1 to 1] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param fallbackStartValue number
---@param fallbackEndValue number
---@return unknown
function AIEncounter_FallbackGuidance_SetFallbackSquadShieldPercentage(pEncounter, fallbackStartValue, fallbackEndValue) end

--- Set Vehicle health threshold [-1 to 1] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param fallbackStartValue number
---@param fallbackEndValue number
---@return unknown
function AIEncounter_FallbackGuidance_SetFallbackVehicleHealthPercentage(pEncounter, fallbackStartValue, fallbackEndValue) end

--- Set global fallback threshold (negative for individual squad).
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetGlobalFallbackPercentage(pEncounter, value) end

--- Set global retreat type (true for retreat; false for fallback).
---@param pEncounter AIEncounterID
---@param value boolean
---@return unknown
function AIEncounter_FallbackGuidance_SetGlobalFallbackRetreat(pEncounter, value) end

--- Set the Reinforce Health Percentage [-1 to 1] (negative disables retreat)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetReinforceHealthPercentage(pEncounter, value) end

--- Set the Max Reinforce Distance (negative value: no distance constrain)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetReinforceMaxDistance(pEncounter, value) end

--- Set the Min Health Ratio Required To Reach Reinforce Point [0.0, 1.0] (negative value: no constrain)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetReinforceMinHealthRatioToReachReinforcePoint(pEncounter, value) end

--- Set combat rating threshold of area [-1 to 1] to fallback at. (negative disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetRetreatCapacityPercentage(pEncounter, value) end

--- Set combat rating threshold of area [0.0 to 1.0] to retreat at. (0.0 disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetRetreatCombatRating(pEncounter, value) end

--- Set retreat health threshold of area [-1 to 1] (negative disables)
---@param pEncounter AIEncounterID
---@param value number
---@return unknown
function AIEncounter_FallbackGuidance_SetRetreatHealthPercentage(pEncounter, value) end

--- Set fallback target.
---@param pEncounter AIEncounterID
---@param pos Position
---@return unknown
function AIEncounter_FallbackGuidance_SetTargetPosition(pEncounter, pos) end

--- Asks the encounter to terminate in its next update (allows PhaseEncounter to set its exit info)
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_ForceComplete(pEncounter) end

--- Set formup type for formation encounter to be at building of type from AE tuning list (must set before triggering)
---@param encounter AIEncounterID
---@param unitTypeList string
---@return unknown
function AIEncounter_FormationGuidance_SetFormUpAtBuildingOfType(encounter, unitTypeList) end

--- Set formup entity for formation encounter (must set before triggering)
---@param encounter AIEncounterID
---@param entity Entity
---@return unknown
function AIEncounter_FormationGuidance_SetFormUpAtEntityTarget(encounter, entity) end

--- Set formup position for formation encounter (must set before triggering)
---@param encounter AIEncounterID
---@param postion Position
---@return unknown
function AIEncounter_FormationGuidance_SetFormUpAtPositionTarget(encounter, postion) end

--- Set formup position for formation encounter at the average of current squad positions (must set before triggering)
---@param encounter AIEncounterID
---@return unknown
function AIEncounter_FormationGuidance_SetFormUpAtSquadAverage(encounter) end

--- Set formup position timeout and % squads that must arrive or else it will fail.  Setting zero for timeout means infinite
---@param encounter AIEncounterID
---@param timeoutSeconds number
---@param requiredSquadsPercent number
---@return unknown
function AIEncounter_FormationGuidance_SetFormUpAtTimeOutParams(encounter, timeoutSeconds, requiredSquadsPercent) end

--- Get the average position of squads of this finished formation phase encounter (may be the same as target if successful).  You should call AIEncounter_FormationPhase_HasValidExitInfo before this to avoid an error
---@param encounterID AITaskID
---@return unknown
function AIEncounter_FormationPhase_GetEndPosition(encounterID) end

--- Get the end position of this finished formation phase move encounter (may be the same as target if successful)
---@param encounterID AITaskID
---@return unknown
function AIEncounter_FormationPhase_GetEndReason(encounterID) end

--- Get Groups containing the enemies encountered by this formation phase encounter (encounter must have completed) false indicates the exit info was not available for this encounter
---@param encounterID AITaskID
---@param enemySquads SGroup
---@param enemyBuildings EGroup
---@return unknown
function AIEncounter_FormationPhase_GetEnemiesAtEnd(encounterID, enemySquads, enemyBuildings) end

--- Get the combat fitness result for a finished phase encounter, will only be valid for exit states CombatFitnessThreshold or WasAttacked.  -1.0f means invalid.
---@param encounterID AITaskID
---@return unknown
function AIEncounter_FormationPhase_GetExitCombatFitnessResult(encounterID) end

--- Get SGRoups containing the squads who made it to the destination of a formation phase move encounter and those who didn't (encounter must have completed) false indicates the exit info was not available for this encounter
---@param encounterID AITaskID
---@param squadsAvailable SGroup
---@param squadsUnavailable SGroup
---@return unknown
function AIEncounter_FormationPhase_GetSquadsAvailableAtEnd(encounterID, squadsAvailable, squadsUnavailable) end

--- Query if there is valid exit info for this encounter (will only return true for phase encounters)
---@param encounterID AITaskID
---@return unknown
function AIEncounter_FormationPhase_HasValidExitInfo(encounterID) end

--- Assign a property bag contains data to support sub task coordination for combat encounters
---@param encounter AIEncounterID
---@param coordinatorPBG PBG
---@return unknown
function AIEncounter_FormationPhaseGuidance_SetCombatCoordinator(encounter, coordinatorPBG) end

--- Set params for terminating a formation phase encounter based on combat, fallback params can also be used
---@param encounter AIEncounterID
---@param timeoutSeconds number
---@param testTargetDestroyed boolean
---@param testEnemySquadsCleared boolean
---@param testEnemyBuildingsCleared boolean
---@param enemyScanRange number
---@param excludeBuildingTypeNames string
---@return unknown
function AIEncounter_FormationPhaseGuidance_SetCombatExitParams(encounter, timeoutSeconds, testTargetDestroyed, testEnemySquadsCleared, testEnemyBuildingsCleared, enemyScanRange, excludeBuildingTypeNames) end

--- Set params for terminating a formation phase encounter that is moving somewhere and encounters enemies
--- enemyScanRange is scan range from current centre of the formation to look for enemies in meters combatFitnessThreshold is the fitness rating against all detected enemies, < 0 means do not use, 0 means our team will win taking no damage, 1.0 means the enemy will win taking now damage. enemyFormationAngle is the relative heading of the strongest enemy formation in degrees, 0 means do not use enemyFormationPosition is the relative position of the strongest enemy formation in degrees, where 360.0f means directly behind us, 0 means do not use enemyFormationDistance is the distance threshold of the strongest enemy formation in meters
---@param encounter AIEncounterID
---@param enemyScanRange number
---@param combatFitnessThreshold number
---@param enemyFormationHeading number
---@param enemyFormationPosition number
---@param enemyFormationDistance number
---@param excludeBuildingTypeNames string
---@return unknown
function AIEncounter_FormationPhaseGuidance_SetMoveEnemiesExitParams(encounter, enemyScanRange, combatFitnessThreshold, enemyFormationHeading, enemyFormationPosition, enemyFormationDistance, excludeBuildingTypeNames) end

--- Set params for terminating a formation phase encounter that is moving somewhere
--- timeoutSeconds is how long to wait for squads to get to destination (0 means run indefinitely) requiredSquadsPercent is how many squads must be in the target area, 1.0 means all wasRecentlyAttackedSecs was any unit attacked in this interval, 0 means do not use.  Recommend not using if you are also using combat threshold
---@param encounter AIEncounterID
---@param timeoutSeconds number
---@param requiredSquadsPercent number
---@param wasRecentlyAttackedSecs number
---@return unknown
function AIEncounter_FormationPhaseGuidance_SetMoveExitParams(encounter, timeoutSeconds, requiredSquadsPercent, wasRecentlyAttackedSecs) end

--- Specify data for formation encounter to create a formation min range task state
--- repositionInterval is how often they will check to see if they need to reposition
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param repositionIntervalSecs number
---@param useTactics boolean
---@param unitTypeNames string
---@param targetPriorityPBG PBG
---@return unknown
function AIEncounter_FormationTaskStateGuidance_MinRange(encounter, priority, minSquads, maxSquads, maxTasks, repositionIntervalSecs, useTactics, unitTypeNames, targetPriorityPBG) end

--- Specify data for formation encounter to create a formation min range task state with protect task
--- enemyScanRange is scan range from current centre of the formation to look for enemies in meters
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param repositionIntervalSecs number
---@param useTactics boolean
---@param unitTypeNames string
---@param targetPriorityPBG PBG
---@param protectMinSquads number
---@param protectMaxSquads number
---@param protectProportionSquads number
---@param protectDistance number
---@param protectRepositionThreshold number
---@param protectRepositionIntervalSecs number
---@param protectUnitTypeNames string
---@return unknown
function AIEncounter_FormationTaskStateGuidance_MinRangeWithProtect(encounter, priority, minSquads, maxSquads, maxTasks, repositionIntervalSecs, useTactics, unitTypeNames, targetPriorityPBG, protectMinSquads, protectMaxSquads, protectProportionSquads, protectDistance, protectRepositionThreshold, protectRepositionIntervalSecs, protectUnitTypeNames) end

--- Specify data for formation encounter to create a formation move task state
---@param encounter AIEncounterID
---@param attackMove boolean
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param unitTypeNames string
---@return unknown
function AIEncounter_FormationTaskStateGuidance_Move(encounter, attackMove, priority, minSquads, maxSquads, maxTasks, unitTypeNames) end

--- Specify data for formation encounter to create a formation setup ranged task state
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param unitTypeNames string
---@param targetPriorityPBG PBG
---@return unknown
function AIEncounter_FormationTaskStateGuidance_SetupRanged(encounter, priority, minSquads, maxSquads, maxTasks, unitTypeNames, targetPriorityPBG) end

--- Specify data for formation encounter to create a formation setup ranged task state and along with a formation of other units to protect it
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param unitTypeNames string
---@param targetPriorityPBG PBG
---@param protectMinSquads number
---@param protectMaxSquads number
---@param protectProportionSquads number
---@param protectDistance number
---@param protectRepositionThreshold number
---@param protectRepositionIntervalSecs number
---@param protectUnitTypeNames string
---@return unknown
function AIEncounter_FormationTaskStateGuidance_SetupRangedWithProtect(encounter, priority, minSquads, maxSquads, maxTasks, unitTypeNames, targetPriorityPBG, protectMinSquads, protectMaxSquads, protectProportionSquads, protectDistance, protectRepositionThreshold, protectRepositionIntervalSecs, protectUnitTypeNames) end

--- Specify data for formation encounter to create a formation simple melee task state
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param unitTypeNames string
---@param targetPriorityPBG PBG
---@return unknown
function AIEncounter_FormationTaskStateGuidance_SimpleMelee(encounter, priority, minSquads, maxSquads, maxTasks, unitTypeNames, targetPriorityPBG) end

--- Specify data for formation encounter to create a formation transport move task state
---@param encounter AIEncounterID
---@param priority number
---@param minSquads number
---@param maxSquads number
---@param maxTasks number
---@param unitTypeNames string
---@param minPassengerSquads number
---@param maxPassengerSquadsPerTransport number
---@param unloadAbilityPBG PBG
---@param passengerUnitTypeNames string
---@param targetPriorityPBG PBG
---@return unknown
function AIEncounter_FormationTaskStateGuidance_TransportMove(encounter, priority, minSquads, maxSquads, maxTasks, unitTypeNames, minPassengerSquads, maxPassengerSquadsPerTransport, unloadAbilityPBG, passengerUnitTypeNames, targetPriorityPBG) end

--- Returns the encounter pointer from the ID, always test for nil before using...
---@param player Player
---@param taskID AITaskID
---@return unknown
function AIEncounter_GetEncounterFromID(player, taskID) end

--- Returns true if enconter has a valid AI player
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_IsAIPlayerValid(pEncounter) end

--- Determines if encounter is still valid.  Must be true before calling any other of the AIEncounter_* function.  Return true if valid, false otherwise.
---@param PlayerUniqueID UniqueID
---@param encounterTaskID AITaskID
---@return unknown
function AIEncounter_IsValid(PlayerUniqueID, encounterTaskID) end

--- in non RTM builds, if verboseEncounterLogging is enabled, will spew string to AI log file
---@param pPlayer Player
---@param encounterID number
---@param debugString string
---@return unknown
function AIEncounter_LogDebug(pPlayer, encounterID, debugString) end

--- Enable / disable aggressive movements on way to engagement targets
---@param pEncounter AIEncounterID
---@param enable boolean
---@return unknown
function AIEncounter_MoveGuidance_EnableAggressiveMove(pEncounter, enable) end

--- Set radius (follow distance) for coordinated move phase (<= 0 disables coordinated movement)
---@param pEncounter AIEncounterID
---@param radius number
---@return unknown
function AIEncounter_MoveGuidance_SetSquadCoherenceRadius(pEncounter, radius) end

--- Clears all notification callbacks for encounter
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_Notify_ClearCallbacks(pEncounter) end

--- enables/disabled the sniped callback
---@param pEncounter AIEncounterID
---@param value boolean
---@return unknown
function AIEncounter_Notify_SetEnableSnipedCallbacks(pEncounter, value) end

--- Sets the ID for the notification event sent out by encounter
---@param pEncounter AIEncounterID
---@param id number
---@return unknown
function AIEncounter_Notify_SetPlayerEventEncounterID(pEncounter, id) end

--- Pause/Unpause this encounter
---@param pEncounter AIEncounterID
---@param bPause boolean
---@return unknown
function AIEncounter_Pause(pEncounter, bPause) end

--- Calculates approximately how long it will take for a specified Encounter to produce a specified squad.
--- Returns production time in seconds.  Negative value means the specified PBG cannot be produced at the specified Encounter. pEncounter is the Encounter Module that can service a production request. pbgShortname is the PBG of the squad to query. if canAffordNowOnly is set and we currently don't have enough resource now, report "cannot be produced".
---@param pEncounter AIEncounterID
---@param pbgShortname string
---@param canAffordNowOnly boolean
---@return unknown
function AIEncounter_ResourceGuidance_CalculateEstimatedSquadProductionTime(pEncounter, pbgShortname, canAffordNowOnly) end

--- Removes all resource entities from encounter.
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_ResourceGuidance_ClearEntities(pEncounter) end

--- Removes all resource squads from encounter.
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_ResourceGuidance_ClearSquads(pEncounter) end

--- Sets the resource entities for encounter.
---@param pEncounter AIEncounterID
---@param entities EGroup
---@return unknown
function AIEncounter_ResourceGuidance_EntityGroup(pEncounter, entities) end

--- Checks if a squad group is equal to the resource squads of an encounter.
---@param pEncounter AIEncounterID
---@param squads SGroup
---@return unknown
function AIEncounter_ResourceGuidance_IsSquadGroupEqual(pEncounter, squads) end

--- Sets the resource money for an encounter.
---@param pEncounter AIEncounterID
---@param resourceAmount ResourceAmount
---@return unknown
function AIEncounter_ResourceGuidance_SetResourceMoney(pEncounter, resourceAmount) end

--- Sets the resource squads for encounter.
---@param pEncounter AIEncounterID
---@param squads SGroup
---@return unknown
function AIEncounter_ResourceGuidance_SquadGroup(pEncounter, squads) end

--- Set encounter name for debugging.
---@param pEncounter AIEncounterID
---@param name string
---@return unknown
function AIEncounter_SetDebugName(pEncounter, name) end

--- Reset all tactic filters for encounter
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_TacticFilter_Reset(pEncounter) end

--- Reset all tactic ability constraints for encounter
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_TacticFilter_ResetAbilityGuidance(pEncounter) end

--- Reset ability priority for all squads in encounter
---@param pEncounter AIEncounterID
---@param abilityPBG PBG
---@return unknown
function AIEncounter_TacticFilter_ResetAbilityPriority(pEncounter, abilityPBG) end

--- Reset tactic priority for all squads in encounter
---@param pEncounter AIEncounterID
---@param tactic AITacticType
---@return unknown
function AIEncounter_TacticFilter_ResetPriority(pEncounter, tactic) end

--- Reset all tactic constraints for encounter
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_TacticFilter_ResetTacticGuidance(pEncounter) end

--- Reset all tactic target constraints for encounter
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_TacticFilter_ResetTargetGuidance(pEncounter) end

--- Set tactic ability constraints for encounter
--- maxCasters is maximum concurrent casters of this ability (-1 is unlimited), waitRetrySecs is time in seconds between ability tactic retrying ability retry, wait[self/encounter], and timeout Secs are: the number of seconds to try doing a tactic after a previous try; seconds after last successful try; how long the successful tactic can run. initialWait is true if the waitTime applies before the first ability use. maxRange is the maximum range to look for ability target from caster (other range constraints may limit the max range to a smaller value) castChanceOverride is the probability to cast the ability, must be between 0.0 and 1.0
---@param pEncounter AIEncounterID
---@param ability PBG
---@param maxCasters number
---@param retrySecs number
---@param waitSelfSecs number
---@param waitEncounterSecs number
---@param timeoutSecs number
---@param initialWait boolean
---@param maxRange number
---@param castChanceOverride number
---@return unknown
function AIEncounter_TacticFilter_SetAbilityGuidance(pEncounter, ability, maxCasters, retrySecs, waitSelfSecs, waitEncounterSecs, timeoutSecs, initialWait, maxRange, castChanceOverride) end

--- Set ability priority for all squads in encounter; negative priority disables
---@param pEncounter AIEncounterID
---@param abilityPBG PBG
---@param priority number
---@return unknown
function AIEncounter_TacticFilter_SetAbilityPriority(pEncounter, abilityPBG, priority) end

--- Set ability priority for squad in encounter
---@param pEncounter AIEncounterID
---@param squad Squad
---@param abilityPBG PBG
---@param priority number
---@return unknown
function AIEncounter_TacticFilter_SetAbilityPriorityForSquad(pEncounter, squad, abilityPBG, priority) end

--- Set default tactic ability constraints for encounter (ability specific guidance takes priority over defaults)
--- maxCasters is maximum concurrent casters of ability (-1 is unlimited), waitRetrySecs is time in seconds between ability tactic retrying ability, retry, wait[self/encounter], and timeout Secs are: the number of seconds to try doing a tactic after a previous try; seconds after last successful try; how long the successful tactic can run. initialWait is true if the waitTime applies before the first ability use. maxRange is the maximum range to look for ability target from caster (other range constraints may limit the max range to a smaller value) castChanceOverride is the probability to cast the ability, must be between 0.0 and 1.0
---@param pEncounter AIEncounterID
---@param maxCasters number
---@param retrySecs number
---@param waitSelfSecs number
---@param waitEncounterSecs number
---@param timeoutSecs number
---@param initialWait boolean
---@param maxRange number
---@param castChanceOverride number
---@return unknown
function AIEncounter_TacticFilter_SetDefaultAbilityGuidance(pEncounter, maxCasters, retrySecs, waitSelfSecs, waitEncounterSecs, timeoutSecs, initialWait, maxRange, castChanceOverride) end

--- Set default tactic constraints for encounter (tactic specific guidance takes priority over defaults)
--- maxUsers is maximum concurrent users of tactic (-1 is unlimited), waitRetrySecs is time in seconds between tactic retrying retry, wait, and timeout Secs are: the number of seconds to try doing a tactic after a previous try; seconds after last successful try; how long the successful tactic can run. initialWait is true if the waitTime applies before the first tactic use. maxRange is the maximum range to look for tactic target from caster (other range constraints may limit the max range to a smaller value)
---@param pEncounter AIEncounterID
---@param maxUsers number
---@param retrySecs number
---@param waitSecs number
---@param timeoutSecs number
---@param initialWait boolean
---@param maxRange number
---@return unknown
function AIEncounter_TacticFilter_SetDefaultTacticGuidance(pEncounter, maxUsers, retrySecs, waitSecs, timeoutSecs, initialWait, maxRange) end

--- Set tactic priority for all squads in encounter; negative priority disables
---@param pEncounter AIEncounterID
---@param tactic AITacticType
---@param priority number
---@return unknown
function AIEncounter_TacticFilter_SetPriority(pEncounter, tactic, priority) end

--- Set tactic priority for squads in encounter
---@param pEncounter AIEncounterID
---@param squad Squad
---@param tactic AITacticType
---@param priority number
---@return unknown
function AIEncounter_TacticFilter_SetPriorityForSquad(pEncounter, squad, tactic, priority) end

--- Set tactic constraints for encounter
--- maxUsers is maximum concurrent users of this tactic (-1 is unlimited), waitRetrySecs is time in seconds between tactic retry retry, wait, and timeout Secs are: the number of seconds to try doing a tactic after a previous try; seconds after last successful try; how long the successful tactic can run. initialWait is true if the waitTime applies before the first tactic use. maxRange is the maximum range to look for tactic target from caster (other range constraints may limit the max range to a smaller value)
---@param pEncounter AIEncounterID
---@param tactic AITacticType
---@param maxUsers number
---@param retrySecs number
---@param waitSecs number
---@param timeoutSecs number
---@param initialWait boolean
---@param maxRange number
---@return unknown
function AIEncounter_TacticFilter_SetTacticGuidance(pEncounter, tactic, maxUsers, retrySecs, waitSecs, timeoutSecs, initialWait, maxRange) end

--- Set tactic target priority for encounter
--- policy is one of: AITacticTargetPreference_None, AITacticTargetPreference_Near,
---@param pEncounter AIEncounterID
---@param policy TargetPreference
---@return unknown
function AIEncounter_TacticFilter_SetTargetPolicy(pEncounter, policy) end

--- Disables the patrol for the passed Squad
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@return unknown
function AIEncounter_TargetGuidance_DisableSquadPatrol(pEncounter, pSquad) end

--- Sets target patrol path for encounter
---@param pEncounter AIEncounterID
---@param pathName string
---@param delaySecs number
---@param invertPathAtEnd boolean
---@param startInverted boolean
---@return unknown
function AIEncounter_TargetGuidance_SetPatrolPathByName(pEncounter, pathName, delaySecs, invertPathAtEnd, startInverted) end

--- Sets random wander target patrol for encounter; delaySecs is the time in secs to pause at each random point
---@param pEncounter AIEncounterID
---@param delaySecs number
---@param radiusMode number
---@param radiusOverride number
---@param overrideCenter boolean
---@param centerOverride Position
---@return unknown
function AIEncounter_TargetGuidance_SetPatrolWander(pEncounter, delaySecs, radiusMode, radiusOverride, overrideCenter, centerOverride) end

--- Sets target patrol path for the squad
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@param pathName string
---@param delaySecs number
---@param invertPathAtEnd boolean
---@param startInverted boolean
---@return unknown
function AIEncounter_TargetGuidance_SetSquadPatrolPathByName(pEncounter, pSquad, pathName, delaySecs, invertPathAtEnd, startInverted) end

--- Sets random wander target patrol for the squad; delaySecs is the time in secs to pause at each random point
---@param pEncounter AIEncounterID
---@param pSquad Squad
---@param delaySecs number
---@param radiusMode number
---@param radiusOverride number
---@param overrideCenter boolean
---@param centerOverride Position
---@return unknown
function AIEncounter_TargetGuidance_SetSquadPatrolWander(pEncounter, pSquad, delaySecs, radiusMode, radiusOverride, overrideCenter, centerOverride) end

--- Sets engagement area radius around the target.
---@param pEncounter AIEncounterID
---@param radius number
---@return unknown
function AIEncounter_TargetGuidance_SetTargetArea(pEncounter, radius) end

--- Sets target Entity for encounter
---@param pEncounter AIEncounterID
---@param entity Entity
---@return unknown
function AIEncounter_TargetGuidance_SetTargetEntity(pEncounter, entity) end

--- Sets leash radius around target where squads should stay within.
---@param pEncounter AIEncounterID
---@param radius number
---@return unknown
function AIEncounter_TargetGuidance_SetTargetLeash(pEncounter, radius) end

--- Sets target position for encounter
---@param pEncounter AIEncounterID
---@param pos Position
---@return unknown
function AIEncounter_TargetGuidance_SetTargetPosition(pEncounter, pos) end

--- Sets target Squad for encounter
---@param pEncounter AIEncounterID
---@param squad Squad
---@return unknown
function AIEncounter_TargetGuidance_SetTargetSquad(pEncounter, squad) end

--- Set encounter name for debugging.
---@param pEncounter AIEncounterID
---@return unknown
function AIEncounter_Trigger(pEncounter) end

--- Checks if the squad can lock the tactic item
---@param tacticItemEntity Entity
---@param lockingAISquad Squad
---@return unknown
function AIPlayer_CanAISquadLockTacticItem(tacticItemEntity, lockingAISquad) end

--- Returns the Player at specified index out of all opponent players.  Use in conjunction with `AIPlayer_GetOpponentPlayerCount`.
---@param aiPlayer Player
---@param index number
---@return unknown
function AIPlayer_GetOpponentPlayerAtIndex(aiPlayer, index) end

--- Returns the number of opponent Players to the specified AIPlayer.
---@param aiPlayer Player
---@return unknown
function AIPlayer_GetOpponentPlayerCount(aiPlayer) end

--- Returns a table of squad ids from the AIPlayer's state model corresponding to the given key.
---@param aiPlayer Player
---@param key string
---@return unknown
function AIPlayer_GetStateModelAISquadListEntries(aiPlayer, key) end

--- Checks if a tactic item is locked
---@param player Player
---@param tacticItemEntity Entity
---@return unknown
function AIPlayer_IsTacticItemLocked(player, tacticItemEntity) end

--- Checks if a tactic item is locked by the squad
---@param tacticItemEntity Entity
---@param lockingAISquad Squad
---@return unknown
function AIPlayer_IsTacticItemLockedByAISquad(tacticItemEntity, lockingAISquad) end

--- Locks a tactic item for the passed player
---@param tacticItemEntity Entity
---@param lockingAISquad Squad
---@return unknown
function AIPlayer_LockTacticItemForAISquad(tacticItemEntity, lockingAISquad) end

--- Temporarily hides all of the known squads belonging to the enemy player for the specified AI
---@param player Player
---@param enemyPlayer Player
---@return unknown
function AIPlayer_ResetEnemySquadsVisibility(player, enemyPlayer) end

--- Set the target distribution of how the ai player should use their units for gathering
--- Second argument is a map of resource type names to weights ex: { ['wood'] = 5, ... }
---@param aiPlayer Player
---@param luaGatherDistro number
---@return unknown
function AIPlayer_SetGathererDistributionOverride(aiPlayer, luaGatherDistro) end

--- marks the player to force the stats squads to update
---@param player Player
---@return unknown
function AIPlayer_SetRequiresStatsUpdate(player) end

--- UnLocks a tactic item for the passed player
---@param tacticItemEntity Entity
---@param lockingAISquad Squad
---@return unknown
function AIPlayer_UnLockTacticItemForAISquad(tacticItemEntity, lockingAISquad) end

--- Find the best squad target which is not part of a clump.
---@param aiSquad Squad
---@param targetSquads SGroup
---@param tacticTargetPolicy TargetPreference
---@param targetAllies boolean
---@return unknown
function AISquad_FindBestIsolatedSquadTarget(aiSquad, targetSquads, tacticTargetPolicy, targetAllies) end

--- returns the best squad target in the sgroup based on the passed tacticTargetPolicy
--- policy is one of: AITacticTargetPreference_None, AITacticTargetPreference_Near,
---@param aiSquad Squad
---@param targetSquads SGroup
---@param tacticTargetPolicy TargetPreference
---@return unknown
function AISquad_FindBestSquadTarget(aiSquad, targetSquads, tacticTargetPolicy) end

--- returns the safest position for the AISquad in the current encounter leash area
---@param aiSquad Squad
---@param maxRadius number
---@return unknown
function AISquad_FindSafePositionInEncounterLeash(aiSquad, maxRadius) end

--- returns true if the AISquad is currently running the AISquadAbilityTactic for the passed abilityPBG
---@param aiSquad Squad
---@param abilityPBG PBG
---@return unknown
function AISquad_IsRunningSquadTacticAbility(aiSquad, abilityPBG) end

--- On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel.
---@param pPlayer Player
---@param openingBranchName string
---@param keepAlive boolean
---@param stateModelTuningsScarPBG ScarAIStateModelTuningsPBG
---@param stateModelSGroupListTunings SGroup
---@param stateModelEGroupListTunings EGroup
---@param stateModelPositionTargetListTunings Position
---@param stateModelMarkerTargetListTunings Marker
---@param stateModelEntityTypeListTunings string[]
---@param stateModelCoordinatorPBGListTunings LuaMap<ScarAIFormationCoordinatorPBG>
---@param stateModelBoolTunings boolean
---@param stateModelFloatTunings number
---@param stateModelIntTunings number
---@return unknown
function AIStateTree_SpawnRootControllerWithStateModelTunings(pPlayer, openingBranchName, keepAlive, stateModelTuningsScarPBG, stateModelSGroupListTunings, stateModelEGroupListTunings, stateModelPositionTargetListTunings, stateModelMarkerTargetListTunings, stateModelEntityTypeListTunings, stateModelCoordinatorPBGListTunings, stateModelBoolTunings, stateModelFloatTunings, stateModelIntTunings) end

--- returns the Encounter that controls the Squad
---@param squad Squad
---@return unknown
function Squad_GetInternalAIEncounterPtr(squad) end

--- returns true if the Squad is in an Encounter
---@param squad Squad
---@return unknown
function Squad_IsInAIEncounter(squad) end

--- iterates through an sgroup, returns count with AIStatsSquad
---@param sgroup SGroup
---@param player Player
---@return unknown
function SquadGroup_CountSpawnedAndStatsInitialized(sgroup, player) end

--- Returns an AIAbility property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetAIAbilityBlueprint(pbgShortname) end

--- Returns an AIAbility property bag group.
---@param pbgID number
---@return unknown
function BP_GetAIAbilityBlueprintByPbgID(pbgID) end

--- Returns an AIFormationCoordinator property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetAIFormationCoordinatorBlueprint(pbgShortname) end

--- Returns an AIFormationCoordinator property bag group.
---@param pbgID number
---@return unknown
function BP_GetAIFormationCoordinatorBlueprintByPbgID(pbgID) end

--- Returns an AIFormationTargetPriority property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetAIFormationTargetPriorityBlueprint(pbgShortname) end

--- Returns an AIFormationTargetPriority property bag group.
---@param pbgID number
---@return unknown
function BP_GetAIFormationTargetPriorityBlueprintByPbgID(pbgID) end

--- Returns an AIStateModelTunings property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetAIStateModelTuningsBlueprint(pbgShortname) end

--- Returns an AIStateModelTunings property bag group.
---@param pbgID number
---@return unknown
function BP_GetAIStateModelTuningsBlueprintByPbgID(pbgID) end

--- Returns the unmodified build time in seconds from cost_ext for a given entity blueprint.
---@param entityBag Entity
---@return unknown
function BP_GetEntityBPBuildTime(entityBag) end

--- Returns the default movement speed from moving_ext for a given entity blueprint. If getModifiedSpeed is true, the value will be modified by any speed_maximum_modifier applied to the player for the given entity blueprint.
---@param entityBag Entity
---@param getModifiedSpeed boolean
---@param player Player
---@return unknown
function BP_GetEntityBPDefaultSpeed(entityBag, getModifiedSpeed, player) end

--- Returns the child blueprint of the specified entity blueprint at specified index.
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetEntityChildBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of child blueprints of the specified entity blueprint.
---@param pbgShortname string
---@return unknown
function BP_GetEntityChildBlueprintCount(pbgShortname) end

--- Returns the parent blueprint of the specified entity blueprint at specified index
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetEntityParentBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of parent blueprints of the specified entity blueprint.
---@param pbgShortname string
---@return unknown
function BP_GetEntityParentBlueprintCount(pbgShortname) end

--- Returns race blueprint associated with an entity blueprint type_ext at specified index.
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetEntityTypeExtRaceBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of race blueprints associated with an entity blueprint type_ext.
---@param pbgShortname string
---@return unknown
function BP_GetEntityTypeExtRaceCount(pbgShortname) end

--- Returns a map pool property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetMapPoolBlueprint(pbgShortname) end

--- Returns a map pool property bag group.
---@param pbgID number
---@return unknown
function BP_GetMapPoolBlueprintByPbgID(pbgID) end

--- Returns a move type property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetMoveTypeBlueprint(pbgShortname) end

--- Returns a move type property bag group.
---@param pbgID number
---@return unknown
function BP_GetMoveTypeBlueprintByPbgID(pbgID) end

--- Returns an pass type property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetPassTypeBlueprint(pbgShortname) end

--- Returns an pass type property bag group.
---@param pbgID number
---@return unknown
function BP_GetPassTypeBlueprintByPbgID(pbgID) end

--- Return the number of property bag groups of the same type
--- Example type would be PBG_Critical
---@param type PropertyBagGroupType
---@return unknown
function BP_GetPropertyBagGroupCount(type) end

--- Return the path name of the group at the specified index
--- Example name would be "abilities\ally_mad_minute_ability"
---@param type PropertyBagGroupType
---@param index number
---@return unknown
function BP_GetPropertyBagGroupPathName(type, index) end

--- Returns a UIReticuleBag property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetReticuleBlueprint(pbgShortname) end

--- Returns a slot item property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetSlotItemBlueprint(pbgShortname) end

--- Returns a slot item property bag group.
---@param pbgID number
---@return unknown
function BP_GetSlotItemBlueprintByPbgID(pbgID) end

--- Returns the child blueprint of the specified squad blueprint at specified index.
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetSquadChildBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of child blueprints of the specified squad blueprint.
---@param pbgShortname string
---@return unknown
function BP_GetSquadChildBlueprintCount(pbgShortname) end

--- Returns the parent blueprint of the specified squad blueprint at specified index
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetSquadParentBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of parent blueprints of the specified squad blueprint.
---@param pbgShortname string
---@return unknown
function BP_GetSquadParentBlueprintCount(pbgShortname) end

--- Returns race blueprint associated with a squad blueprint squad_type_ext at specified index.
---@param pbgShortname string
---@param index number
---@return unknown
function BP_GetSquadTypeExtRaceBlueprintAtIndex(pbgShortname, index) end

--- Returns the number of race blueprints associated with a squad blueprint squad_type_ext.
---@param pbgShortname string
---@return unknown
function BP_GetSquadTypeExtRaceCount(pbgShortname) end

--- Returns the type of a blueprint.
---@param v any
---@return unknown
function BP_GetType(v) end

--- Returns a weapon property bag group.
---@param pbgShortname string
---@return unknown
function BP_GetWeaponBlueprint(pbgShortname) end

--- Returns a weapon property bag group.
---@param pbgID number
---@return unknown
function BP_GetWeaponBlueprintByPbgID(pbgID) end

--- Returns true if the UpgradePGB's list of types includes the given type
---@param upgradePBG Upgrade
---@param key string
---@return unknown
function BP_IsUpgradeOfType(upgradePBG, key) end

--- Returns true if an entity blueprint exists with the given name.
---@param pbgShortname string
---@return unknown
function EBP_Exists(pbgShortname) end

--- Returns whether the entity blueprint is of specified race
---@param pbgShortname string
---@param race ScarRacePBG
---@return unknown
function EBP_IsOfRace(pbgShortname, race) end

--- get Entity blueprint pop cost, use CT_Personnel, CT_Vehicle, CT_Medic for captype
---@param ebpUnit PBG
---@param player Player
---@param type CapType
---@return unknown
function EBP_PopulationCost(ebpUnit, player, type) end

--- Returns true if a squad blueprint exists with the given name.
---@param pbgShortname string
---@return unknown
function SBP_Exists(pbgShortname) end

--- Returns whether the squad blueprint is of specified race
---@param pbgShortname string
---@param race ScarRacePBG
---@return unknown
function SBP_IsOfRace(pbgShortname, race) end

--- Queue moving the camera along a spline consisting of entity/marker/pos/egroup/sgroup/squad objects within seconds.
--- The camera will move from the position that was in front of it in the pan queue along the positions provided. Catmull-Rom interpolation between points is used
---@param var any
---@param seconds number
---@param keepQueue boolean
---@param controlRotation boolean
---@return unknown
function Camera_CatromSplinePanOverTime(var, seconds, keepQueue, controlRotation) end

--- Moves the camera through a list of positions.
---@param list table
---@param pan boolean | nil
---@param panRate number | nil
---@param callback function | nil
---@return unknown
function Camera_CyclePositions(list, pan, panRate, callback) end

--- Set the camera to follow an sgroup/squad/egroup/entity.
--- The camera will follow them until the player takes control again.
---@param var any
---@return unknown
function Camera_Follow(var) end

--- Queue moving the camera along a spline consisting of entity/marker/pos/egroup/sgroup/squad objects within seconds.
--- The camera will move from the position that was in front of it in the pan queue along the positions provided. Linear interpolation between points is used
---@param var any
---@param seconds number
---@param keepQueue boolean
---@param controlRotation boolean
---@return unknown
function Camera_LinearSplinePanOverTime(var, seconds, keepQueue, controlRotation) end
--- Slightly refocus the camera to rest on an entity/squad/squad/sgroup/egroup/pos/marker if it's close by.
--- This function can be called through a CTRL object in NISlets.
---@param var any
---@return unknown
function Camera_MoveToIfClose(var) end

--- Queue moving the camera a certain distance from the position of the camera in a specified amount of time.
--- The position used is the position the camera will be in after completing the movement(s) queued in front.
---@param delta Position
---@param seconds number
---@param keepQueue boolean
---@return unknown
function Camera_PanOverTimeRelative(delta, seconds, keepQueue) end

--- Queue moving the camera to an entity/marker/pos/egroup/sgroup/squad within seconds.
--- The camera will move from the position that was in front of it in the queue.
---@param var any
---@param seconds number
---@param keepQueue boolean
---@return unknown
function Camera_PanOverTimeTo(var, seconds, keepQueue) end

--- Reset the camera to its default rotation.
---@return unknown
function Camera_ResetRotation() end

--- Rotate the camera relative to its current rotation in degrees.
---@param angle number
---@return unknown
function Camera_RotateRelative(angle) end

--- Rotate the camera to a given angle in degrees.
---@param angle number
---@return unknown
function Camera_RotateTo(angle) end

--- Adds a function to the Mission Cheat menu, under the title you provide. These should be registered in the Mission_Preset function.
--- If the restartMission flag is set, when the cheat is activated the mission will be restarted. Most of the startup script happens as normal: Mission_SetupVariables,  Mission_SetDifficulty, Mission_SetupRestrictions and Mission_Preset are all called as normal, but the supplied function is called INSTEAD OF the regular Mission_Start function.
---@param cheatFunction function
---@param title string
---@param restartMission boolean | nil
---@return unknown
function CheatMenu_RegisterCheatFunction(cheatFunction, title, restartMission) end

--- Order a squad group to abandon their current team weapon if they have it and they could (tuning value in attribute editor)
---@param sgroupid SGroup
---@param preserveCrew boolean | nil
---@param queued boolean | nil
---@return unknown
function Cmd_AbandonTeamWeapon(sgroupid, preserveCrew, queued) end

--- Attach the squad from sgroupnameAttachee to sgroupname.  Both SGroups must contain only one squad.
---@param sgroup SGroup
---@param sgroupAttachee SGroup
---@return unknown
function Cmd_AttachSquads(sgroup, sgroupAttachee) end

--- Issues an attack command to an SGroup
---@param sgroup SGroup
---@param target EGroup
---@param queued boolean | nil
---@param stationary boolean | nil
---@param plan string | nil
---@param check_FOW boolean | nil
---@return unknown
function Cmd_Attack(sgroup, target, queued, stationary, plan, check_FOW) end

--- Order a squad group to attack move to a position (anything whose position can be queried). can be queued, can follow a plan, can search for cover within a radius
---@param sgroup SGroup
---@param targetposition Position
---@param queued boolean | nil
---@param plan string | nil
---@param coverSearchRadius number | nil
---@param deleteWhenNearMarker Marker | nil
---@param splitCmd boolean | nil
---@return unknown
function Cmd_AttackMove(sgroup, targetposition, queued, plan, coverSearchRadius, deleteWhenNearMarker, splitCmd) end

--- Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it
---@param attacker SGroup
---@param target EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_AttackMoveThenCapture(attacker, target, queued) end

--- Order a squad group to capture team weapon entity group.
---@param sgroupid SGroup
---@param targetid EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_CaptureTeamWeapon(sgroupid, targetid, queued) end

--- Orders a squad to contruct a building at specified position, or to continue construction on an existing building.
--- The command also checks to see if a building already exists at the location, and the squad will continue building it, if it is of the correct type.
---@param sgroupid SGroup
---@param blueprint Entity
---@param targetid EGroup
---@param Facing Position | nil
---@param queued boolean | nil
---@return unknown
function Cmd_Construct(sgroupid, blueprint, targetid, Facing, queued) end

--- Detonates a building's demolitions
---@param player Player
---@param target EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_DetonateDemolitions(player, target, queued) end

--- Orders an EGroup or SGroup to kick out its occupants. If no position is specified, the occupants stay at the exit.
---@param fromgroupid EGroup
---@param destination Position | nil
---@param queued boolean | nil
---@return unknown
function Cmd_EjectOccupants(fromgroupid, destination, queued) end

--- Order a squad group to load at a random entity or squad of the group
--- overload is a flag that will allow the hold entity to ignore maximum slot check
---@param fromsgroupid SGroup
---@param togroupid EGroup
---@param overload boolean | nil
---@param queued boolean | nil
---@param instant boolean | nil
---@return unknown
function Cmd_Garrison(fromsgroupid, togroupid, overload, queued, instant) end

--- Order a squad group to hold position at a given location (or just it's current location)
--- The location parameter can be a position (to hold position at that location), or a Boolean to enable/disable HoldPosition at the current location. If it's omitted entirely, it defaults to true.
---@param sgroup SGroup
---@param location boolean | nil
---@param queued boolean | nil
---@return unknown
function Cmd_HoldPosition(sgroup, location, queued) end

--- Sends a instant reinforce command to all squads in a group.  count represents the number of commands to send.
--- Note: This function bypasses pre-reqs, costs and the production queue
---@param sgroup SGroup
---@param count number
---@return unknown
function Cmd_InstantReinforceUnit(sgroup, count) end

--- Order a squad group to instant setup their team weapon without animation
---@param sgroupid SGroup
---@param queued boolean | nil
---@return unknown
function Cmd_InstantSetupTeamWeapon(sgroupid, queued) end

--- Move a squad group out of a position to a certain radius
--- All squads in the group will move away from the centre position from its current position
---@param sgroup SGroup
---@param position Position
---@param radius number
---@param queued boolean | nil
---@return unknown
function Cmd_MoveAwayFromPos(sgroup, position, radius, queued) end

--- Moves a squad group to the indicated Marker and despawns it.
---@param sgroup SGroup
---@param marker Marker
---@param queued boolean
---@return unknown
function Cmd_MoveToAndDeSpawn(sgroup, marker, queued) end

--- Moves a squad group to the indicated Marker and destroys it.
---@param sgroup SGroup
---@param marker Marker
---@param queued boolean
---@return unknown
function Cmd_MoveToAndDestroy(sgroup, marker, queued) end

--- Moves a squad group to the closest marker in a list/table of MarkerIDs.
---@param sgroup SGroup
---@param markertable table
---@return unknown
function Cmd_MoveToClosestMarker(sgroup, markertable) end

--- Move a squad group to a given position, attack-moving once close enough
--- Squad will move to a position, once they're within 'distance', they will attack-move the rest of the way.
---@param sgroup SGroup
---@param position EGroup
---@param distance number | nil
---@param ANY boolean | nil
---@param queued boolean | nil
---@return unknown
function Cmd_MoveToThenAttackMove(sgroup, position, distance, ANY, queued) end

--- Command attacker sgroup to attack move to strategic point target; when it is capturable, the sgroup would capture it
---@param attacker SGroup
---@param target EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_MoveToThenCapture(attacker, target, queued) end

--- Order a squad group to recrew an abandoned vehicle.
---@param sgroupid SGroup
---@param targetid EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_RecrewVehicle(sgroupid, targetid, queued) end

--- Order a squad group to retreat, optionally to a specific location. The sgroup can be deleted when in proximity of a marker (it assumes a proximity of 5 if you forget to set one on the marker)
--- vulnerableRetreat will make retreating squads take more damage
---@param sgroup SGroup
---@param location Position | nil
---@param deleteWhenNearMarker boolean | nil
---@param queued boolean | nil
---@param saveEncounters boolean | nil
---@param vulnerableRetreat boolean | nil
---@return unknown
function Cmd_Retreat(sgroup, location, deleteWhenNearMarker, queued, saveEncounters, vulnerableRetreat) end

--- Order a squad group to revert occupied building
---@param sgroupid SGroup
---@param targetid EGroup
---@param queued boolean | nil
---@return unknown
function Cmd_RevertOccupiedBuilding(sgroupid, targetid, queued) end

--- Orders a squad group to place demolition charges on a building (egroup). Function does nothing if egroup cannot be detonated, or player can't afford the demolitions
---@param sgroupid SGroup
---@param targetid EGroup
---@param skipCostPrereq boolean | nil
---@param queued boolean | nil
---@return unknown
function Cmd_SetDemolitions(sgroupid, targetid, skipCostPrereq, queued) end

--- Order a squad group to setup their team weapon with animation
---@param sgroupid SGroup
---@param queued boolean | nil
---@return unknown
function Cmd_SetupTeamWeapon(sgroupid, queued) end

--- Sends an camouflage stance command to all squads in a group.  stanceid should be the number returned by Util_GetCamouflageStanceID( stancename )
---@param sgroup SGroup
---@param stanceid CamouflageStanceID
---@return unknown
function Cmd_SquadCamouflageStance(sgroup, stanceid) end

--- Send a command to the squad to follow a path. Can wait at each waypoint. The sgroup can be deleted when in proximity of a marker if you pass in the marker as the 7th argument (it assumes a proximity of 5 if you forget to set one on the marker)
--- loop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION
---@param sgroup SGroup
---@param pathName string
---@param bFromClosest boolean
---@param loop number
---@param bAttackMove boolean
---@param pauseTime number
---@param deleteWhenNearMarker Marker | nil
---@param queued boolean | nil
---@param bMoveForward boolean | nil
---@return unknown
function Cmd_SquadPath(sgroup, pathName, bFromClosest, loop, bAttackMove, pauseTime, deleteWhenNearMarker, queued, bMoveForward) end

--- Causes a squad to patrol a marker attacking any enemies that come within its radius. If used on circular markers, the radius must be at least 5. To stop the squad from patrolling the marker, use Cmd_Stop.
---@param sgroup SGroup
---@param marker Marker
---@return unknown
function Cmd_SquadPatrolMarker(sgroup, marker) end

--- Retreats large numbers of units in a staggered, realistic manner.
--- Each Squad in the sgroup will have a 1 in 3 chance to retreat.  After 10 seconds (or maxTries), all squads will be forced to retreat. Squads will delete on arrival at their retreat point. vulnerableRetreat will make retreating squads take more damage
---@param sgroup SGroup
---@param markers table
---@param maxTries number | nil
---@param vulnerableRetreat boolean | nil
---@return unknown
function Cmd_StaggeredRetreat(sgroup, markers, maxTries, vulnerableRetreat) end

--- Orders a squad to surrender and awards the local player with an appropriate number of action points
--- Use the optional parameter to assign action points to override the default number.  The function automatically addresses squads that are in buildings or vehicles by ordering them out of the vehicle. The command will also overwrite the exit position as well, if you do not want the squads to exit at the map entry point.
---@param sgroupid SGroup
---@param actionpoints number | nil
---@param exitpos Position | nil
---@param deleteAtExit boolean | nil
---@param removeWeapon boolean | nil
---@return unknown
function Cmd_Surrender(sgroupid, actionpoints, exitpos, deleteAtExit, removeWeapon) end

--- Orders an sgroup to exit the building or vehicle that it's in. If no position is specified, the sgroup stays at the exit.
---@param sgroupid SGroup
---@param destination Position | nil
---@param queued boolean | nil
---@return unknown
function Cmd_UngarrisonSquad(sgroupid, destination, queued) end

--- Sends an upgrade command to a player, egroup or sgroup. accepts a single upgrade or table of upgrades.
---@param user EGroup
---@param blueprint number
---@param count number | nil
---@param instant boolean | nil
---@return unknown
function Cmd_Upgrade(user, blueprint, count, instant) end

--- Set a squad's unit speed to a multiplied value, and revert it when they reach the target, speed cannot be 0.0f
--- Squad will move to a position, once they're within 'distance', they will revert back to their original speed. ANY means any squad in the group within distance meets criteria, ALL means ALL squads. Queued means the command is queued if true as a command, rather than executing immediately.
---@param sgroup SGroup
---@param position EGroup
---@param speedMultiplier number
---@param distance___10 number | nil
---@param ANY___ANY boolean | nil
---@param queued___false boolean | nil
---@return unknown
function Cmd_WalkToAndThenRun(sgroup, position, speedMultiplier, distance___10, ANY___ANY, queued___false) end

--- Send a entity command to a entity group(CMD_DefaultAction, CMD_Stop, CMD_Destroy, CMD_BuildSquad, CMD_CancelProduction, CMD_RallyPoint, CMD_AttackForced)
--- Entity commands are mostly used for buildings etc.  If you need to issue commands to units, use the Squad_Command function.
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@return unknown
function LocalCommand_Entity(player, egroup, entityCommand) end

--- Send an entity ability command (CMD_Ability) to an entity
---@param player Player
---@param egroup EGroup
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityAbility(player, egroup, abilityPBG, skipCostAndPrereq, queued) end

--- Send a squad command to a entity group with custom data
---@param player Player
---@param egroup EGroup
---@param squadPbg Squad
---@return unknown
function LocalCommand_EntityBuildSquad(player, egroup, squadPbg) end

--- Send a entity-based command to an entity group.
--- Use this function to issue orders that require a entity to an entity group (eg. order a building to attack another building)\n See LocalCommand_Entity for a list of all the possible entityCommands.
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@param target EGroup
---@return unknown
function LocalCommand_EntityEntity(player, egroup, entityCommand, target) end

--- Send a squad command to a squad group with custom data
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_EntityExt(player, egroup, entityCommand, cmdparam, queued) end

--- Send a position command to an entity group.
--- Use this function to issue orders that require a position to an entity group (eg. set a rally point for a building)\n See LocalCommand_Entity for a list of all the possible entityCommands.
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@param target Position
---@return unknown
function LocalCommand_EntityPos(player, egroup, entityCommand, target) end

--- Send a positional ability command (CMD_Ability) to an entity
--- Use this function to issue ability orders that require a position to player
---@param player Player
---@param egroup EGroup
---@param pos Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityPosAbility(player, egroup, pos, abilityPBG, skipCostAndPrereq, queued) end

--- Send a positional/directional ability command (CMD_Ability) to an entity
--- Use this function to issue ability orders that require a position and a direction to player
---@param player Player
---@param egroup EGroup
---@param pos Position
---@param dir Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityPosDirAbility(player, egroup, pos, dir, abilityPBG, skipCostAndPrereq, queued) end

--- Send a dual target (position and squad) command to an entity group.
--- Use this function to issue orders that require a position and a squad to an entity group (eg. unloading squad from hold)\n See LocalCommand_Entity for a list of all the possible entityCommands.
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@param target Position
---@param sgroup SGroup
---@return unknown
function LocalCommand_EntityPosSquad(player, egroup, entityCommand, target, sgroup) end

--- Send a squad-based command to an entity group.
--- Use this function to issue orders that require a squad to an entity group (eg. order a building to attack a squad)\n See LocalCommand_Entity for a list of all the possible entityCommands.
---@param player Player
---@param egroup EGroup
---@param entityCommand EntityCommandType
---@param target SGroup
---@return unknown
function LocalCommand_EntitySquad(player, egroup, entityCommand, target) end

--- Send an entity-targeting ability command (CMD_Ability) to an entity
--- Use this function to issue ability orders that require an entity target to an entity
---@param player Player
---@param egroup EGroup
---@param entityTarget Entity
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityTargetEntityAbility(player, egroup, entityTarget, abilityPBG, skipCostAndPrereq, queued) end

--- Send an squad-targeting ability command (CMD_Ability) to an entity
--- Use this function to issue ability orders that require an entity target to an entity
---@param player Player
---@param egroup EGroup
---@param squadTarget Squad
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityTargetSquadAbility(player, egroup, squadTarget, abilityPBG, skipCostAndPrereq, queued) end

--- Send a squad command to a entity group with custom data
---@param player Player
---@param egroup EGroup
---@param upgrade Upgrade
---@param instant boolean
---@param queued boolean
---@return unknown
function LocalCommand_EntityUpgrade(player, egroup, upgrade, instant, queued) end

--- Send a player command to a player
--- PCMD_Ability
---@param player Player
---@param dest Player
---@param playerCommand PlayerCommandType
---@return unknown
function LocalCommand_Player(player, dest, playerCommand) end

--- Send a player ability command (PCMD_Ability) to a player
---@param player Player
---@param dest Player
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function LocalCommand_PlayerAbility(player, dest, abilityPBG, skipCostAndPrereq) end

--- Send an entity command to a player.
---@param player Player
---@param dest Player
---@param playerCommand PlayerCommandType
---@param target EGroup
---@return unknown
function LocalCommand_PlayerEntity(player, dest, playerCommand, target) end

--- Send a player command to a player with a custom flag
---@param player Player
---@param dest Player
---@param playerCommand PlayerCommandType
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_PlayerExt(player, dest, playerCommand, cmdparam, queued) end

--- Send a player a command to use a multi-target ability on the given targets.
---@param caster Player
---@param targets table<ConstTargetHandle>
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function LocalCommand_PlayerMultiTargetAbility(caster, targets, abilityPBG, skipCostAndPrereq) end

--- Place a planned structure
---@param player Player
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@param payOnApply boolean
---@return unknown
function LocalCommand_PlayerPlaceAndConstructEntitiesPlanned(player, ebp, position, facingPos, queued, payOnApply) end

--- Place a planned fence
---@param player Player
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@param payOnApply boolean
---@return unknown
function LocalCommand_PlayerPlaceAndConstructFencePlanned(player, ebp, posStart, posEnd, queued, payOnApply) end

--- Place a planned slotted spline
---@param player Player
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@param payOnApply boolean
---@return unknown
function LocalCommand_PlayerPlaceAndConstructSlottedSplinePlanned(player, ebp, posStart, posEnd, queued, payOnApply) end

--- Send a position command to a player.
--- Use this function to issue orders that require a position to player)\n See LocalCommand_Player for a list of all the possible playerCommands.
---@param player Player
---@param dest Player
---@param playerCommand PlayerCommandType
---@param pos Position
---@return unknown
function LocalCommand_PlayerPos(player, dest, playerCommand, pos) end

--- Send a positional ability command (PCMD_Ability) to a player
--- Use this function to issue ability orders that require a position to player
---@param player Player
---@param dest Player
---@param pos Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function LocalCommand_PlayerPosAbility(player, dest, pos, abilityPBG, skipCostAndPrereq) end

--- Send a positional/directional ability command (PCMD_Ability) to a player
--- Use this function to issue ability orders that require a position and a direction to player
---@param player Player
---@param dest Player
---@param pos Position
---@param dir Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function LocalCommand_PlayerPosDirAbility(player, dest, pos, dir, abilityPBG, skipCostAndPrereq) end

--- Send a position command to a player with extra info
--- Use this function to issue orders that require a position to player\n See LocalCommand_Player for a list of all the possible playerCommands.
---@param player Player
---@param dest Player
---@param playerCommand PlayerCommandType
---@param pos Position
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_PlayerPosExt(player, dest, playerCommand, pos, cmdparam, queued) end

--- Send a player command to itself to order squads in the sgroup to construct the building at specific position and facing
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructBuilding(player, sgroup, ebp, position, facingPos, queued) end

--- Send a player command to itself to order squads in the sgroup to construct the building at specific position and facing
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructBuildingCheat(player, sgroup, ebp, position, facingPos, queued) end

--- Send a player command to itself to order squads in the sgroup to construct fences from posStart to posEnd
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructFence(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a player command to itself to order squads in the sgroup to construct fences from posStart to posEnd
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructFenceCheat(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a player command to itself to order squads in the sgroup to construct a field ranging from posStart to posEnd
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructField(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a player command to itself to order squads in the sgroup to construct a field ranging from posStart to posEnd
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building would cost nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructFieldCheat(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline from posStart to posEnd.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSpline(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline from posStart to posEnd.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param posStart Position
---@param posEnd Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSplineCheat(player, sgroup, ebp, posStart, posEnd, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline dependent entity.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSplineDependent(player, sgroup, ebp, position, facingPos, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline dependent entity.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSplineDependentCheat(player, sgroup, ebp, position, facingPos, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline replacer entity.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSplineReplacer(player, sgroup, ebp, position, facingPos, queued) end

--- Send a command from player to sgroup to build ebp as a slotted spline replacer entity.
--- structureBlueprint must be a valid building that can be constructed by the sgroup. This building costs nothing and does not effect population and availability This is a special command for SCAR use
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facingPos Position
---@param queued boolean
---@return unknown
function LocalCommand_PlayerSquadConstructSlottedSplineReplacerCheat(player, sgroup, ebp, position, facingPos, queued) end

--- Sends an upgrade command to a player
---@param player Player
---@param upgrade Upgrade
---@param instant boolean
---@param queued boolean
---@return unknown
function LocalCommand_PlayerUpgrade(player, upgrade, instant, queued) end

--- Send a squad command to a squad group
--- SCMD_DefaultAction, SCMD_Move, SCMD_Stop, SCMD_Destroy, SCMD_BuildStructure, SCMD_Capture, SCMD_Attack, SCMD_ReinforceUnit, SCMD_Upgrade, SCMD_CancelProduction SCMD_AttackMove, SCMD_Ability SCMD_Load,SCMD_UnloadSquads, SCMD_DoPlan SCMD_SlotItemRemove, SCMD_InstantReinforceUnit, SCMD_InstantUpgrade
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param queued boolean
---@return unknown
function LocalCommand_Squad(player, sgroup, squadCommand, queued) end

--- Send a ability command (SCMD_Ability) to a squad
---@param player Player
---@param sgroup SGroup
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadAbility(player, sgroup, abilityPBG, skipCostAndPrereq, queued) end

--- Send a position ATTACK MOVE command to a squad group with custom data.
--- WARNING: Element plans need to be reimplemented in state trees.
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target Position
---@param planName string
---@param queued boolean
---@param split boolean
---@return unknown
function LocalCommand_SquadAttackMovePos(player, sgroup, squadCommand, target, planName, queued, split) end

--- Send an entity command to a squad group.
--- Use this function to isssue an entity-based command to a squad group.\n See LocalCommand_Squad for a list of all the possible squadCommands
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target EGroup
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntity(player, sgroup, squadCommand, target, queued) end

--- Send a entity ability command (SCMD_Ability) to a squad
---@param player Player
---@param sgroup SGroup
---@param target EGroup
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntityAbility(player, sgroup, target, abilityPBG, skipCostAndPrereq, queued) end

--- Send an entity command ATTACK to a squad group.
--- Use this function to issue an entity-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)\n planName is the name of the custom plan file to execute. Pass in empty string to use the default\n stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See LocalCommand_Squad for a list of all the possible squadCommands WARNING: Element plans need to be reimplemented in state trees.
---@param player Player
---@param sgroup SGroup
---@param target EGroup
---@param bCheckFOW boolean
---@param bStationary boolean
---@param planName string
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntityAttack(player, sgroup, target, bCheckFOW, bStationary, planName, queued) end

--- Send a entity command to a squad group with custom BOOLEAN data
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target EGroup
---@param cmdparam boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntityBool(player, sgroup, squadCommand, target, cmdparam, queued) end

--- Send a entity command to a squad group with custom data
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target EGroup
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntityExt(player, sgroup, squadCommand, target, cmdparam, queued) end

--- Send special squad command to a squad group with squad load parameters
--- This is a special command for loading squads into building (entity) holds (SCMD_Load, SCMD_InstantLoad)
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target EGroup
---@param bOverLoad boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadEntityLoad(player, sgroup, squadCommand, target, bOverLoad, queued) end

--- Send a squad command to a squad group with custom data
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_SquadExt(player, sgroup, squadCommand, cmdparam, queued) end

--- Send a move to position command for a squad group.
--- Use this function to issue move orders that require a position to a squad group
---@param player Player
---@param sgroup SGroup
---@param target Position
---@param queued boolean
---@param reverseMove boolean
---@param split boolean
---@param acceptableProximity number
---@return unknown
function LocalCommand_SquadMovePos(player, sgroup, target, queued, reverseMove, split, acceptableProximity) end

--- Send a move-facing command to a squad group
---@param player Player
---@param sgroup SGroup
---@param target Position
---@param facing Position
---@param queued boolean
---@param reverseMove boolean
---@param split boolean
---@param acceptableProximity number
---@return unknown
function LocalCommand_SquadMovePosFacing(player, sgroup, target, facing, queued, reverseMove, split, acceptableProximity) end

--- Send a squad a command to use a multi-target ability on the given targets.
---@param caster Squad
---@param targets table<ConstTargetHandle>
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadMultiTargetAbility(caster, targets, abilityPBG, skipCostAndPrereq, queued) end

--- Send a squad patrol command (SCMD_Patrol) to a squad
---@param pPlayer Player
---@param pSGroup SGroup
---@param pathName string
---@param pathIndex number
---@param bFromClosest boolean
---@param loopType LoopType
---@param bAttackMove boolean
---@param pauseTime number
---@param bMoveForward boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadPath(pPlayer, pSGroup, pathName, pathIndex, bFromClosest, loopType, bAttackMove, pauseTime, bMoveForward, queued) end

--- Send a position command to a squad group.
--- Use this function to issue orders that require a position to a squad group (eg. order a squad to move to position, or attack position)\n See LocalCommand_Squad for a list of all the possible squadCommands.
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target Position
---@param queued boolean
---@return unknown
function LocalCommand_SquadPos(player, sgroup, squadCommand, target, queued) end

--- Send a positional ability command (SCMD_Ability) to a squad
---@param player Player
---@param sgroup SGroup
---@param pos Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadPosAbility(player, sgroup, pos, abilityPBG, skipCostAndPrereq, queued) end

--- Send a position command to a squad group with custom data
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target Position
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_SquadPosExt(player, sgroup, squadCommand, target, cmdparam, queued) end

--- Send an position command ATTACK to a squad group.
--- Use this function to issue an position-based command to a squad group with custom FOW check flag. (eg. order a squad to attack a building)\n planName is the name of the custom plan file to execute. Pass in empty string to use the default\n stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See LocalCommand_Squad for a list of all the possible squadCommands WARNING: Element plans need to be reimplemented in state trees.
---@param player Player
---@param sgroup SGroup
---@param target Position
---@param bCheckFOW boolean
---@param bStationary boolean
---@param planName string
---@param queued boolean
---@return unknown
function LocalCommand_SquadPositionAttack(player, sgroup, target, bCheckFOW, bStationary, planName, queued) end

--- Send a retreat position command to a squad group.
--- Use this function to issue retreat order that require a position to a squad group
---@param player Player
---@param sgroup SGroup
---@param target Position
---@param queued boolean
---@param allowNonInteractiveStages boolean
---@return unknown
function LocalCommand_SquadRetreatPos(player, sgroup, target, queued, allowNonInteractiveStages) end

--- Send a set CombatStance command to the squads
--- Set the CombatStance for all the Squads in the SGroup. StanceTypes: STANCE_CeaseFire (don't shoot), STANCE_StandGround (don't move, just shoot), STANCE_Attack (move and shoot)
---@param player Player
---@param sgroup SGroup
---@param stanceType StanceType
---@param queued boolean
---@return unknown
function LocalCommand_SquadSetCombatStance(player, sgroup, stanceType, queued) end

--- Send a set Weapon Preference command to the squads
--- Set the Weapon Preference for all the Squads in the SGroup. WeaponPreference: WP_Melee, WP_Ranged,
---@param player Player
---@param sgroup SGroup
---@param weaponPreference WeaponPreference
---@param queued boolean
---@return unknown
function LocalCommand_SquadSetWeaponPreference(player, sgroup, weaponPreference, queued) end

--- Send an squad-based command to a squad group.
--- Use this function to issue a squad-based command to a squad group. \n See LocalCommand_Squad for a list of all the possible squadCommands
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target SGroup
---@param queued boolean
---@return unknown
function LocalCommand_SquadSquad(player, sgroup, squadCommand, target, queued) end

--- Send a squad ability command (SCMD_Ability) to a squad
---@param player Player
---@param sgroup SGroup
---@param target SGroup
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadSquadAbility(player, sgroup, target, abilityPBG, skipCostAndPrereq, queued) end

--- Send an squad-based command to a squad group.
--- Use this function to issue a squad-based command to a squad group with special boolean flag. (eg. order a squad to attack another squad)\n If bCheckFOW is set to false, the squad would be able to attack other squads hidden in FOW \n planName is the name of the custom plan file to execute. Pass in empty string to use the default\n stationary flag uses SCMD_StationaryAttack instead where plan file is ignored and squad does not pursue its target See LocalCommand_Squad for a list of all the possible squadCommands WARNING: Element plans need to be reimplemented in state trees.
---@param player Player
---@param sgroup SGroup
---@param target SGroup
---@param bCheckFOW boolean
---@param bStationary boolean
---@param planName string
---@param queued boolean
---@return unknown
function LocalCommand_SquadSquadAttack(player, sgroup, target, bCheckFOW, bStationary, planName, queued) end

--- Send a squad command to a squad group with custom data
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target SGroup
---@param cmdparam number
---@param queued boolean
---@return unknown
function LocalCommand_SquadSquadExt(player, sgroup, squadCommand, target, cmdparam, queued) end

--- Send special squad command to a squad group with squad load parameters
--- This is a special command for loading squads into vehicle (squad) holds (SCMD_Load, SCMD_InstantLoad)
---@param player Player
---@param sgroup SGroup
---@param squadCommand SquadCommandType
---@param target SGroup
---@param bOverLoad boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadSquadLoad(player, sgroup, squadCommand, target, bOverLoad, queued) end

--- Sends an upgrade command to a squad group.
---@param player Player
---@param sgroup SGroup
---@param upgrade Upgrade
---@param instant boolean
---@param queued boolean
---@return unknown
function LocalCommand_SquadUpgrade(player, sgroup, upgrade, instant, queued) end

--- Has a player join a specific team
--- Will remove the player from his previous team.  If you pass in nil for newTeam, will add to a new empty team
---@param player Player
---@param teams_table Team
---@return unknown
function Core_AddPlayerToTeam(player, teams_table) end

--- Compare two values using provided comparator
---@param value1 number
---@param value2 number
---@param comparator COMPARISON
---@return unknown
function Core_Compare(value1, value2, comparator) end

--- Returns the number of non-eliminated teams remaining.
---@return unknown
function Core_GetActiveTeamCount() end

--- Returns the table reference of a PLAYERS table entry
---@param playerIndex number
---@return unknown
function Core_GetPlayersTableEntryFromIndex(playerIndex) end

--- Returns the table reference of a player's TEAMS table entry
---@param player Player
---@return unknown
function Core_GetPlayerTeamsEntry(player) end

--- Returns the entry in the Teams table that corresponds to the given teamIndex.
--- NOTE: Use the teams table's .id entry - not the actual index of the table.
---@param index number
---@return unknown
function Core_GetTeamsEntryFromIndex(index) end

--- Returns true if a module is registered for delegate invocation, false if delegate invocation is disabled, nil if module not in module registry.
---@param name string
---@return unknown
function Core_IsModuleRegistered(name) end

--- Returns true if a player is eliminated from the game.
---@param player Player
---@return unknown
function Core_IsPlayerEliminated(player) end

--- Returns true if the two given players are on the same team.
---@return unknown
function Core_IsPlayerOnPlayerTeam() end

--- Returns true if the PLAYERS table contains the given player.
---@param player Player
---@return unknown
function Core_IsPlayersTableEntryValid(player) end

--- Returns true if a team is eliminated from the game. A team is considered eliminated when all of its players are eliminated.
---@param teams_table Team
---@return unknown
function Core_IsTeamEliminated(teams_table) end

--- Returns true if teamIndex is a valid index in the Teams table.
--- NOTE: Use the teams table's .id entry - not the actual index of the table.
---@param index number
---@return unknown
function Core_IsTeamsEntryIndexValid(index) end

--- Call this function to notify other modules (via their ***_OnGameOver() callback) that the match is about to end.
--- Modules typically implement this for cleanup purposes (i.e. remove rules and UI elements) prior to the match end UI.
---@return unknown
function Core_OnGameOver() end

--- Registers a script module for delegate invocation. The name should be the prefix used by all of the delegate functions in this module. This needs to be called in *global* scope of a module script with the prefix name of that module; use this instead of Scar_AddInit.
--- For example, if you call Core_RegisterModule("MySystem") then any delegate functions in your script such as "MySystem_OnGameSetup" or "MySystem_OnInit" will be called at the appropriate time during the game initialization process (after the Project delegates but before the Mission delegates).
---@param name string
---@return unknown
function Core_RegisterModule(name) end

--- Removes a player from player and team tables.
---@param player Player
---@return unknown
function Core_RemovePlayerFromPlayersTable(player) end

--- Returns the value of the "Reveal FOW on Elimination" match option
---@return unknown
function Core_RevealFOWOnEliminationEnabled() end

--- Sets the default presentation table for defeated players.
---@param presentationTable table
---@return unknown
function Core_SetDefaultDefeatPresentation(presentationTable) end

--- Sets the default presentation function for victorious players.
---@param presentationFunction function
---@return unknown
function Core_SetDefaultVictoriousPresentation(presentationFunction) end

--- Sets the relationship between two players
---@param player1 Player
---@param player2 Player
---@param relationship number
---@return unknown
function Core_SetMutualPlayerRelationship(player1, player2, relationship) end

--- Sets the relationship between two entries
--- NOTE: You should generally be setting Team to Team only. Valid Relationships: R_NEUTRAL, R_ALLY, R_ENEMY, R_UNDEFINED
---@param player_teams_table Player | table
---@param player_teams_table_2 Player | table
---@param relationship Relationship
---@return unknown
function Core_SetMutualRelationship(player_teams_table, player_teams_table_2, relationship) end

--- Sets a player as defeated.
---@param player Player
---@param presentationFunction function
---@param reason winReason
---@return unknown
function Core_SetPlayerDefeated(player, presentationFunction, reason) end

--- Sets a player as the match winner.
---@param player Player
---@param presentationFunction function
---@param reason winReason
---@return unknown
function Core_SetPlayerVictorious(player, presentationFunction, reason) end

--- Sets if a team is defeated
---@param teams_table Team
---@param presentationTable table
---@return unknown
function Core_SetTeamDefeated(teams_table, presentationTable) end

--- Sets a team as the match winner.
---@param teams_table Team
---@param presentationFunction function
---@param reason winReason
---@return unknown
function Core_SetTeamVictorious(teams_table, presentationFunction, reason) end

--- Removes a script module from the delegate invocation system.
--- This is usually used for a module to remove itself if it decided it isn't needed (i.e. a game mode that isn't relevant given the map). Please don't have modules removing each other!
---@param name string
---@return unknown
function Core_UnregisterModule(name) end

--- Set the game to a GameOver state without an explicit winner
---@param presentationFunction function
---@param reason winReason
---@return unknown
function Core_WinnerlessGameOver(presentationFunction, reason) end

--- Pauses for a given amount of time. This function MUST be called from a CTRL object in NISlet events only!
--- See Event_Start for more information on NISlet events.
---@param seconds number
---@return unknown
function Event_Delay(seconds) end

--- Returns true if the event is being skipped.
---@return unknown
function Event_IsBeingSkipped() end

--- Completes execution of the event immediately (all calls to Wait() are ignored)
---@return unknown
function Event_Skip() end

--- Starts event.  Event will not start until all rules are evaluated for this frame!
--- We allow saving events in multiplayer so please don't put any non-UI events in multiplayer Running events are not saved at all.
---@param eventFunction function
---@param int number
---@return unknown
function Event_Start(eventFunction, int) end

--- Starts an event the same way as Event_Start, but calls a user defined function when the event is over
---@param eventFunction function
---@param int number
---@param onComplete function
---@return unknown
function Event_StartEx(eventFunction, int, onComplete) end

--- Register an init function with the scar system.
--- This init function will be called when scar is started up.\n **Important: Make sure you do not register two functions with the same name; the init function names should be unique.
---@param f function
---@return unknown
function Scar_AddInit(f) end

--- Lets lua tell the game when it has finished initializing
---@return unknown
function Scar_InitComplete() end

--- Returns true if an init function exists
---@param f function
---@return unknown
function Scar_InitExists(f) end

--- Unregister an init function that was registered from Scar_AddInit
---@param f function
---@return unknown
function Scar_RemoveInit(f) end

--- This is a global function that needs to exist for other things to work correctly. It used to be in module_defend.scar, but wasn't relevant to that particular chunk!
---@param data table
---@return unknown
function _idleBehaviour_stop(data) end

--- Plays the next intel event in the debug queue.  IntelEvents are played sequentially as they are defined in a mission's .events file.
---@return unknown
function _IntelDebugNext() end

--- Plays the next intel event in the debug queue. IntelEvents are played sequentially as they are defined in a mission's .events file.
---@return unknown
function _IntelDebugPrev() end

--- Replays the last intel event that was debugged.
---@return unknown
function _IntelDebugReplay() end

--- Restores various aspects of the single player game after loading a mission from a save game
---@return unknown
function Game_DefaultGameRestore() end

--- Checks whether a callback
---@param callback function
---@return unknown
function Game_GetGameRestoreCallbackExists(callback) end

--- Removes a callback from being called on game restore
---@param callback function
---@return unknown
function Game_RemoveGameRestoreCallback(callback) end

--- Adds a function and set of arguments to be automatically called during restore from a saved game. Maxiumum of 9 parameters. Callback will be called like this: Callback(arg[1], arg[2], ...)
---@param callback function
---@return unknown
function Game_SetGameRestoreCallback(callback) end

--- Enters Cinematic mode
---@param VisibilityFlag_Enums GameUICore | nil
---@param of_GameUICore_VisibilityFlag_enums_to_hide_in_cinematic_mode__Pass_in_an_empty_table_or_nil_to_not_hide_any_game_components__Pass_in_the_constant__DEFAULT_CINEMATIC_HIDDEN_GAME_COMPONENT_FLAGS__for_a_default_set_of_game_components_to_hide_ List | nil
---@param skipNISCallback__optional___Skip_NIS_callback_to_set_ function
---@return unknown
function Util_EnterCinematicMode(VisibilityFlag_Enums, of_GameUICore_VisibilityFlag_enums_to_hide_in_cinematic_mode__Pass_in_an_empty_table_or_nil_to_not_hide_any_game_components__Pass_in_the_constant__DEFAULT_CINEMATIC_HIDDEN_GAME_COMPONENT_FLAGS__for_a_default_set_of_game_components_to_hide_, skipNISCallback__optional___Skip_NIS_callback_to_set_) end

--- Exits Cinematic mode
---@return unknown
function Util_ExitCinematicMode() end

--- Enters Fullscreen mode
---@param VisibilityFlag_Enums GameUICore | nil
---@param of_GameUICore_VisibilityFlag_enums_to_hide_in_fullscreen_mode__Pass_in_an_empty_table_or_nil_to_not_hide_any_game_components__Pass_in_the_constant__DEFAULT_FULLSCREEN_HIDDEN_GAME_COMPONENT_FLAGS__for_a_default_set_of_game_components_to_hide_ List | nil
---@return unknown
function Util_FullscreenMode(VisibilityFlag_Enums, of_GameUICore_VisibilityFlag_enums_to_hide_in_fullscreen_mode__Pass_in_an_empty_table_or_nil_to_not_hide_any_game_components__Pass_in_the_constant__DEFAULT_FULLSCREEN_HIDDEN_GAME_COMPONENT_FLAGS__for_a_default_set_of_game_components_to_hide_) end

--- Wrapper function for command line arguments. DO NOT USE MORE THAN ONCE PER ARGUMENT. It is impossible for them to change after application start, so save the result and reuse it.
---@param key_of_the_argument_you_want_to_query string
---@return unknown
function Util_GetCommandLineArgument(key_of_the_argument_you_want_to_query) end

--- Returns whether cinematic mode is active
---@return unknown
function Util_IsCinematicMode() end

--- Enters Normal mode
---@return unknown
function Util_NormalMode() end

--- Reverses the entries of the table that is passed to the function
--- This function will iterate over a 1D array/table and flip it, so that the first element is the last, the last is the first, and so on.
---@param list_to_reverse table
---@return unknown
function Util_ReverseList(list_to_reverse) end

--- Checks if Resources_Disable is currently applying to a player.
---@return unknown
function Are_Resources_Disabled() end

--- Returns a string describing the Scartype
---@return unknown
function Debug_ScartypeToString() end

--- Disables any resource income - useful to stop resources accruing during the opening movie
---@return unknown
function Resources_Disable() end

--- Re-enables resource income.
---@return unknown
function Resources_Enable() end

--- Adds an entity to the end of a group if the group doesnt already have it.
---@param group EGroup
---@param entity Entity
---@return unknown
function EGroup_Add(group, entity) end

--- Adds an ability to all entities in an egroup.
---@param egroup EGroup
---@param ability number
---@return unknown
function EGroup_AddAbility(egroup, ability) end

--- Appends the entities in one group to another group.
--- All entities from 'grouptoadd' will be added to 'group'.\n If 'group' already contains an entity from 'grouptoadd' it will not be added.\n This function does not clear the contents of 'grouptoadd'.\n Example: Add group2 (0, 10, 11, 22) to group1 (1, 11, 20) --> group1 would now be (1, 11, 20, 0, 10, 22)\n
---@param group EGroup
---@param grouptoadd EGroup
---@return unknown
function EGroup_AddEGroup(group, grouptoadd) end

--- Returns true if ALL or ANY entities in a group can see ALL or ANY entities in a given egroup.
---@param egroup EGroup
---@param targetegroup EGroup
---@param all boolean
---@return unknown
function EGroup_CanSeeEGroup(egroup, targetegroup, all) end

--- Returns true if ALL or ANY entities in a group can see ALL or ANY squads in a given sgroup.
---@param egroup EGroup
---@param targetsgroup SGroup
---@param all boolean
---@return unknown
function EGroup_CanSeeSGroup(egroup, targetsgroup, all) end

--- Removes all entities from a group
---@param egroup EGroup
---@return unknown
function EGroup_Clear(egroup) end

--- Returns true if the contents of the two groups are equal. Order of the entities does not matter.
---@param group1 EGroup
---@param group2 EGroup
---@return unknown
function EGroup_Compare(group1, group2) end

--- Check if a group contains ALL or ANY of the blueprints.
---@param egroup EGroup
---@param blueprint EntityPBG | EntityType | table
---@param all boolean
---@return unknown
function EGroup_ContainsBlueprints(egroup, blueprint, all) end

--- Returns true if EGroup1 contains ANY or ALL of EGroup2
---@param egroup1 EGroup
---@param egroup2 EGroup
---@param all boolean
---@return unknown
function EGroup_ContainsEGroup(egroup1, egroup2, all) end

--- Returns true if EGroup contains a particular EntityID
---@param egroup EGroup
---@param entity Entity
---@return unknown
function EGroup_ContainsEntity(egroup, entity) end

--- Returns the total number of spawned and despawned entities in a group.
---@param egroup EGroup
---@return unknown
function EGroup_Count(egroup) end

--- Get the number of alive entities (both spawned and despawned)
---@param egroup EGroup
---@return unknown
function EGroup_CountAlive(egroup) end

--- Returns the total count of all entities in a given EGroup with the provided blueprint
---@param sgroup EGroup
---@param ebp number
---@return unknown
function EGroup_CountBlueprints(sgroup, ebp) end

--- Returns the number of despawned entities in a group.
---@param egroup EGroup
---@return unknown
function EGroup_CountDeSpawned(egroup) end

--- Returns the number of spawned entities in a group.
---@param egroup EGroup
---@return unknown
function EGroup_CountSpawned(egroup) end

--- Returns a new entity group with the given name.
--- Entity groups are used for buildings and objects such as rocks and trees.\n If you need to issue orders to a group vehicles or units you must use a SGroup.\n Note that you cannot create egroups with duplicate names.\n To be safe, you can check if the EGroup you want to create exists using EGroup_Exists( )
---@param name string
---@return unknown
function EGroup_Create(name) end

--- Find a entity group from name.  Creates a new one with given name if it doesnt exist.
---@param egroupname string
---@return unknown
function EGroup_CreateIfNotFound(egroupname) end

--- Returns an EGroup with a unique name, prefixed by the 'prefix' parameter.
---@param prefix string | nil
---@return unknown
function EGroup_CreateUnique(prefix) end

--- Returns a new entity group with an autogenerated unique name, optionally prefixed by the string passed in.
--- Use this if you want to create a new EGroup but don't necessarily care about the name.\n Entity groups are used for buildings and objects such as rocks and trees.\n
---@param prefix string
---@return unknown
function EGroup_CreateUniqueWithPrefix(prefix) end

--- Despawn all spawned entities in a group.
---@param egroup EGroup
---@return unknown
function EGroup_DeSpawn(egroup) end

--- Manually destroy a group that you don't need anymore.
---@param egroup EGroup
---@return unknown
function EGroup_Destroy(egroup) end

--- Destroys all spawned and despawned entities in a group.
--- Be careful not to confuse this with EGroup_Destroy which destroys the group and NOT the items it contains.  This function will destroy spawned and despawned items in a group
---@param egroup EGroup
---@return unknown
function EGroup_DestroyAllEntities(egroup) end

--- Duplicates an EGroup. Creates a copy of egroup1 in egroup2. The function will clear egroup2 beforehand if necessary.
---@param egroupid1 EGroup
---@param egroupid2 EGroup
---@return unknown
function EGroup_Duplicate(egroupid1, egroupid2) end

--- Enables or disables the minimap indicator for all entities in a group
---@param egroup EGroup
---@param enable boolean
---@return unknown
function EGroup_EnableMinimapIndicator(egroup, enable) end

--- Returns true if the entity group with the given name exists
---@param name string
---@return unknown
function EGroup_Exists(name) end

--- Filters an EGroup by blueprint or type.
--- Blueprints can be provided by name or by ID, and in a table if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing entities of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same entities out and leave those that aren't of the types listed.
---@param egroup EGroup
---@param blueprint_type string
---@param filtertype number
---@param splitGroup EGroup | nil
---@return unknown
function EGroup_Filter(egroup, blueprint_type, filtertype, splitGroup) end

--- Filters an EGroup by whether units are on screen or not. Percent refers to the screen area you are considering (0.8 is a good value to use - it won't include things that are right at the screen edge).
--- Setting filtertype to FILTER_KEEP results in the group only containing those entities that are on screen.
---@param egroup EGroup
---@param percent number
---@param filtertype number
---@return unknown
function EGroup_FilterOnScreen(egroup, percent, filtertype) end

--- Filters an EGroup by whether or not the entity is part of a squad. filter_type can be FILTER_KEEP or FILTER_REMOVE
---@param egroup EGroup
---@param filter_type number
---@return unknown
function EGroup_FilterSquads(egroup, filter_type) end

--- Filters an EGroup by construction status. Set the filtertype to FILTER_REMOVE to remove buildings under construction.
--- Setting filtertype to FILTER_KEEP results in the group only containing those entities that are in the process of being built.
---@param egroup EGroup
---@param filtertype number
---@return unknown
function EGroup_FilterUnderConstruction(egroup, filtertype) end

--- Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue.
--- function Rule_Test( )\n \tlocal DespawnEntity = function( egroupid, itemindex, entityID )\n \t\tEntity_Despawn( entityID )\n \tend\n\n \tEGroup_ForEach( EGroup_FromName("eg_PlayersHQ"), DespawnEntity )\n end\n Note: This function iterates over SPAWNED ENTITIES ONLY.
---@param egroup EGroup
---@param f function
---@return unknown
function EGroup_ForEach(egroup, f) end

--- Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool.
--- Only use this to TEST conditions on entities. DO NOT use this to perform operations on all entities, since it may not call your function on all entities (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)\n Note: This function iterates over SPAWNED ENTITIES ONLY.
---@param egroup EGroup
---@param all boolean
---@param f function
---@return unknown
function EGroup_ForEachAllOrAny(egroup, all, f) end

--- Same as EGroup_ForEachAllOrAny except you have a choice to iterate over spawned entities, despawned entities, or both.
---@param egroup EGroup
---@param all boolean
---@param f function
---@param spawned boolean
---@param despawned boolean
---@return unknown
function EGroup_ForEachAllOrAnyEx(egroup, all, f, spawned, despawned) end

--- Same as EGroup_ForEach except you have a choice to iterate over spawned entities, despawned entities, or both.
---@param egroup EGroup
---@param f function
---@param spawned boolean
---@param despawned boolean
---@return unknown
function EGroup_ForEachEx(egroup, f, spawned, despawned) end

--- Find an entity group with a given name.
---@param name string
---@return unknown
function EGroup_FromName(name) end

--- Returns the average health ratio of all units in a entity group.
--- This uses the "proper" measure of health for panel buildings, so should accurately reflect what the user sees.
---@param egroup EGroup
---@return unknown
function EGroup_GetAvgHealth(egroup) end

--- Gets the COUNT closest entities to POSITION from EGROUP. Does NOT remove entities from the source EGroup
---@return unknown
function EGroup_GetClosestEntities() end

--- Get the closest entity in an egroup to a given position
---@param egroupid EGroup
---@param position Marker | Position
---@return unknown
function EGroup_GetClosestEntity(egroupid, position) end

--- Returns the despawned entity at the given index.
--- Use EGroup_GetSpawnedEntityAt if you want the spawned items in the group\n Use index 1 to get the first entity in the group.\n It is an error if index > EGroup_GetCountDeSpawned()\n
---@param group EGroup
---@param int number
---@return unknown
function EGroup_GetDeSpawnedEntityAt(group, int) end

--- Check invulnerablity state for ALL or ANY entity in an entity group.
--- Set all param to true to check for ALL or set to false to check for ANY.
---@param egroup EGroup
---@param all boolean
---@return unknown
function EGroup_GetInvulnerable(egroup, all) end

--- Gets the last attacker(s) for all the entities in an EGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker
---@param EGroupVictim EGroup
---@param SGroupAttacker SGroup
---@return unknown
function EGroup_GetLastAttacker(EGroupVictim, SGroupAttacker) end

--- Returns the name of a given entity group.
---@param egroup EGroup
---@return unknown
function EGroup_GetName(egroup) end

--- Returns a position (a certain distance away) relative to an entity's current position/orientation. see ScarUtil.scar for explanation of 'offset' parameter
---@param egroup EGroup
---@param offset number
---@param value number
---@return unknown
function EGroup_GetOffsetPosition(egroup, offset, value) end

--- Returns the center position of an entity group.
---@param group EGroup
---@return unknown
function EGroup_GetPosition(group) end

--- Get a random spawned entity from egroup
---@param egroupid EGroup
---@return unknown
function EGroup_GetRandomSpawnedEntity(egroupid) end

--- Builds a table of EGroupIDs that are named in a sequence. i.e. a name of "eg_building" will find groups "eg_building1", "eg_building2" and so on, up until it looks for a group that isn't there.
---@param name string
---@return unknown
function EGroup_GetSequence(name) end

--- Returns the spawned entity at the given index.
--- Use EGroup_GetDeSpawnedEntityAt if you want the despawned items in the group\n Use index 1 to get the first entity in the group.\n It is an error if index > EGroup_GetCountSpawned()\n
---@param group EGroup
---@param int number
---@return unknown
function EGroup_GetSpawnedEntityAt(group, int) end

--- Get the first spawned entity from egroup that meets the condition (a function that takes an entity)
---@param egroupid EGroup
---@param condition_entity_ function
---@return unknown
function EGroup_GetSpawnedEntityFilter(egroupid, condition_entity_) end

--- Returns the distance from the centre of the group of the entity that furthest out.
---@param egroup EGroup
---@return unknown
function EGroup_GetSpread(egroup) end

--- Returns an sgroup containing all squads held by any entities in an egroup
---@param egroup EGroup
---@param sgroupRecipient SGroup
---@return unknown
function EGroup_GetSquadsHeld(egroup, sgroupRecipient) end

--- Returns the total health of all units in a entity group.
--- This uses the "proper" measure of health for panel buildings, so should accurately reflect what the user sees.
---@param egroup EGroup
---@return unknown
function EGroup_GetTotalHealth(egroup) end

--- Test whether ANY or ALL buildings in a group have a specified ability
---@param egroup EGroup
---@param ability number
---@param all boolean
---@return unknown
function EGroup_HasAbility(egroup, ability, all) end

--- Check if ANY or ALL of the entities in a group match the blueprint specified.
--- The blueprint can be a table of blueprints or types (see Entity_HasBlueprint() for details)
---@param egroup EGroup
---@param blueprint EntityPBG | EntityType | table
---@param all boolean
---@return unknown
function EGroup_HasBlueprint(egroup, blueprint, all) end

--- Returns whether ANY or ALL entities in an EGroup have the specified upgrade
---@param egroup EGroup
---@param upgrade Upgrade
---@param all boolean
---@return unknown
function EGroup_HasUpgrade(egroup, upgrade, all) end

--- Hide or show all entities in an EGroup
--- Bool should be true to hide, false to show
---@param egroup EGroup
---@param hide boolean
---@return unknown
function EGroup_Hide(egroup, hide) end

--- Change the ownership of a Strategic Point
---@param egroup EGroup
---@param player Player
---@return unknown
function EGroup_InstantCaptureStrategicPoint(egroup, player) end

--- Reverts an occupied building
---@param egroup EGroup
---@return unknown
function EGroup_InstantRevertOccupiedBuilding(egroup) end

--- Performs a group intersection.
--- Only entities that are in both groups will be added to 'group'.\n The contents of 'grouptointersect' will not be changed.\n Example: group = (1,2,3,4,5,6)  grouptointersect = (2,4,6,8,10)   --> group will now equal (2,4,6)
---@param group EGroup
---@param grouptointersect EGroup
---@return unknown
function EGroup_Intersection(group, grouptointersect) end

--- Checks if ANY or ALL entities in an egroup are on fire (ignition threshold exceeded)
---@param egroup EGroup
---@param ALL boolean
---@return unknown
function EGroup_IsBurning(egroup, ALL) end

--- Returns true if all or any strategic points in a group have been captured. Use ANY or ALL.
--- This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.
---@param egroup EGroup
---@param playerId Player
---@param all boolean
---@return unknown
function EGroup_IsCapturedByPlayer(egroup, playerId, all) end

--- Returns true if all or any strategic points in a group have been captured. Use ANY or ALL.
--- This function will ignore all entities that cannot be captured and will return false if no entities in the group can be captured.
---@param egroup EGroup
---@param teamId TeamID
---@param all boolean
---@return unknown
function EGroup_IsCapturedByTeam(egroup, teamId, all) end

--- Returns true if ALL or ANY entities are attacking within the time
---@param egroup EGroup
---@param all boolean
---@param time number
---@return unknown
function EGroup_IsDoingAttack(egroup, all, time) end

--- Returns true if a named entity group contains no spawned or despawned entities
---@param egroup EGroup
---@return unknown
function EGroup_IsEmpty(egroup) end

--- Returns whether any entity in an EGroup has a hold on anything
---@param egroup EGroup
---@return unknown
function EGroup_IsHoldingAny(egroup) end

--- Returns true if ALL or ANY entities are in cover.
---@param egroup EGroup
---@param all boolean
---@return unknown
function EGroup_IsInCover(egroup, all) end

--- Returns true if ANY or ALL entities in an EGroup are moving.
---@param egroupid EGroup
---@param all boolean
---@return unknown
function EGroup_IsMoving(egroupid, all) end

--- Returns true if ANY or ALL (use those keywords) of the enities in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen.
---@param player Player
---@param group EGroup
---@param all boolean
---@param percent number | nil
---@return unknown
function EGroup_IsOnScreen(player, group, all, percent) end

--- Returns true if ALL or ANY entities in a group are currently producing squads
--- Set all to true to check for ALL or set to false to check for ANY
---@param egroup EGroup
---@param all boolean
---@return unknown
function EGroup_IsProducingSquads(egroup, all) end

--- Checks if ANY or ALL entities in an group are currently spawned or not.
---@param egroup EGroup
---@param ALL boolean
---@return unknown
function EGroup_IsSpawned(egroup, ALL) end

--- Returns true if ALL or ANY entities are under attack within the time
---@param egroup EGroup
---@param all boolean
---@param time number
---@return unknown
function EGroup_IsUnderAttack(egroup, all, time) end

--- Check if the entities are attacked by the player
---@param group EGroup
---@param attackerplayer Player
---@param duration number
---@return unknown
function EGroup_IsUnderAttackByPlayer(group, attackerplayer, duration) end

--- Returns true if ALL or ANY entities are under attack from a direction within the time. see ScarUtil.scar for types of directions. you can pass in a table of offsets
---@param egroup EGroup
---@param all boolean
---@param offset number
---@param time number
---@return unknown
function EGroup_IsUnderAttackFromDirection(egroup, all, offset, time) end

--- Checks if ANY or ALL squads within an EGroup are using an ability
--- also used for emplacements/entities that are built but function through the use of squads.  Does not check WHAT ability a squad is using.
---@param egroup EGroup
---@param ALL boolean
---@return unknown
function EGroup_IsUsingAbility(egroup, ALL) end

--- Check to see if an egroup still exists without needing the name.
---@param egroupID number
---@return unknown
function EGroup_IsValid(egroupID) end

--- Kill all entities in an EGroup
---@param egroup EGroup
---@return unknown
function EGroup_Kill(egroup) end

--- Calls a function when any entity in an EGroup gets destroyed by the player clicking the "Detonate me" button
---@param id EGroup
---@param _function function
---@return unknown
function EGroup_NotifyOnPlayerDemolition(id, _function) end

--- Removes an entity from a group.
---@param group EGroup
---@param entity Entity
---@return unknown
function EGroup_Remove(group, entity) end

--- Removes any entites that exist in both groups.
--- Entities that exist in both groups will be removed from 'group'.\n The contents of 'grouptocompare' will not be changed.\n Example: group = (1,2,3,4,5,6)  grouptocompare = (1,2,3,8,10)   --> group will now equal (4,5,6)
---@param group EGroup
---@param grouptocompare EGroup
---@return unknown
function EGroup_RemoveAllMatching(group, grouptocompare) end

--- Removes all demolition charges on an egroup
---@param egroup EGroup
---@return unknown
function EGroup_RemoveDemolitions(egroup) end

--- Remove from the first EGroup all entities contained in the second EGroup. EGroup2 remains untouched.
---@param group EGroup
---@param grouptoremove EGroup
---@return unknown
function EGroup_RemoveGroup(group, grouptoremove) end

--- Removes all the entities from the EGroup that don't have HoldExt on them
---@param egroup EGroup
---@return unknown
function EGroup_RemoveNonHoldEntities(egroup) end

--- Removes upgrade(s) from an egroup
---@param egroup EGroup
---@param upgrade number
---@return unknown
function EGroup_RemoveUpgrade(egroup, upgrade) end

--- Respawn all despawned entities in a group.
---@param egroup EGroup
---@return unknown
function EGroup_ReSpawn(egroup) end

--- Trigger animation action for an EGroup. Please only use this for simple animations
---@param egroup EGroup
---@param actionName string
---@return unknown
function EGroup_SetAnimatorAction(egroup, actionName) end

--- Set animation event for an EGroup. Please only use this for simple animations
---@param egroup EGroup
---@param eventName string
---@return unknown
function EGroup_SetAnimatorEvent(egroup, eventName) end

--- Set animation state of a state machine for an EGroup. Please only use this for simple animations
---@param egroup EGroup
---@param stateMachineName string
---@param stateName string
---@return unknown
function EGroup_SetAnimatorState(egroup, stateMachineName, stateName) end

--- Set animation variable value for an EGroup. Please only use this for simple animations
---@param egroup EGroup
---@param variableName string
---@param value number
---@return unknown
function EGroup_SetAnimatorVariable(egroup, variableName, value) end

--- Sets whether a weapon to auto-target things or not
---@param group EGroup
---@param hardpoint string
---@param enable boolean
---@return unknown
function EGroup_SetAutoTargetting(group, hardpoint, enable) end

--- Sets the health of each unit in an entity group to a given percent [0.0, 1.0].
---@param egroup EGroup
---@param healthPercent number
---@return unknown
function EGroup_SetAvgHealth(egroup, healthPercent) end

--- Overrides crushable behavior for an egroup
---@param egroup EGroup
---@param crushable boolean
---@return unknown
function EGroup_SetCrushable(egroup, crushable) end

--- Instantly wires a building for demolitions
---@param player Player
---@param egroupid EGroup
---@param numcharges number | nil
---@return unknown
function EGroup_SetDemolitions(player, egroupid, numcharges) end

--- Set the minimum health for this entity
--- This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value
---@param egroup EGroup
---@param minhealth number
---@return unknown
function EGroup_SetHealthMinCap(egroup, minhealth) end

--- Enable/Disable invulnerablity for an entire entity group. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage an entity can take before it takes no more.
--- The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, health damage is disabled.
---@param egroup EGroup
---@param enabled boolean
---@param reset_time number | nil
---@return unknown
function EGroup_SetInvulnerable(egroup, enabled, reset_time) end

--- Changes the player owner for all spawned and despawned entities of an EGroup.
--- Strategic/capturable point does not support setting player owner directly
---@param egroup EGroup
---@param owner Player
---@return unknown
function EGroup_SetPlayerOwner(egroup, owner) end

--- Set the rally point for this entity
--- This is usually set to zero, any higher value prevents the entity from having its health reduced below this given value
---@param egroup EGroup
---@param target Position
---@return unknown
function EGroup_SetRallyPoint(egroup, target) end

--- Sets all entities in an egroup to be recrewable or not when abandoned
---@param sgroup EGroup
---@param recrewable boolean
---@return unknown
function EGroup_SetRecrewable(sgroup, recrewable) end

--- Set player selectable state of entities in the egroup
---@param egroup EGroup
---@param selectable boolean
---@return unknown
function EGroup_SetSelectable(egroup, selectable) end

--- Enables shared team production on a building (teammates can build using THEIR resources)
---@param egroup EGroup
---@param enable boolean
---@return unknown
function EGroup_SetSharedProductionQueue(egroup, enable) end

--- Sets a strategic point to neutral (not owned by any team)
---@param egroup EGroup
---@return unknown
function EGroup_SetStrategicPointNeutral(egroup) end

--- Makes an egroup neutral
---@param egroup EGroup
---@return unknown
function EGroup_SetWorldOwned(egroup) end

--- Creates an entity group containing a single entity
--- Creates an EGroup containing just one entity, creating the group if it doesn't exist and clearing it if it does. It returns the name of the EGroup.
---@param egroup EGroup
---@param entity Entity
---@return unknown
function EGroup_Single(egroup, entity) end

--- Sorts the EGroup based on health
---@param egroup EGroup
---@param ascending boolean
---@return unknown
function EGroup_SortBasedOnHealth(egroup, ascending) end

--- Warps all members of an EGroup immediately to a marker
---@param entity EGroup
---@param marker Marker
---@return unknown
function EGroup_WarpToMarker(entity, marker) end

--- Warps all members of an EGroup immediately to a new position
---@param entity EGroup
---@param pos Position
---@return unknown
function EGroup_WarpToPos(entity, pos) end

--- Returns the total health of all units combined in a squad group.
---@param sgroup SGroup
---@return unknown
function SGroup_GetTotalHealth(sgroup) end

--- Returns true if ANY or ALL of the squad's entities have the specified upgrade
---@param egroup EGroup
---@param upgrade Upgrade
---@param all boolean
---@return unknown
function SGroup_HasEntityUpgrade(egroup, upgrade, all) end

--- Finds all encounters that contain ANY or ALL squads within the given sgroup.
---@param sgroup SGroup
---@param all any | ALL
---@return unknown
function Ai(sgroup, all) end

--- Finds all encounters that contain ANY or ALL squads within the given sgroup.
---@param squad Squad
---@return unknown
function Ai(squad) end

--- Disables all encounters
---@return unknown
function AI_DisableAllEncounters() end

--- Enables all encounters
---@return unknown
function AI_EnableAllEncounters() end

--- Returns a table with all active (not dead) encounters.
---@return unknown
function AI_GetActiveEncounters() end

--- Returns the number of alive encounters currently managed by the AI manager.
---@return unknown
function AI_GetNumEncounters() end

--- Returns True if the current AI_Manager difficulty matches any in a given list.
---@param difficultyList number
---@return unknown
function AI_IsMatchingDifficulty(difficultyList) end

--- Overrides the current difficulty setting (only for the AI Manager). Pass 'nil' to reset to Game_GetSPDifficulty() value
---@param level number
---@return unknown
function AI_OverrideDifficulty(level) end

--- Clears goals on all encounters, then empties the encounter list. Can also issue a stop command to all units.
---@param stopAll boolean
---@return unknown
function AI_RemoveAllEncounters(stopAll) end

--- Set the level of debug information shown but Ai:Print().
---@return unknown
function AI_SetDebugLevel() end

--- Sets the default player to use when creating an encounter.
---@param player Player
---@return unknown
function AI_SetDefaultEnemyPlayer(player) end

--- Toggle encounter/goal debug information on screen.
---@return unknown
function AI_ToggleDebugData() end

--- Toggle printing console debug information for encounters.
---@return unknown
function AI_ToggleDebugPrint() end

--- Adjust default goal data for ability goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter ability goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIAbilityGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for ability goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter ability goal values.
---@param defaultGoalData table
---@return unknown
function AIAbilityGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for ability goals.  modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter ability goal value.
---@param modifyGoalData table
---@return unknown
function AIAbilityGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for ability goals.  overrideGoalData is cloned; any values specified are used for encounter ability goal values.
---@param overrideGoalData table
---@return unknown
function AIAbilityGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for attack goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter attack goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIAttackGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for attack goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter attack goal values.
---@param defaultGoalData table
---@return unknown
function AIAttackGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for attack goals.  modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter attack goal value.
---@param modifyGoalData table
---@return unknown
function AIAttackGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for attack goals.  overrideGoalData is cloned; any values specified are used for encounter attack goal values.
---@param overrideGoalData table
---@return unknown
function AIAttackGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIBaseGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data.  defaultGoalData is cloned; any values specified are used for unspecified encounter goal values.
---@param defaultGoalData table
---@return unknown
function AIBaseGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data.  modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter goal value.
---@param modifyGoalData table
---@return unknown
function AIBaseGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data.  overrideGoalData is cloned; any values specified are used for encounter goal values.
---@param overrideGoalData table
---@return unknown
function AIBaseGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for defend goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter defend goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIDefendGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for defend goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter defend goal values.
---@param defaultGoalData table
---@return unknown
function AIDefendGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for defend goals.  modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter defend goal value.
---@param modifyGoalData table
---@return unknown
function AIDefendGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for defend goals.  overrideGoalData is cloned; any values specified are used for encounter defend goal values.
---@param overrideGoalData table
---@return unknown
function AIDefendGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for attack goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter attack goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIFormationAttackGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for attack goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter attack goal values.
---@param defaultGoalData table
---@return unknown
function AIFormationAttackGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for attack goals.  modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter attack goal value.
---@param modifyGoalData table
---@return unknown
function AIFormationAttackGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for attack goals.  overrideGoalData is cloned; any values specified are used for encounter attack goal values.
---@param overrideGoalData table
---@return unknown
function AIFormationAttackGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for DefendArea goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter DefendArea goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIFormationDefendAreaGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for DefendArea goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter DefendArea goal values.
---@param defaultGoalData table
---@return unknown
function AIFormationDefendAreaGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for DefendArea goals.  modifyGoalData is cloned; values specified via keyname_Multiplier are used for the numeric keyname encounter DefendArea goal value.
---@param modifyGoalData table
---@return unknown
function AIFormationDefendAreaGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for DefendArea goals.  overrideGoalData is cloned; any values specified are used for encounter DefendArea goal values.
---@param overrideGoalData table
---@return unknown
function AIFormationDefendAreaGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for move goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter move goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AIMoveGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for move goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter move goal values.
---@param defaultGoalData table
---@return unknown
function AIMoveGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for move goals.  modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter move goal value.
---@param modifyGoalData table
---@return unknown
function AIMoveGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for move goals.  overrideGoalData is cloned; any values specified are used for encounter move goal values.
---@param overrideGoalData table
---@return unknown
function AIMoveGoal_SetOverrideGoalData(overrideGoalData) end

--- Adjust default goal data for TownLife goals.  Sets the default GoalData to the current defaults plus additionalDefaultGoalData; any values specified are used for unspecified encounter TownLife goal values.
---@param additionalDefaultGoalData table
---@return unknown
function AITownLifeGoal_AdjustDefaultGoalData(additionalDefaultGoalData) end

--- Set default goal data for TownLife goals.  defaultGoalData is cloned; any values specified are used for unspecified encounter TownLife goal values.
---@param defaultGoalData table
---@return unknown
function AITownLifeGoal_SetDefaultGoalData(defaultGoalData) end

--- Set modify goal data for TownLife goals.  modifyGoalData is cloned; values specified via keyname_Multiply are used for the numeric keyname encounter TownLife goal value.
---@param modifyGoalData table
---@return unknown
function AITownLifeGoal_SetModifyGoalData(modifyGoalData) end

--- Set override goal data for TownLife goals.  overrideGoalData is cloned; any values specified are used for encounter TownLife goal values.
---@param overrideGoalData table
---@return unknown
function AITownLifeGoal_SetOverrideGoalData(overrideGoalData) end

--- Create a new encounter from encounter data. If spawnNow is true, spawns specified units immediately.
--- See: http://relicwiki/display/REL/Ai+Encounters
---@param data EncounterData
---@param spawnNow boolean | nil
---@param spawnStaggered number | nil
---@return unknown
function Encounter(data, spawnNow, spawnStaggered) end

--- Create a new encounter with a generic FormationAttack goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param encRange number | nil
---@param encLeash number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, encRange, encLeash) end

--- Create a new encounter with a generic FormationAttack goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param encRange number | nil
---@param encLeash number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, encRange, encLeash) end

--- Create a new encounter with a generic Attack goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param encRange number | nil
---@param encLeash number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, encRange, encLeash) end

--- Create a new encounter with a generic Defend goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param encRange number | nil
---@param encLeash number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, encRange, encLeash) end

--- Create a new encounter with a generic Patrol goal.
--- pathLoop can be: LOOP_NONE, LOOP_NORMAL, LOOP_TOGGLE_DIRECTION
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encPath string
---@param dynamicSpawn Marker | Position | nil
---@param pathWait number | nil
---@param pathLoop number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encPath, dynamicSpawn, pathWait, pathLoop) end

--- Create a new encounter with a generic Move goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param moveRange number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, moveRange) end

--- Create a new encounter with a generic Ability goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param moveRange number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, moveRange) end

--- Create a new encounter with a generic TownLife goal.
---@param name string
---@param encUnits SBP | table
---@param spawnLoc Marker | Position
---@param encTarget EGroup
---@param dynamicSpawn Marker | Position | nil
---@param townLifeRange number | nil
---@return unknown
function Encounter(name, encUnits, spawnLoc, encTarget, dynamicSpawn, townLifeRange) end

--- Create a new basic encounter.
---@param name string
---@param spawnLoc Marker | Position
---@param encUnits SBP | table
---@param dynamicSpawn Marker | Position | nil
---@return unknown
function Encounter(name, spawnLoc, encUnits, dynamicSpawn) end

--- Create a new encounter from an SGroup, with default encounter data
--- Encounter player is derived from sgroup; all squads in sgroup must be owned by same player.
---@param squadgroup SGroup
---@return unknown
function Encounter(squadgroup) end

--- Spawns the units within an. Does nothing if the encounter has already been spawned.
---@param spawnStaggered boolean
---@return unknown
function Encounter(spawnStaggered) end

--- Adds unit(s) to the encounter
--- See Encounter.scar for details unitData is a table that can either hold a single unit OR a set of unit tables The format of each individual unit table is the same as regular encounter unit tables spawnType is of type SPAWN.<>
---@param unitData table
---@param spawnType SPAWN
---@return unknown
function Encounter(unitData, spawnType) end

--- Creates encounter goal from goal data; goals determine unit behaviours.
--- See: http://relicwiki/display/REL/Ai+Goal
---@param goalData GoalData
---@param triggerGoal__dafault_true_ boolean
---@param previousEncounterID HandleID | nil
---@return unknown
function Encounter(goalData, triggerGoal__dafault_true_, previousEncounterID) end

--- Determines whether or not the encounter has an active and valid goal.
---@return unknown
function Encounter() end

--- Clears the current goal.
---@return unknown
function Encounter() end

--- Removes an encounter's onSight/onEngage event and immediately starts its goal.
--- Only works if the encounter has both data.goal, and a valid goal trigger
---@return unknown
function Encounter() end

--- Moves back the goal to the original location
--- Only works if the goal was previously relocated after being triggered
---@return unknown
function Encounter() end

--- If encounter has a goal, but no currently running AI Encounter, restarts the goal.
--- Returns true if goal was restarted, false otherwise. If we pass a previousEncounterID, it restarts the encounter using that handle id. This is used for save / load
---@return unknown
function Encounter() end

--- Sets the goal data for the encounter. If encounter has a goal with a running AI Encounter, updates the goal.
--- See: http://relicwiki/display/REL/Ai+Goal Use GetGoalData() to get
---@param goalData GoalData
---@return unknown
function Encounter(goalData) end

--- Gets clone of current goal data.  May be nil.
---@return unknown
function Encounter() end

--- Gets the encounter's sgroup. Caution: sgroup may be empty
---@return unknown
function Encounter() end

--- Gets the encounter's nearby allied Egroup. Caution: egroup may be empty. Automatically created whenever the Encounter triggers OnEngage or OnAttacked. To force the EGroup creation call Encounter:UpdateNearbyAllies()
---@return unknown
function Encounter() end

--- Starts encounter running (encounters are enabled by default) if it was disabled previously.
---@return unknown
function Encounter() end

--- Stops running the encounter and clears the current goal.
---@return unknown
function Encounter() end

--- After adding units to a pre-existing encounter it is sometimes necessary to reboot it, as it may have disabled itself if all it's units died. This function checks and does that safely.
---@return unknown
function Encounter() end

--- Removes all encounter units that belong to the given sgroup
---@return unknown
function Encounter() end

--- Find and removes a unit from an encounter based on the squad.
---@return unknown
function Encounter() end

--- Adds an sgroup to an encounter
---@return unknown
function Encounter() end

--- Forces the encounter to spawn its units instantly
---@return unknown
function Encounter() end

--- Clears the encounter's onDeath callback. If includeUnits is set to true, it clears onDeath callbacks for units as well.
---@param includeUnits boolean
---@return unknown
function Encounter(includeUnits) end

--- Sets a new onDeath callback for the encounter
---@param func function
---@return unknown
function Encounter(func) end

--- Set the goal's OnSuccess callback.
---@return unknown
function Encounter() end

--- Set the goal's OnFailure callback.
---@return unknown
function Encounter() end

--- Callback helper function for relocate an Encounter goal. Name of parameters: 'encounter'.
--- Example usage: Event_*(EventHandler_ResetGoalRelocation, {encounter = <myEncounter>}, ...)
---@param data table
---@return unknown
function EventHandler_RelocateGoal(data) end

--- Callback helper function for relocate  an Encounter goal to the original location. Name of parameters: 'encounter'.
--- Example usage: Event_*(EventHandler_ResetGoalRelocation, {encounter = <myEncounter>}, ...)
---@param data table
---@return unknown
function EventHandler_ResetGoalRelocation(data) end

--- Callback helper function for triggering an Encounter goal. Name of parameters: 'encounter'.
--- Invokes Encounter:TriggerGoal() for data.encounter Example usage: Event_*(EventHandler_TriggerEncounterGoal, {encounter = <myEncounter>}, ...)
---@param data table
---@return unknown
function EventHandler_TriggerEncounterGoal(data) end

--- Merge clones two table (recursively) into a single table combining into a new table allowing for unadulterated use of the data
---@param defaultTable table
---@param overrideTable table
---@return unknown
function MergeClone(defaultTable, overrideTable) end

--- Returns true if the active command is of the type we specified
---@param entity Entity
---@param cmdtype EntityCommandType
---@return unknown
function Entity_ActiveCommandIs(entity, cmdtype) end

--- Allows the entity to use this ability
---@param entity Entity
---@param ability Ability
---@return unknown
function Entity_AddAbility(entity, ability) end

--- Add a specific amount of a certain resource type to an entity.
---@param entity Entity
---@param type number
---@param amount number
---@return unknown
function Entity_AddResource(entity, type, amount) end

--- Advance ability cooldown
---@param entity Entity
---@param tickAmount number
---@return unknown
function Entity_AdjustAbilityCooldown(entity, tickAmount) end

--- Builds the cycle list based on current tagged entity
---@return unknown
function Entity_BuildCycleList() end

--- pass in a entity and position to resolve the position into a open space position, if the position is not free, position returned will try to be the closest position near the original position
---@param entity Entity
---@param pos Position
---@return unknown
function Entity_CalculatePassableSpawnPosition(entity, pos) end

--- Returns whether an entity can attack a target without moving or turning.
---@param attacker Entity
---@param target Position
---@return unknown
function Entity_CanAttackNow(attacker, target) end

--- Cancels an item in a production queue.  Index 0 is the currently producing item.
---@param entity Entity
---@param index number
---@return unknown
function Entity_CancelProductionQueueItem(entity, index) end

--- Check if an entity can currently be damaged.
---@param entity Entity
---@return unknown
function Entity_CanCurrentlyBeDamaged(entity) end

--- Check if the entity can load squad or not
---@param entity Entity
---@param squad Squad
---@param assumeEmpty boolean
---@param assumeVisible boolean
---@return unknown
function Entity_CanLoadSquad(entity, squad, assumeEmpty, assumeVisible) end

--- Returns true if the distance between a target entity and the source entity is less than it entity's sight distance.  There is no LOS or FOW check.
--- Try Player_CanSeeEntity() if you care about LOS or FOW.
---@param entity Entity
---@param target Entity
---@return unknown
function Entity_CanSeeEntity(entity, target) end

--- Returns true if the distance between a target squad and the source entity is less than it entity's sight distance.  There is no LOS or FOW check.
--- Try Player_CanSeeSquad() if you care about LOS or FOW.
---@param entity Entity
---@param target Squad
---@return unknown
function Entity_CanSeeSquad(entity, target) end

--- Check if an entity can target and attack another entity.
---@param entity Entity
---@param target Entity
---@param checkFOW boolean
---@return unknown
function Entity_CanTargetEntity(entity, target, checkFOW) end

--- Clear the pending death flag manually. Should be used when campaign leaders are revived.
---@param entity Entity
---@return unknown
function Entity_ClearPendingDeathFlag(entity) end

--- Clears any previous posture suggestions made to an entity
---@param entity Entity
---@return unknown
function Entity_ClearPostureSuggestion(entity) end

--- Clears a TargetHandle value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_ClearStateModelEnumTableTarget(entity, key, tableRowIndex) end

--- Clears a TargetHandle value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_ClearStateModelTarget(entity, key) end

--- Clears the tagged entity used for debugging
---@return unknown
function Entity_ClearTagDebug() end

--- Instantly adds an upgrade to a given entity
---@param pEntity Entity
---@param upgradePBG Upgrade
---@return unknown
function Entity_CompleteUpgrade(pEntity, upgradePBG) end

--- Cycle through the existing list built for the originally tagged entity
---@return unknown
function Entity_CycleDebug() end

--- DeSpawn the entity at its current position
---@param entity Entity
---@return unknown
function Entity_DeSpawn(entity) end

--- Remove an entity from the world and destroy it.
---@param entity Entity
---@return unknown
function Entity_Destroy(entity) end

--- Forces the cancel construction command to be disabled, meaning you can't cancel construction for this
---@param entity Entity
---@param disable boolean
---@return unknown
function Entity_DisableCancelConstructionCommand(entity, disable) end

--- Adjusts the entity's burn level by val
---@param entity Entity
---@param val number
---@param ignoreMaxDamagePerSecond boolean
---@return unknown
function Entity_DoBurnDamage(entity, val, ignoreMaxDamagePerSecond) end

--- Sets whether an entity pays attention to its surroundings
---@param entity Entity
---@param attentive boolean
---@return unknown
function Entity_EnableAttention(entity, attentive) end

--- Sets whether an entity can produce anything (including upgrades)
---@param entity Entity
---@param enable boolean
---@return unknown
function Entity_EnableProductionQueue(entity, enable) end

--- Sets whether an strategic point is active
---@param entity Entity
---@param enable boolean
---@return unknown
function Entity_EnableStrategicPoint(entity, enable) end

--- Returns total entity extension count.
---@return unknown
function Entity_ExtensionCount() end

--- Returns true if the entity has the specific extension enabled.
---@param pEntity Entity
---@param extID ComponentDependencyIndex
---@return unknown
function Entity_ExtensionEnabled(pEntity, extID) end

--- Returns true if the specified extension on the entity will update every frame.
---@param pEntity Entity
---@param extID ComponentDependencyIndex
---@return unknown
function Entity_ExtensionExecuting(pEntity, extID) end

--- Returns a string name of the given extension on the entity.
---@param pEntity Entity
---@param extID ComponentDependencyIndex
---@return unknown
function Entity_ExtensionName(pEntity, extID) end

--- Force constructs this entity but only if its a building
---@param e Entity
---@return unknown
function Entity_ForceConstruct(e) end

--- Force a building to self construct if it's a building
---@param e Entity
---@return unknown
function Entity_ForceSelfConstruct(e) end

--- Get an entity from a mission editor ID.
---@param id number
---@return unknown
function Entity_FromID(id) end

--- Returns the active entity command.
---@param entity Entity
---@return unknown
function Entity_GetActiveCommand(entity) end

--- Find the entity target. If found, the target squad is added to the sgroup. Entity targets like buildings are ignored.
---@param entity Entity
---@param sgroup SGroup
---@return unknown
function Entity_GetAttackTarget(entity, sgroup) end

--- Returns the entity targeted by the given entity.
---@param entity Entity
---@return unknown
function Entity_GetAttackTargetEntity(entity) end

--- Returns the squad targeted by the given entity.
---@param entity Entity
---@return unknown
function Entity_GetAttackTargetSquad(entity) end

--- Returns the entity's blueprint
---@param entity Entity
---@return unknown
function Entity_GetBlueprint(entity) end

--- Returns the construction progress (with range [0.0, 1.0] for a given entity.  Returns 0.0 if the entity is not a building.
---@param pEntity Entity
---@return unknown
function Entity_GetBuildingProgress(pEntity) end

--- Get cover safety value from the where the entity is standing. The safety value is number from -.5 to .5.
--- Higher value means better cover. If the entity doesn't have cover_ext, value of 0 would be returned
---@param entity Entity
---@return unknown
function Entity_GetCoverValue(entity) end

--- Get the currently tagged debug entity
---@return unknown
function Entity_GetDebugEntity() end

--- Returns number of entities that will be placed if this ebp is built in a fence.
---@param ebp PBG
---@param startPos Position
---@param endPos Position
---@return unknown
function Entity_GetFenceEntityCount(ebp, startPos, endPos) end

--- Returns the number of filled slots for squads in a hold in the HoldExtInfo
---@param entity Entity
---@return unknown
function Entity_GetFilledHoldSquadSlots(entity) end

--- Find the last squad attacker on this entity. If found, the squad is added to the sgroup
---@param entity Entity
---@param sgroup SGroup
---@return unknown
function Entity_GetLastAttacker(entity, sgroup) end

--- Find the squad attackers on this entity from the last seconds specified. The sgroup is cleared, then any squads found are added to the sgroup. Building attackers are ignored.
---@param entity Entity
---@param group SGroup
---@param timeSeconds number
---@return unknown
function Entity_GetLastAttackers(entity, group, timeSeconds) end

--- Find the entity attackers on this entity from the last seconds specified. The sgroup is cleared, then any squads found are added to the sgroup. Building attackers are ignored.
---@param entity Entity
---@param group EGroup
---@param timeSeconds number
---@return unknown
function Entity_GetLastEntityAttackers(entity, group, timeSeconds) end

--- Gets the maximum capture crew size from a recrewable entity
---@param entity Entity
---@return unknown
function Entity_GetMaxCaptureCrewSize(entity) end

--- Returns the number of specified slots for squads in a hold in the HoldExtInfo
---@param entity Entity
---@return unknown
function Entity_GetMaxHoldSquadSlots(entity) end

--- Returns the number of blocks the entity will perform per number of attacks
--- For each numAttacks melee attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@return unknown
function Entity_GetMeleeBlocksPerAttacks(entity) end

--- Returns the number of entities connected to an entity via the interaction system.
--- interactionType should match one of the values defined in the `interaction_type` attribute enum
---@param entity Entity
---@param interactionType string
---@return unknown
function Entity_GetNumInteractors(entity, interactionType) end

--- Returns a position relative to an entity's current position and orientation. see ScarUtil.scar for explanation of 'offset' parameter.
---@param entity Entity
---@param offset number
---@param distance number
---@return unknown
function Entity_GetOffsetPosition(entity, offset, distance) end

--- Get the entity health percentage where it can be set on fire
---@param entity Entity
---@return unknown
function Entity_GetOnFireHealthPercentThreshold(entity) end

--- Returns the blueprint for a production queue item with index.
---@param entity Entity
---@param index number
---@return unknown
function Entity_GetProductionQueueItem(entity, index) end

--- Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index.
---@param entity Entity
---@param index number
---@return unknown
function Entity_GetProductionQueueItemType(entity, index) end

--- Returns the number of items in the entities production queue.
--- It is an error to call this function on an entity that does not have a production queue.\n Use Entity_HasProductionQueue to check that the entity has a queue.
---@param entity Entity
---@return unknown
function Entity_GetProductionQueueSize(entity) end

--- Returns the number of blocks the entity will perform per number of attacks
--- For each numAttacks projectile attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@return unknown
function Entity_GetProjectileBlocksPerAttacks(entity) end

--- Returns the number of blocks the entity will perform per number of attacks
--- For each numAttacks ranged attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@return unknown
function Entity_GetRangedBlocksPerAttacks(entity) end

--- Get remaining resource amount of the given entity.
---@param entity Entity
---@return unknown
function Entity_GetRemainingResourceDepositAmount(entity) end

--- Returns the amount of a certain resource that an entity has.
---@param entity Entity
---@param resourceType number
---@return unknown
function Entity_GetResource(entity, resourceType) end

--- Returns the inner sight height for this entity
--- Height will be zero for entities without a sight extension
---@param entity Entity
---@return unknown
function Entity_GetSightInnerHeight(entity) end

--- Returns the inner sight radius for this entity
--- Radius will be zero for entities without a sight extension
---@param entity Entity
---@return unknown
function Entity_GetSightInnerRadius(entity) end

--- Returns the outer sight height for this entity
--- Height will be zero for entities without a sight extension
---@param entity Entity
---@return unknown
function Entity_GetSightOuterHeight(entity) end

--- Returns the outer sight radius for this entity
--- Radius will be zero for entities without a sight extension
---@param entity Entity
---@return unknown
function Entity_GetSightOuterRadius(entity) end

--- Returns the Squad for the passed Entity. (May be nullptr)
---@param pEntity Entity
---@return unknown
function Entity_GetSquad(pEntity) end

--- Adds squads held by an entity to an SGroup
---@param pEntity Entity
---@param sgroup SGroup
---@return unknown
function Entity_GetSquadsHeld(pEntity, sgroup) end

--- Returns a boolean value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelBool(entity, key) end

--- Returns an Entity value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelEntityTarget(entity, key) end

--- Returns a boolean value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableBool(entity, key, tableRowIndex) end

--- Returns an Entity value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableEntityTarget(entity, key, tableRowIndex) end

--- Returns a float value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableFloat(entity, key, tableRowIndex) end

--- Returns an integer value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableInt(entity, key, tableRowIndex) end

--- Returns a Player value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTablePlayerTarget(entity, key, tableRowIndex) end

--- Returns a Squad value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableSquadTarget(entity, key, tableRowIndex) end

--- Returns a Vector3f value from the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@return unknown
function Entity_GetStateModelEnumTableVector3f(entity, key, tableRowIndex) end

--- Returns a float value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelFloat(entity, key) end

--- Returns an integer value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelInt(entity, key) end

--- Returns a Player value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelPlayerTarget(entity, key) end

--- Returns a Squad value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelSquadTarget(entity, key) end

--- Returns a Vector3f value from the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@return unknown
function Entity_GetStateModelVector3f(entity, key) end

--- Returns an Entity value from the entity's StateTree EntityTargetingExt with the given type and key.
---@param entity Entity
---@param type string
---@param key string
---@return unknown
function Entity_GetStateTreeTargeting_EntityTarget(entity, type, key) end

--- Returns an Player value from the entity's StateTree EntityTargetingExt with the given type and key.
---@param entity Entity
---@param type string
---@param key string
---@return unknown
function Entity_GetStateTreeTargeting_PlayerTarget(entity, type, key) end

--- Returns an Squad value from the entity's StateTree EntityTargetingExt with the given type and key.
---@param entity Entity
---@param type string
---@param key string
---@return unknown
function Entity_GetStateTreeTargeting_SquadTarget(entity, type, key) end

--- Returns an Vector3f value from the entity's StateTree EntityTargetingExt with the given type and key.
---@param entity Entity
---@param type string
---@param key string
---@return unknown
function Entity_GetStateTreeTargeting_Vector3f(entity, type, key) end

--- Returns the number of entities or squads currently securing this strategic point
---@param entity Entity
---@return unknown
function Entity_GetStrategicPointSecureCount(entity) end

--- Get the entity's targeting type - auto, manual, or none
---@param entity Entity
---@return unknown
function Entity_GetTargetingType(entity) end

--- Returns a weapon hardpoint  ( 0 indexed )
---@param entity Entity
---@param hardPointIndex number
---@return unknown
function Entity_GetWeaponBlueprint(entity, hardPointIndex) end

--- Returns how many hardpoints an entity has
---@param entity Entity
---@return unknown
function Entity_GetWeaponHardpointCount(entity) end

--- Call HandleAssert on an EntityAssertHandler for each entity
---@return unknown
function Entity_HandleAllAsserts() end

--- Tests to see if an entity has an ability
---@param entity Entity
---@param ability Ability
---@return unknown
function Entity_HasAbility(entity, ability) end

--- Checks whether an entity is of any of the Blueprints or EntityTypes specified.
--- Blueprint can be a single Blueprint, a single EntityType, or a table of multiple Blueprints or EntityTypes. If you want to see if an entity has ALL of a set of EntityTypes, then wrap them all in a sub-table.
---@param entity Entity
---@param blueprints EntityPBG | EntityType | table
---@return unknown
function Entity_HasBlueprint(entity, blueprints) end

--- Returns true if an entity has a production queue.
---@param entity Entity
---@return unknown
function Entity_HasProductionQueue(entity) end

--- Return true if the entity has purchased the specified upgrade.
---@param pEntity Entity
---@param upgradePBG Upgrade
---@return unknown
function Entity_HasUpgrade(pEntity, upgradePBG) end

--- Strategic point will be captured instantly by the team of the supplied player
---@param entity Entity
---@param player Player
---@return unknown
function Entity_InstantCaptureStrategicPoint(entity, player) end

--- instantly converts a building into a fieldsupport
---@param building Entity
---@param owner Player
---@return unknown
function Entity_InstantConvertBuildingToFieldSupport(building, owner) end

--- Reverts an occupied building
---@param entity Entity
---@return unknown
function Entity_InstantRevertOccupiedBuilding(entity) end

--- True if the ability is active
---@param entity Entity
---@param pbg Ability
---@return unknown
function Entity_IsAbilityActive(entity, pbg) end

--- Returns true if entity is alive and spawned
---@param pEntity Entity
---@return unknown
function Entity_IsActive(pEntity) end

--- Returns true if entity is still alive
---@param pEntity Entity
---@return unknown
function Entity_IsAlive(pEntity) end

--- Returns true if the entity is attacking within the time
--- Time is in seconds
---@param entity Entity
---@param time number
---@return unknown
function Entity_IsAttacking(entity, time) end

--- Returns true if the given entity is a building
---@param e Entity
---@return unknown
function Entity_IsBuilding(e) end

--- Returns true if the entity can be set on fire
---@param e Entity
---@return unknown
function Entity_IsBurnable(e) end

--- Returns true if the given entity is burning (buildings on fire or non-buildings with burn_exts)
---@param e Entity
---@return unknown
function Entity_IsBurning(e) end

--- Returns whether the entity is camouflaged.
---@param entity Entity
---@return unknown
function Entity_IsCamouflaged(entity) end

--- Returns true if the entity is a capturable building
---@param entity Entity
---@return unknown
function Entity_IsCapturableBuilding(entity) end

--- Returns true if entity is a casualty else false
---@param entity Entity
---@return unknown
function Entity_IsCasualty(entity) end

--- Returns whether this entity is cuttable
---@param entity Entity
---@return unknown
function Entity_IsCuttable(entity) end

--- Returns whether this entity's demolition charges are ready to be detonated
---@param entity Entity
---@return unknown
function Entity_IsDemolitionReady(entity) end

--- True if entity is currently performing the given ability
---@param entity Entity
---@param pbg Ability
---@return unknown
function Entity_IsDoingAbility(entity, pbg) end

--- Returns true if the given blueprint is a building
---@param ebp Entity
---@return unknown
function Entity_IsEBPBuilding(ebp) end

--- Returns true if the given blueprint is objcover
---@param ebp Entity
---@return unknown
function Entity_IsEBPObjCover(ebp) end

--- Returns true if the given blueprint is of the given type. Types are defined in type_ext/unit_type_list
---@param ebp Entity
---@param type string
---@return unknown
function Entity_IsEBPOfType(ebp, type) end

--- Returns whether a hardpoint is active ( 0 indexed )
---@param entity Entity
---@param hardPointIndex number
---@return unknown
function Entity_IsHardpointActive(entity, hardPointIndex) end

--- Check if the entity has a hold on anything
---@param entity Entity
---@return unknown
function Entity_IsHoldingAny(entity) end

--- Returns whether or not the entity is in the background.
---@param pEntity Entity
---@return unknown
function Entity_IsInBackground(pEntity) end

--- Returns true if entity is in cover.
---@param entityId Entity
---@return unknown
function Entity_IsInCover(entityId) end

--- Returns whether an entity is an infantry unit
---@param pEntity Entity
---@return unknown
function Entity_IsInfantry(pEntity) end

--- Checks if an entity is in a hold
---@param entity Entity
---@return unknown
function Entity_IsInHold(entity) end

--- get if an entity is invulnerable
---@param entity Entity
---@return unknown
function Entity_IsInvulnerable(entity) end

--- Returns whether an entity is moving.
---@param pEntity Entity
---@return unknown
function Entity_IsMoving(pEntity) end

--- Determines if this entity is of the given type. Types are defined in type_ext/unit_type_list
---@param entity Entity
---@param type string
---@return unknown
function Entity_IsOfType(entity, type) end

--- Returns if an Entity is currently on walkable wall.
---@param entity Entity
---@return unknown
function Entity_IsOnWalkableWall(entity) end

--- Returns true if the entity is part of a squad
---@param pEntity Entity
---@return unknown
function Entity_IsPartOfSquad(pEntity) end

--- Returns whether an entity is a plane (has a flight extension)
---@param pEntity Entity
---@return unknown
function Entity_IsPlane(pEntity) end

--- Returns whether an entity is a planned structure.
---@param entity Entity
---@return unknown
function Entity_IsPlannedStructure(entity) end

--- Returns whether a particular squad blueprint is being produced by a given entity
---@param entity Entity
---@param pbg Squad
---@return unknown
function Entity_IsProducingSquad(entity, pbg) end

--- Returns true if an entity has a production queue and if the queue is available
---@param entity Entity
---@return unknown
function Entity_IsProductionQueueAvailable(entity) end

--- Returns true if the entity is a resource generator and has resources remaining
---@param entity Entity
---@return unknown
function Entity_IsResourceGenerator(entity) end

--- Return true if the entity is a slot item
---@param entity Entity
---@return unknown
function Entity_IsSlotItem(entity) end

--- if entity is spawned return true
---@param entity Entity
---@return unknown
function Entity_IsSpawned(entity) end

--- Returns true if the entity is a starting position
---@param entity Entity
---@return unknown
function Entity_IsStartingPosition(entity) end

--- Returns true if the entity is a strategic point.
---@param pEntity Entity
---@return unknown
function Entity_IsStrategicPoint(pEntity) end

--- Returns true if strategic point is captured by the team of the player provided.
---@param entity Entity
---@param player Player
---@return unknown
function Entity_IsStrategicPointCapturedBy(entity, player) end

--- Return true if the entity is a team weapon
---@param entity Entity
---@return unknown
function Entity_IsSyncWeapon(entity) end

--- Returns true if the entity is under attack.
---@param entity Entity
---@param time number
---@return unknown
function Entity_IsUnderAttack(entity, time) end

--- Returns true if the entity is under attack by a certain player
---@param entity Entity
---@param pAttackerOwner Player
---@param time number
---@return unknown
function Entity_IsUnderAttackByPlayer(entity, pAttackerOwner, time) end

--- Returns true if the entity was under attack from a certain direction (8 offset types, see ScarUtil.scar)
---@param entity Entity
---@param offset number
---@param timeSeconds number
---@return unknown
function Entity_IsUnderAttackFromDirection(entity, offset, timeSeconds) end

--- Returns true if the entity is under construction.
---@param entity Entity
---@return unknown
function Entity_IsUnderConstruction(entity) end

--- Returns true if the entity is being repaired.
---@param entity Entity
---@return unknown
function Entity_IsUnderRepair(entity) end

--- Check if an entity with the given ID can be found in the world
---@param id number
---@return unknown
function Entity_IsValid(id) end

--- Returns whether an entity can be vaulted
---@param pEntity Entity
---@return unknown
function Entity_IsVaultable(pEntity) end

--- Returns whether an entity is a vehicle
---@param pEntity Entity
---@return unknown
function Entity_IsVehicle(pEntity) end

--- Returns true if entityID is a victory point
---@param pEntity Entity
---@return unknown
function Entity_IsVictoryPoint(pEntity) end

--- Kill the entity.  Sets health to 0, and triggers death effects.
---@param entity Entity
---@return unknown
function Entity_Kill(entity) end

--- Calls a function when an entity gets destroyed by the player clicking the "Detonate me" button next to an entity.
---@param entity Entity
---@param _function function
---@return unknown
function Entity_NotifyOnPlayerDemolition(entity, _function) end

--- get entity pop cost, use CT_Personnel, CT_Vehicle, CT_Medic for captype
---@param entity Entity
---@param type CapType
---@return unknown
function Entity_Population(entity, type) end

--- trigger the RagDoll skeleton driving.
---@param entity Entity
---@return unknown
function Entity_RagDoll(entity) end

--- Removes an ability that was previously added by Entity_AddAbility. You cannot remove static abilities (from AE: ability_ext)
---@param entity Entity
---@param ability Ability
---@return unknown
function Entity_RemoveAbility(entity, ability) end

--- Removes all booby-traps on this entity
---@param pEntityTarget Entity
---@return unknown
function Entity_RemoveBoobyTraps(pEntityTarget) end

--- Removes all demolition charges on an entity
---@param entity Entity
---@return unknown
function Entity_RemoveDemolitions(entity) end

--- Removes an upgrade from an entity
---@param entity Entity
---@param upgrade Upgrade
---@return unknown
function Entity_RemoveUpgrade(entity, upgrade) end

--- Returns true if you should call Misc_UpdateSlottedSplinesContainingEGroupAfterBlueprintConversion with an egroup containing this entity after blueprint converting it. Make sure to batch together all your entities when using that function to reduce duplicated work.
---@param entity Entity
---@return unknown
function Entity_RequiresSlottedSplineUpdateAfterBlueprintConversion(entity) end

--- Reset melee block rate to AE tuned values
---@param entity Entity
---@return unknown
function Entity_ResetMeleeBlocksPerAttacks(entity) end

--- Reset Projectile block rate to AE tuned values
---@param entity Entity
---@return unknown
function Entity_ResetProjectileBlocksPerAttacks(entity) end

--- Reset ranged block rate to AE tuned values
---@param entity Entity
---@return unknown
function Entity_ResetRangedBlocksPerAttacks(entity) end

--- Restore the targeting type to the default found in the ebp
---@param entity Entity
---@return unknown
function Entity_RestoreTargetingType(entity) end

--- Trigger animation action for an entity. Please only use this for simple animations
---@param pEntity Entity
---@param actionName string
---@return unknown
function Entity_SetAnimatorAction(pEntity, actionName) end

--- Set animation action parameter for an entity. Please only use this for simple animations
---@param pEntity Entity
---@param actionParameterName string
---@param actionParameterValue string
---@return unknown
function Entity_SetAnimatorActionParameter(pEntity, actionParameterName, actionParameterValue) end

--- Sets the entity to be in the background or foreground. By default, all entities are in the foreground
---@param pEntity Entity
---@param isInBackground boolean
---@return unknown
function Entity_SetBackground(pEntity, isInBackground) end

--- Enables or disables the BurnExt extensions for squads / entities
---@param unit EGroup
---@param enabled boolean
---@return unknown
function Entity_SetBurnExtEnabled(unit, enabled) end

--- Overrides crushable behavior for an entity
---@param entity Entity
---@param crushable boolean
---@return unknown
function Entity_SetCrushable(entity, crushable) end

--- Changes the crush mode of a given entity.  Entity must have a crush extension.
---@param entity Entity
---@param mode CrushMode
---@return unknown
function Entity_SetCrushMode(entity, mode) end

--- Fully wires this entity for demolitions, if it's set up to be demolishable. 'player' is the one that owns the demolitions and can detonate them.
---@param player Player
---@param entity Entity
---@param numcharges number
---@return unknown
function Entity_SetDemolitions(player, entity, numcharges) end

--- enable or disable the casualtext
---@param enable boolean
---@param entity Entity
---@return unknown
function Entity_SetEnableCasualty(enable, entity) end

--- Enables/disables an extension on the entity.
---@param entity Entity
---@param extID string
---@param enabled boolean
---@return unknown
function Entity_SetExtEnabled(entity, extID, enabled) end

--- Sets the heading of the entity.  The position is currently a lua table with three entries (x, y, z)
---@param entity Entity
---@param pos Position
---@param bInterpolate boolean
---@return unknown
function Entity_SetHeading(entity, pos, bInterpolate) end

--- Sets the heading of the entity.  The position is currently a lua table with three entries (x, y, z)
---@param entity Entity
---@param pos Position
---@param bSnapToGround boolean
---@param bInterpolate boolean
---@return unknown
function Entity_SetHeadingGroundSnapOptional(entity, pos, bSnapToGround, bInterpolate) end

--- Set the health of an entity.  healthPercent must be in the range [0.0, 1.0].
---@param entity Entity
---@param healthPercent number
---@return unknown
function Entity_SetHealth(entity, healthPercent) end

--- Set invulnerability on the entity. Reset time is in seconds. If it it set, the invulnerability will expire after this time.
---@param entity Entity
---@param enable boolean
---@param reset_time number
---@return unknown
function Entity_SetInvulnerable(entity, enable, reset_time) end

--- Make an entity invulnerable to physical damage when health is below the minimum health percentage
--- percentage of 0.0 means entity is vulnerable; percentage of 1.0 sets the entity in god mode resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever
---@param entity Entity
---@param minHealthPercentage number
---@param resetTime number
---@return unknown
function Entity_SetInvulnerableMinCap(entity, minHealthPercentage, resetTime) end

--- Sets the lockCurrentTierVisuals flag in the TierExt so when an entity gets BP converted it doesn't update the visual assets. Must be called before BP conversion
---@param entity Entity
---@param lockVisuals boolean
---@return unknown
function Entity_SetLockCurrentTierVisuals(entity, lockVisuals) end

--- Set the number of blocks the entity will perform per number of attacks
--- For each numAttacks melee attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@param blocks number
---@param attacks number
---@return unknown
function Entity_SetMeleeBlocksPerAttacks(entity, blocks, attacks) end

--- Sets an object on fire (also works on buildings)
---@param entity Entity
---@return unknown
function Entity_SetOnFire(entity) end

--- Changes the owner of the given squad.
--- This function doesn't work with strategic/capturable point
---@param entity Entity
---@param owner Player
---@return unknown
function Entity_SetPlayerOwner(entity, owner) end

--- Sets the position of the entity.  The position is currently a lua table with three entries (x, y, z)
---@param entity Entity
---@param pos Position
---@return unknown
function Entity_SetPosition(entity, pos) end

--- If the entity is at the same cell as desiredPosition, try to set the entity position to it. If the cell is next to impass, set it to the center of the cell.
---@param entity Entity
---@param desiredPosition Position
---@return unknown
function Entity_SetPositionWithinCell(entity, desiredPosition) end

--- Set the number of blocks the entity will perform per number of attacks
--- For each numAttacks projectile attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@param blocks number
---@param attacks number
---@return unknown
function Entity_SetProjectileBlocksPerAttacks(entity, blocks, attacks) end

--- Sets whether or not a projectile can explode.
---@param projectile Entity
---@param canExplode boolean
---@return unknown
function Entity_SetProjectileCanExplode(projectile, canExplode) end

--- Set the number of blocks the entity will perform per number of attacks
--- For each numAttacks ranged attacks the entity receives, it will block a random numBlocks of them. Block rate is numBlocks / numAttacks
---@param entity Entity
---@param blocks number
---@param attacks number
---@return unknown
function Entity_SetRangedBlocksPerAttacks(entity, blocks, attacks) end

--- Sets an entity to be recrewable or not when it becomes abandoned
---@param entity Entity
---@param capturable boolean
---@return unknown
function Entity_SetRecrewable(entity, capturable) end

--- Set remaining resource amount of the given entity.
---@param entity Entity
---@param amount number
---@return unknown
function Entity_SetRemainingResourceDepositAmount(entity, amount) end

--- Sets a specific amount of a certain resource type for an entity.
---@param entity Entity
---@param type number
---@param amount number
---@return unknown
function Entity_SetResource(entity, type, amount) end

--- Enables shared team production on a building (teammates can build using THEIR resources)
---@param entity Entity
---@param shared boolean
---@return unknown
function Entity_SetSharedProductionQueue(entity, shared) end

--- Show or hide the entity's silhouette when behind other objects
---@param entity Entity
---@param show boolean
---@return unknown
function Entity_SetShowSilhouette(entity, show) end

--- Sets a boolean value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value boolean
---@return unknown
function Entity_SetStateModelBool(entity, key, value) end

--- Sets an Entity TargetHandle value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value Entity
---@return unknown
function Entity_SetStateModelEntityTarget(entity, key, value) end

--- Sets a boolean value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value boolean
---@return unknown
function Entity_SetStateModelEnumTableBool(entity, key, tableRowIndex, value) end

--- Sets an Entity TargetHandle value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value Entity
---@return unknown
function Entity_SetStateModelEnumTableEntityTarget(entity, key, tableRowIndex, value) end

--- Sets a float value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Entity_SetStateModelEnumTableFloat(entity, key, tableRowIndex, value) end

--- Sets an integer value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Entity_SetStateModelEnumTableInt(entity, key, tableRowIndex, value) end

--- Sets a Player TargetHandle value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value Player
---@return unknown
function Entity_SetStateModelEnumTablePlayerTarget(entity, key, tableRowIndex, value) end

--- Sets a Squad TargetHandle value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value Squad
---@return unknown
function Entity_SetStateModelEnumTableSquadTarget(entity, key, tableRowIndex, value) end

--- Sets a Vector3f value in the entity's state model corresponding to the given key and table row index (0 based).
---@param entity Entity
---@param key string
---@param tableRowIndex number
---@param value Position
---@return unknown
function Entity_SetStateModelEnumTableVector3f(entity, key, tableRowIndex, value) end

--- Sets a float value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value number
---@return unknown
function Entity_SetStateModelFloat(entity, key, value) end

--- Sets an integer value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value number
---@return unknown
function Entity_SetStateModelInt(entity, key, value) end

--- Sets a Player TargetHandle value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value Player
---@return unknown
function Entity_SetStateModelPlayerTarget(entity, key, value) end

--- Sets a Squad TargetHandle value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value Squad
---@return unknown
function Entity_SetStateModelSquadTarget(entity, key, value) end

--- Sets a Vector3f value in the entity's state model corresponding to the given key.
---@param entity Entity
---@param key string
---@param value Position
---@return unknown
function Entity_SetStateModelVector3f(entity, key, value) end

--- Sets a flag that tells a building to keep burning while invulnerable (for atmosphere).
---@param entity Entity
---@param shouldStayBurning boolean
---@return unknown
function Entity_SetStayBurningWhileInvulnerable(entity, shouldStayBurning) end

--- Sets a strategic point to neutral (not owned by any team)
---@param entity Entity
---@return unknown
function Entity_SetStrategicPointNeutral(entity) end

--- Sets whether a strategic point's reticule is visible
---@param entity Entity
---@param visible boolean
---@return unknown
function Entity_SetStrategicPointReticuleVisible(entity, visible) end

--- Set the allowable methods of targeting this entity
--- Targeting_Automatic: allow auto and manual targeting Targeting_Manual: only allow manual targeting Targeting_None: do not allow targeting
---@param entity Entity
---@param type TargetingType
---@return unknown
function Entity_SetTargetingType(entity, type) end

--- Makes an entity neutral
---@param entity Entity
---@return unknown
function Entity_SetWorldOwned(entity) end

--- Shows/hides the entity in the simulation
---@param entity Entity
---@param hide boolean
---@return unknown
function Entity_SimHide(entity, hide) end

--- Snaps the entity to the grid and ground.
---@param entity Entity
---@param interpolate boolean
---@return unknown
function Entity_SnapToGridAndGround(entity, interpolate) end

--- Spawn the entity at its current position
---@param entity Entity
---@return unknown
function Entity_Spawn(entity) end

--- Spawn the entity at its current position without pathfinding and collision
---@param entity Entity
---@return unknown
function Entity_SpawnDoNotAddPathfindingAndCollision(entity) end

--- Spawn the entity at a given position
---@param entity Entity
---@param pos Position
---@param toward Position
---@param spawnType string
---@return unknown
function Entity_SpawnToward(entity, pos, toward, spawnType) end

--- Abruptly stops an active ability
---@param entity Entity
---@param ability Ability
---@param bIsEarlyExit boolean
---@return unknown
function Entity_StopAbility(entity, ability, bIsEarlyExit) end

--- Puts out the fire on an object (also works on buildings)
---@param entity Entity
---@return unknown
function Entity_StopFire(entity) end

--- Suggests a posture to an entity, lasting the passed duration
--- Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing.  Duration is in seconds, negative means indefinite.
---@param entity Entity
---@param posture number
---@param duration number
---@return unknown
function Entity_SuggestPosture(entity, posture, duration) end

--- Returns whether this entity is set up to have demolitions placed on it
---@param entity Entity
---@return unknown
function Entity_SupportsDemolition(entity) end

--- Tags the entity to be used for debugging
---@param entity Entity
---@return unknown
function Entity_TagDebug(entity) end

--- Hides or shows an entity visually.
---@param pEntity Entity
---@param bHide boolean
---@return unknown
function Entity_VisHide(pEntity, bHide) end

--- Warps an entity immediately to a new position
---@param entity Entity
---@param pos Position
---@return unknown
function Entity_WarpToPos(entity, pos) end

--- Checks if the given position has an associated district.
---@param pos Position
---@return unknown
function Misc_DoesPositionHaveAssociatedDistrict(pos) end

--- Do weapon hit effect on the ground
--- WeaponID is the property bag group id; if penetrated is set to false, deflection effect would be played instead
---@param pos Position
---@param weaponPBG ScarWeaponPBG
---@param penetrated boolean
---@return unknown
function Misc_DoWeaponHitEffectOnPosition(pos, weaponPBG, penetrated) end

--- Find deposits within the specified range of a squad
---@param group EGroup
---@param squad Squad
---@param searchRange number
---@return unknown
function Misc_FindDepositsCloseToSquad(group, squad, searchRange) end

--- Finds resource deposits of given type within the specified range of a position, that can be collected by the provided gathererEBP
--- Returns an egroup of resource deposits named "eg_Misc_FindNearbyDepositOfType_result", sorted by proximity to the position
---@param resourceType ResourceType
---@param gathererEBP EntityPBG
---@param position Position
---@param searchRange number
---@return unknown
function Misc_FindDepositsOfTypeCloseToPosition(resourceType, gathererEBP, position, searchRange) end

--- Return the entity generating the district containing the given position. Use with Misc_DoesPositionHaveAssociatedDistrict
---@param pos Position
---@return unknown
function Misc_GetDistrictGeneratorFromPosition(pos) end

--- Return the district value of the district containing the given position. Use with Misc_DoesPositionHaveAssociatedDistrict
---@param pos Position
---@return unknown
function Misc_GetDistrictValueFromPosition(pos) end

--- Updates the slotted spline system to handle the fact that the entities in the given EGroup have done a blueprint conversion. This must be called after converting slotted spline entities from script.
---@param egroup EGroup
---@return unknown
function Misc_UpdateSlottedSplinesContainingEGroupAfterBlueprintConversion(egroup) end

--- Creates a Callback Event that triggers when ALL of the specified events are triggered.
---@param callback function
---@param data table
---@param events table
---@param delay number
---@return unknown
function Event_CreateAND(callback, data, events, delay) end

--- Callback given callback function with data, when the certain objects die.
---@param callback function
---@param group EGroup
---@param selection ALL_UNITS | ANY_MEMBER | ANY_SQUAD
---@param _repeat boolean
---@param requireAllEntitiesDead boolean
---@param data table
---@return unknown
function Event_Death(callback, group, selection, _repeat, requireAllEntitiesDead, data) end

--- Callback given callback function with data, when any squad in the encounter can see any squad owned by the player
---@param callback function
---@param data table
---@param encounter SGroup
---@param player Player
---@param delay number
---@return unknown
function Event_EncounterCanSeePlayerSquads(callback, data, encounter, player, delay) end

--- Callback given callback function with data when target enters range
---@param callback function
---@param data table
---@param target ConstTargetHandle
---@param arequireAll boolean
---@param location Marker
---@param range number
---@param _repeat boolean
---@param triggerOnEnter boolean
---@return unknown
function Event_EnterProximity(callback, data, target, arequireAll, location, range, _repeat, triggerOnEnter) end

--- Callback given callback function with data when target exits range
---@param callback function
---@param data table
---@param target ConstTargetHandle
---@param arequireAll boolean
---@param location Marker
---@param range number
---@param _repeat boolean
---@param triggerOnEnter boolean
---@return unknown
function Event_ExitProximity(callback, data, target, arequireAll, location, range, _repeat, triggerOnEnter) end

--- Callback given callback function with data, when the amount of objects matches the requested conditions - Note: Does not count team weapons
---@param callback function
---@param data table
---@param __SGroup_group EGroup
---@param amount__value_to_be_compared_against_ number
---@param _repeat boolean
---@return unknown
function Event_GroupCount(callback, data, __SGroup_group, amount__value_to_be_compared_against_, _repeat) end

--- Callback given callback function with data, when group is dead(empty).
---@param callback function
---@param data table
---@param __SGroup_group EGroup
---@param delay number
---@return unknown
function Event_GroupIsDeadOrRetreating(callback, data, __SGroup_group, delay) end

--- Callback given callback function with data, when the amount of entities left in a group drops below amount.
---@param callback function
---@param data table
---@param __SGroup_group EGroup
---@param amount number
---@param delay number
---@return unknown
function Event_GroupLeftAlive(callback, data, __SGroup_group, amount, delay) end

--- Callback given callback function with data, when group is doing an attack or is under attack in the last attackTime seconds.
---@param callback function
---@param data table
---@param attackTime number
---@param delay number
---@return unknown
function Event_IsEngaged(callback, data, attackTime, delay) end

--- Callback given callback function with data, when group is out of combat  in the last attackTime seconds.
---@param callback function
---@param data table
---@param __SGroup_group EGroup
---@param attackTime number
---@param delay number
---@return unknown
function Event_IsOutOfCombat(callback, data, __SGroup_group, attackTime, delay) end

--- Callback when a target element is selected.
---@param callback function
---@param data table
---@return unknown
function Event_IsSelected(callback, data) end

--- Callback given callback function with data, when sgroup or egroup are under attack in the last attackTime seconds.
---@param callback function
---@param data table
---@param __SGroup SGroup
---@param __EGroup EGroup
---@param attackTime number
---@param player Player
---@param delay number
---@return unknown
function Event_IsUnderAttack(callback, data, __SGroup, __EGroup, attackTime, player, delay) end

--- Callback given callback function with data, when the given player can see the element.
---@param callback function
---@param data table
---@param team Player
---@param element SGroup
---@return unknown
function Event_PlayerCanSeeElement(callback, data, team, element) end

--- Callback given callback function with data when target enters location.
---@param callback function
---@param data table
---@param target ConstTargetHandle
---@param location Marker
---@param range number
---@param delay number
---@return unknown
function Event_Proximity(callback, data, target, location, range, delay) end

--- Callback given callback function with data, when the amount of members left in a squad matches the requested conditions
---@param callback function
---@param data table
---@param group SGroup
---@param amount__value_to_be_compared_against_ number
---@param _repeat boolean
---@return unknown
function Event_SGroupCountMember(callback, data, group, amount__value_to_be_compared_against_, _repeat) end

--- Callback given callback function with data when target remains in range (called every interval seconds)
---@param callback function
---@param data table
---@param target ConstTargetHandle
---@param arequireAll boolean
---@param location Marker
---@param range number
---@param _repeat boolean
---@param triggerOnEnter boolean
---@return unknown
function Event_WhileInProximity(callback, data, target, arequireAll, location, range, _repeat, triggerOnEnter) end

--- Explores entire map for all players. (Careful where this is used. For example, if used before the first tick, a statetree may change an entity's visual on the first tick, so the ghost's visual will not reflect the entity's.)
---@return unknown
function FOW_ExploreAll() end

--- Reveal FOW except blockers for all players. Does not create ghosts and ghosts will not be present if undone.
---@return unknown
function FOW_ForceRevealAllUnblockedAreas() end

--- Explores entire map for one player. (Careful where this is used. For example, if used before the first tick, a statetree may change an entity's visual on the first tick, so the ghost's visual will not reflect the entity's.)
---@param player Player
---@return unknown
function FOW_PlayerExploreAll(player) end

--- Reveal FOW for specified player
---@param player Player
---@return unknown
function FOW_PlayerRevealAll(player) end

--- Reveals a circular area for the given player over a given duration.
--- Pass in a duration of -1 for indefinite duration ( or until unreveal is called on the same position )
---@param player Player
---@param pos Position
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_PlayerRevealArea(player, pos, radius, durationSecs) end

--- Reveals a SGroup in the Fog of War for a player over a given duration.
--- Pass in a duration of -1 for indefinite duration ( until the squads are dead or UnReveal is called )
---@param player Player
---@param group SGroup
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_PlayerRevealSGroup(player, group, radius, durationSecs) end

--- Unexplores entire map for one player.
---@param player Player
---@return unknown
function FOW_PlayerUnExploreAll(player) end

--- Use to undo a FOW_RevealAll for specified player
---@param player Player
---@return unknown
function FOW_PlayerUnRevealAll(player) end

--- UnReveals a circular area that was previously revealed for a given player.
---@param player Player
---@param pos Position
---@return unknown
function FOW_PlayerUnRevealArea(player, pos) end

--- UnReveal a SGroup previously revealed to a Player
---@param player Player
---@param group SGroup
---@return unknown
function FOW_PlayerUnRevealSGroup(player, group) end

--- Reveal FOW for all players
---@return unknown
function FOW_RevealAll() end

--- Reveals a circular area for all alive players over a given duration.
--- Pass in a duration of -1 for indefinite duration ( or until unreveal is called at the same position )
---@param pos Position
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_RevealArea(pos, radius, durationSecs) end

--- Reveals an EGroup in the Fog of War for all alive players over a given duration.
--- Pass in a duration of -1 for indefinite duration ( until the entities are dead or UnReveal is called )
---@param group EGroup
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_RevealEGroup(group, radius, durationSecs) end

--- Reveals an entity group in the FOW for alive players for a duration.
--- Pass in a duration of -1 for an indefinite duration.
---@param group EGroup
---@param durationSeconds number
---@return unknown
function FOW_RevealEGroupOnly(group, durationSeconds) end

--- Reveals an entity in the Fog of War for all alive players over a given duration.
--- Pass in a duration of -1 for indefinite duration ( until the entity is dead or UnReveal is called with the same entity )
---@param entity Entity
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_RevealEntity(entity, radius, durationSecs) end

--- Reveals an area the size of a given markers proximity at that markers position for a given amount of time. Pass in a duration of -1 for indefinite duration. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.
--- This function will reveal the FOW for ALL alive players. This does not work with markers with rectangular proximity type
---@param marker Marker
---@param duration number
---@return unknown
function FOW_RevealMarker(marker, duration) end

--- Reveals a SGroup in the Fog of War for all alive players over a given duration.
--- Pass in a duration of -1 for indefinite duration ( until the squads are dead or UnReveal is called )
---@param group SGroup
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_RevealSGroup(group, radius, durationSecs) end

--- Reveals a squad group in the FOW for alive players for a duration.
--- Pass in a duration of -1 for an indefinite duration.
---@param group SGroup
---@param durationSeconds number
---@return unknown
function FOW_RevealSGroupOnly(group, durationSeconds) end

--- Reveals a squad in the Fog of War for all alive players over a given duration.
--- Pass in a duration of -1 for indefinite duration ( until the squad is dead or UnReveal is called with the same squad )
---@param squad Squad
---@param radius number
---@param durationSecs number
---@return unknown
function FOW_RevealSquad(squad, radius, durationSecs) end

--- Reveals a territory to a player
---@param player Player
---@param sectorID number
---@param durationSecs number
---@param mustOwn boolean
---@return unknown
function FOW_RevealTerritory(player, sectorID, durationSecs, mustOwn) end

--- Reveal FOW for all players by disabling rendering of FOW without triggering a FOW in the game simulation
---@return unknown
function FOW_UIRevealAll() end

--- Use to transition from game to RevealAll
---@param duration number
---@return unknown
function FOW_UIRevealAll_Transition(duration) end

--- Use to reveal all Entities in FoW
---@return unknown
function FOW_UIRevealAllEntities() end

--- Use to undo a FOW_UIRevealAll
---@return unknown
function FOW_UIUnRevealAll() end

--- Use to transition into game
---@param duration number
---@return unknown
function FOW_UIUnRevealAll_Transition(duration) end

--- Use to unreveal all Entities in FoW
---@return unknown
function FOW_UIUnRevealAllEntities() end

--- Use to undo a FOW_ForceRevealAllUnblockedAreas.
---@return unknown
function FOW_UndoForceRevealAllUnblockedAreas() end

--- Unexplores entire map for all players
---@return unknown
function FOW_UnExploreAll() end

--- Use to undo a FOW_RevealAll
---@return unknown
function FOW_UnRevealAll() end

--- UnReveals a circular area that was previously revealed for all alive players.
---@param pos Position
---@return unknown
function FOW_UnRevealArea(pos) end

--- Unreveals an area the size of a given markers proximity at that markers position. YOU SHOULD ONLY CALL THIS ONCE FOR EACH AREA.
--- This does not work with markers with rectangular proximity type
---@param marker Marker
---@return unknown
function FOW_UnRevealMarker(marker) end

--- Unreveals a territory sector
---@param player Player
---@param sectorID number
---@return unknown
function FOW_UnRevealTerritory(player, sectorID) end

--- Returns a table of egroups NOT in the world builder
--- See Marker_GetTable for more info on format parameter
---@param format string
---@param size number
---@return unknown
function EGroup_CreateTable(format, size) end

--- Returns a table of egroups from the world builder
--- See Marker_GetTable for more info on format parameter
---@param format string
---@return unknown
function EGroup_GetWBTable(format) end

--- Returns a fixed size table of markers from the world builder.  Markers that do not exist in the WB, will be nil in the table.  This is why we call it 'non-sequential'
---@param format string
---@param size number
---@return unknown
function Marker_GetNonSequentialTable(format, size) end

--- Returns a table of markers from the world builder. Creates as many as it finds
--- mkr_table = Marker_GetTable( 'mkr_%d' ) -- creates a table with 3 markers named 'mkr_1', 'mkr_2', and 'mkr_3' (and so on) from the WB\n\n mkr_table2 = Marker_GetTable( 'mkr_%02d' )  -- creates a table with 3 markers named 'mkr_01', 'mkr_02', 'mkr_03' (and so on) from the WB\n\n mkr_table3 = Marker_GetTable( 'mkr_%03d_patrol' )  -- creates a table with 3 markers named 'mkr_001_patrol', 'mkr_002_patrol' (and so on) from the WB\n\n
---@param format string
---@return unknown
function Marker_GetTable(format) end

--- Returns a table of sgroups NOT in the world builder
--- See Marker_GetTable for more info on format parameter
---@param format string
---@param size number
---@return unknown
function SGroup_CreateTable(format, size) end

--- Returns a table of sgroups from the world builder
--- See Marker_GetTable for more info on format parameter
---@param format string
---@return unknown
function SGroup_GetWBTable(format) end

--- Returns all ScarMarkers from the Mission Editor with the given name. If you don't care about the type, pass in an empty string ( "" )
--- The type is defined in the markers list of the mission editor when placing markers.\n
---@param name string
---@param type string
---@return unknown
function AllMarkersFromName(name, type) end

--- Builds a table of MarkerIDs that are named in a sequence. i.e. a name of "spot" will find markers "spot1", "spot2" and so on, up until it looks for a marker that isn't there.
---@param name string
---@param type string
---@return unknown
function Marker_GetSequence(name, type) end

--- Returns the number of ScarMarkers with the given name If you don't care about the type, pass in an empty string ( "" )
--- The type is defined in the markers list of the mission editor when placing markers.
---@param name string
---@param type string
---@return unknown
function MarkerCountFromName(name, type) end

--- Checks if a modifier is enabled on all or any entities in an egroup
---@param egroup EGroup
---@param modifier string
---@param modtype string
---@param all boolean
---@param bEnabledByDefault boolean
---@return unknown
function Modifier_IsEnabledOnEGroup(egroup, modifier, modtype, all, bEnabledByDefault) end

--- Removes all SCAR-applied modifiers for a specific EGroup.
---@param egroup EGroup
---@return unknown
function Modifier_RemoveAllFromEGroup(egroup) end

--- Removes all SCAR-applied modifiers for a specific SGroup.
---@param sgroup SGroup
---@return unknown
function Modifier_RemoveAllFromSGroup(sgroup) end

--- Modifies the cast time of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_AbilityCastTime(player, ability, scalefactor, mathtype) end

--- Modifies the channeling time of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_AbilityChannelingTime(player, ability, scalefactor, mathtype) end

--- Modifies the initial delay time of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@return unknown
function Modify_AbilityDelayTime(player, ability, scalefactor) end

--- Modifies the duration of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@return unknown
function Modify_AbilityDurationTime(player, ability, scalefactor) end

--- Modifies the manpower cost of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_AbilityManpowerCost(player, ability, scalefactor, mathtype) end

--- Modifies the maximum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range
---@param player Player
---@param ability Ability
---@param scalefactor number
---@return unknown
function Modify_AbilityMaxCastRange(player, ability, scalefactor) end

--- Modifies the minimum casting range of an ability. NOTE: it assumes that the actions that the ability executes can also handle the modified range
---@param player Player
---@param ability Ability
---@param scalefactor number
---@return unknown
function Modify_AbilityMinCastRange(player, ability, scalefactor) end

--- Modifies the munitions cost of an ability
---@param player Player
---@param ability Ability
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_AbilityMunitionsCost(player, ability, scalefactor, mathtype) end

--- Modifies a squad or entity's armor
---@param group EGroup
---@param scalefactor number
---@param exclusive boolean | nil
---@return unknown
function Modify_Armor(group, scalefactor, exclusive) end

--- Modifies the capture time of all strategic points in an EGroup.
---@param egroup EGroup
---@param scalefactor number
---@return unknown
function Modify_CaptureTime(egroup, scalefactor) end

--- Modifies the capture time of all cover objects in an EGroup.  Higher = less time to capture.
---@param egroup EGroup
---@param scalefactor number
---@return unknown
function Modify_CoverCaptureTime(egroup, scalefactor) end

--- Enable or disable hold (garrisoning) for an egroup or sgroup
---@param group EGroup
---@param disable boolean
---@return unknown
function Modify_DisableHold(group, disable) end

--- Enable or disable camoflage for an egroup or sgroup
---@param group EGroup
---@param disable boolean
---@return unknown
function Modify_EnableCamoflage(group, disable) end

--- Modifies an entity's construction time
--- Should only be used on entities, NOT squads
---@param group EGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@return unknown
function Modify_EntityConstructionTime(group, Factor, Usage__MUT_Multiplication) end

--- Modifies the cost of an entity for a particular player.
---@param player Player
---@param blueprint string
---@param resourcetype number
---@param addition number
---@return unknown
function Modify_EntityCost(player, blueprint, resourcetype, addition) end

--- Modifies an entity's health regen
--- Should only be used on entities, NOT squads
---@param group EGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@return unknown
function Modify_EntityHealthRegen(group, Factor, Usage__MUT_Multiplication) end

--- Modifies an entity's max health
--- Should only be used on entities, NOT squads
---@param group EGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@return unknown
function Modify_EntityMaxHealth(group, Factor, Usage__MUT_Multiplication) end

--- Modifies an entity's selection name
--- Should only be used on entities, NOT squads
---@param group EGroup
---@param value number
---@param Usage__MUT_Set_ MUT
---@return unknown
function Modify_EntitySelectionName(group, value, Usage__MUT_Set_) end

--- Modifies the veterancy experience received by a player
---@param player Player
---@param factor number
---@return unknown
function Modify_PlayerExperienceReceived(player, factor) end

--- Modifies the production rate of a player.
---@param sgroup Player
---@param scalefactor number
---@return unknown
function Modify_PlayerProductionRate(sgroup, scalefactor) end

--- Modifies a player's resource cap. Possible math types are MUT_Multiplication, MUT_Addition.
---@param playerId Player
---@param resourceType number
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_PlayerResourceCap(playerId, resourceType, scalefactor, mathtype) end

--- Modifies the sight radius for a player.
---@param player Player
---@param scalefactor number
---@return unknown
function Modify_PlayerSightRadius(player, scalefactor) end

--- Modifies the upkeep for a player's resource.  Possible math types are MUT_Multiplication, MUT_Addition.
---@param playerId Player
---@param resourceType number
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_PlayerUpkeep(playerId, resourceType, scalefactor, mathtype) end

--- Modifies the production rate of all factories in an EGroup
---@param sgroup EGroup
---@param scalefactor number
---@return unknown
function Modify_ProductionRate(sgroup, scalefactor) end

--- Modifies the build time for a particular upgrade. This only affects the given player.
---@param entity Entity
---@param scalefactor number
---@return unknown
function Modify_ProductionSpeed(entity, scalefactor) end

--- Modifies a projectile's delay_detonate_time.
---@param player Player
---@param entityBP PBG
---@param factor number
---@return unknown
function Modify_ProjectileDelayTime(player, entityBP, factor) end

--- Modifies the chance of a squad/entity being hit
---@param group EGroup
---@param scalefactor number
---@param exclusive boolean | nil
---@return unknown
function Modify_ReceivedAccuracy(group, scalefactor, exclusive) end

--- Modifies the damage a squad/entity receives.
---@param group EGroup
---@param scalefactor number
---@param exclusive boolean | nil
---@return unknown
function Modify_ReceivedDamage(group, scalefactor, exclusive) end

--- Modifies the rate at which a squad gets suppressed
---@param sgroup SGroup
---@param scalefactor number
---@return unknown
function Modify_ReceivedSuppression(sgroup, scalefactor) end

--- Sets the cost of an upgrade. This only affects the given player
---@param playerId Player
---@param upgrade Upgrade
---@param resourceType number
---@param newCost number
---@return unknown
function Modify_SetUpgradeCost(playerId, upgrade, resourceType, newCost) end

--- Modifies the sight radius for an egroup or an sgroup.
---@param group EGroup
---@param scalefactor number
---@return unknown
function Modify_SightRadius(group, scalefactor) end

--- Modifies the availability limit of a squad type for any given player
---@param player Player
---@param blueprint string
---@param addition number
---@return unknown
function Modify_SquadAvailability(player, blueprint, addition) end

--- Modifies a squad's rate at which it will capture a strategic point.
---@param group SGroup
---@param scalefactor number
---@return unknown
function Modify_SquadCaptureRate(group, scalefactor) end

--- Modifies the cost of an squad for a particular player.
---@param player Player
---@param blueprint string
---@param resourcetype number
---@param addition number
---@return unknown
function Modify_SquadCost(player, blueprint, resourcetype, addition) end

--- Modifies a squad's health regen.
---@param group SGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@param exclusive boolean | nil
---@return unknown
function Modify_SquadHealthRegen(group, Factor, Usage__MUT_Multiplication, exclusive) end

--- Enable or Disable a squad's vulnerability to knock back
---@param group SGroup
---@param disable boolean
---@return unknown
function Modify_SquadInvulnerableToKnockback(group, disable) end

--- Modifies a squad's max health
--- Should only be used on squads
---@param group SGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@return unknown
function Modify_SquadMaxHealth(group, Factor, Usage__MUT_Multiplication) end

--- Modifies the sight radius of a squad type for any given player
---@param player Player
---@param blueprint string
---@param scalefactor number
---@return unknown
function Modify_SquadTypeSightRadius(player, blueprint, scalefactor) end

--- Modifies the target priority of a squad or entity group from the attacker. The value is an addition
---@param group EGroup
---@param addition number
---@return unknown
function Modify_TargetPriority(group, addition) end

--- Modifies a sync weapon only.
--- The hardpoint defaults to "hardpoint_01"
---@param group EGroup
---@param modifier string
---@param scalefactor number
---@param hardpoint string | nil
---@return unknown
function Modify_TeamWeapon(group, modifier, scalefactor, hardpoint) end

--- Modifies the territory radius for an egroup or an sgroup.
---@param group EGroup
---@param scalefactor number
---@return unknown
function Modify_TerritoryRadius(group, scalefactor) end

--- Modifies the maximum speed for a vehicle. This has no effect on infantry.
---@param sgroup SGroup
---@param scalefactor number
---@return unknown
function Modify_UnitSpeed(sgroup, scalefactor) end

--- Modifies the Veterancy Experience value of the target SGroup, EGroup, Entity, or Squad. Mathtype is Multiplication by default
---@param group EGroup
---@param scalefactor number
---@param mathtype number | nil
---@return unknown
function Modify_UnitVeterancyValue(group, scalefactor, mathtype) end

--- Modifies the build time for a particular upgrade. This only affects the given player.
---@param playerId Player
---@param upgrade Upgrade
---@param scalefactor number
---@return unknown
function Modify_UpgradeBuildTime(playerId, upgrade, scalefactor) end

--- Modifies the vehicle repair rate of all a player's engineers
---@param player Player
---@param factor number
---@param engineer_entity_blueprint string
---@return unknown
function Modify_VehicleRepairRate(player, factor, engineer_entity_blueprint) end

--- Modifies the vehicle rotation speed
---@param group EGroup
---@param factor number
---@return unknown
function Modify_VehicleRotationSpeed(group, factor) end

--- Modifies the turret rotation speed of a vehicle squad
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_VehicleTurretRotationSpeed(group, hardpoint, scalefactor) end

--- Increases the received accuracy, penetration, and damage on a squad by the scalefactor.  For example, a scalefactor of 2 means that the squad gets 2x the received accuracy, 2x the received penetration, and 2x the received damage.
---@param group EGroup
---@param scalefactor number
---@return unknown
function Modify_Vulnerability(group, scalefactor) end

--- Modifies a squad's weapon accuracy.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponAccuracy(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon burst length (time).
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponBurstLength(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon rate of fire.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponBurstRateOfFire(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon cooldown time.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponCooldown(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon damage.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponDamage(group, hardpoint, scalefactor) end

--- Enables or disables a weapon hardpoint
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param enabled boolean
---@return unknown
function Modify_WeaponEnabled(group, hardpoint, enabled) end

--- Modifies a squad's weapon penetration. Does not work on artillery (mortar, nebelwerfer, etc.)
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponPenetration(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon range. Does not work on artillery (mortar, nebelwerfer, etc.)
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponRange(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon reload time.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponReload(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon scatter.
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponScatter(group, hardpoint, scalefactor) end

--- Modifies a squad's weapon suppression. Does not work on artillery (mortar, nebelwerfer, etc.)
--- The hardpoint should be specified as a string - i.e. "hardpoint_01"
---@param group EGroup
---@param hardpoint string
---@param scalefactor number
---@return unknown
function Modify_WeaponSuppression(group, hardpoint, scalefactor) end

--- Gets the 'default music movement'.  This is the current default that can always be called
---@return unknown
function Music_GetDefaultMovement() end

--- Translates the string music event level into the engine designated intensity value
---@param music_event__see_Cardinal_scar_for_event_enums_ string
---@return unknown
function Music_GetMusicEventIntensityLevel(music_event__see_Cardinal_scar_for_event_enums_) end

--- Lock the music's intensity to a given level, for a given length of time (if you omit duration, the music plays indefinately until Music_UnlockIntensity is called)
--- You can chain several level/duration pairs together to create a playlist of sorts. To do this, just use more parameters: Music_LockIntensity(level1, duration1, level2, duration2, ...)
---@param level number
---@param duration number | nil
---@return unknown
function Music_LockIntensity(level, duration) end

--- Plays the music end outro segement and stop music after for about 50 secs.
---@return unknown
function Music_Outro_End() end

--- Play Music at the 'default music movement'
--- Set current music movement with Music_SetDefaultMovement
---@return unknown
function Music_PlayDefaultMovement() end

--- Plays a specific movement immediately - useful for things like NISes
---@param movement string
---@return unknown
function Music_PlayMovement(movement) end

--- Plays a stinger audio event.  The wwise event should handle ducking, ending, etc.
---@param Stinger string
---@return unknown
function Music_PlayStinger(Stinger) end

--- Plays the music short end outro segement after combat finishes and goes to silence for around 20 secs.
---@return unknown
function Music_PostCombat_End() end

--- This restart the music after objective after certain
---@param duration number
---@return unknown
function Music_RestartAfterObjective(duration) end

--- Sets the 'default music movement'.  This is the current default that can always be called
---@param newMovement string
---@return unknown
function Music_SetDefaultMovement(newMovement) end

--- This restart the music after objective after certain
---@param delay number
---@param level number
---@param duration number
---@return unknown
function Music_SetIntensityAfterObjective(delay, level, duration) end

--- Stops all music currently playing
---@return unknown
function Music_Stop() end

--- This stops music after objective and make sound go to silence
---@param delay number
---@return unknown
function Music_StopAfterObjective(delay) end

--- Unlock the music's intensity and revert to gameplay-driven
---@return unknown
function Music_UnlockIntensity() end

--- ONLY USE THIS INSIDE AN NIS EVENT. Wait until the NIS camera hits its counterpart checkpoint.
--- Makes the script pause and wait until the camera portion hits "nis_pause()" (the counterpart checkpoint) on it's timeline. With these two functions, you can have the event script and camera sync up - i.e. make one wait for the other - at various points in the NIS and avoid all sorts of timing issues.
---@return unknown
function NIS_CameraCheckpoint() end

--- ONLY USE THIS INSIDE AN NIS EVENT. Transition from the NIS back to the game.
--- You can safely do any cleanup after calling this, and it will occur once the screen is black.
---@param details table | nil
---@return unknown
function NIS_END(details) end

--- Used to create a fade cut in an NIS
--- Call this in your NIS Event.  This will require an nis_pause() frame in your NIS file in order to work.
---@return unknown
function NIS_FadeCameraCut() end

--- ONLY USE THIS INSIDE AN NIS EVENT. Transition from the game into an NIS preamble - a quick section before the NIS proper. A preamble is totally optional, if you want to go straight into an NIS, skip this and use NIS_START instead.
--- See NIS_START for information about the details table.
---@param details table
---@return unknown
function NIS_PREAMBLE(details) end

--- ONLY USE THIS INSIDE AN NIS EVENT. Transition from the game (or a preamble) into an NIS.
--- You can do any setup after calling this, as that will occur once the screen has faded to black on the transition in. The game will fade back in to the NIS over the next half second or so (apart from opening cinematics, which is two seconds), so you may want to delay your first action accordingly. The details table should include, at the very least, the following items: style (NIS_OPENING, NIS_MID, or NIS_CLOSING), revealFOW (a Boolean). If you included details in a preamble, you don't need to supply them again here.
---@param details table | nil
---@return unknown
function NIS_START(details) end

--- ONLY USE THIS INSIDE AN NIS EVENT with an NIS camera. Starts the NIS camera drifting.
--- "Drifting" moves the camera around in the shape of an infinity symbol, so it doesn't look quite so static.
---@param totalTime number | nil
---@param driftScale number | nil
---@return unknown
function NIS_StartDrift(totalTime, driftScale) end

--- ONLY USE THIS INSIDE AN NIS EVENT with an NIS camera. Stops the NIS camera drifting.
--- "Drifting" moves the camera around in the shape of an infinity symbol, so it doesn't look quite so static.
---@return unknown
function NIS_StopDrift() end

--- Stores the current camera position as the NIS's end_camera position.
--- Useful if you want the camera to always end where the player was last looking. If it does not return a position, nothing will be stored.
---@return unknown
function NIS_StoreCurrentCameraPos() end

--- Adds a map highlight around a specific point
--- AreaType is AT_CIRCLE (the default) or AT_SQUARE. Color is a table with three values for red, green and blue - i.e. {255, 0, 0}.
---@param objTable LuaTable
---@param pos Marker | Position | Group
---@param areatype AreaType | nil
---@param scale number | nil
---@param color table | nil
---@param alpha number | nil
---@return unknown
function Objective_AddAreaHighlight(objTable, pos, areatype, scale, color, alpha) end

--- Adds a visual splat on the ground in the world around a certain position, returning the ID
--- The reticule blueprint (the circle on the ground) and the hintpoint template (the arrow) are by defualt taken from the objective type, but you can override them or set them to false to turn that element off.
---@param objTable LuaTable
---@param position Marker | Position
---@param size number | nil
---@param reticuleBlueprint BP | nil
---@param hintpointTemplate string | nil
---@return unknown
function Objective_AddGroundReticule(objTable, position, size, reticuleBlueprint, hintpointTemplate) end

--- Adds a Healthbar tied to a squad or entity at a location.  Will update the health bar as the unit's health fluctuates.  Can be removed with Objective_RemoveHealthBar or completing/failing the objective
--- If you want to use one of the "global" progress bars (if your project supports them), supply the relevant barIndex value and text string to show alongside it.
---@param objTable LuaTable
---@param group EGroup
---@param onlyWhenDamaged boolean | nil
---@param barIndex number | nil
---@param text string | nil
---@return unknown
function Objective_AddHealthBar(objTable, group, onlyWhenDamaged, barIndex, text) end

--- Adds a tactical map ping to an objective
---@param objectiveTable LuaTable
---@param pos Position
---@return unknown
function Objective_AddPing(objectiveTable, pos) end

--- Returns whether all primary objectives have been completed.
---@return unknown
function Objective_AreAllPrimaryObjectivesComplete() end

--- Returns whether ALL or ANY sub-objectives of the given objective are complete
---@param objTable LuaTable
---@param all boolean
---@return unknown
function Objective_AreSubObjectivesComplete(objTable, all) end

--- Returns whether ALL or ANY sub-objectives of the given objective are expired
---@param objTable LuaTable
---@param all boolean
---@return unknown
function Objective_AreSubObjectivesExpired(objTable, all) end

--- Returns whether ALL or ANY sub-objectives of the given objective are failed
---@param objTable LuaTable
---@param all boolean
---@return unknown
function Objective_AreSubObjectivesFailed(objTable, all) end

--- Bring attention to some UI elements by blinking them. This causes the hintpoint and the off-screen arrow to blink, but leaves the minimap ping and other elements constant.
---@param objTable LuaTable
---@param elementID number
---@return unknown
function Objective_BlinkUIElements(objTable, elementID) end

--- Completes an objective and removes it from the list (unless it is a sub-objective, in which case it is marked as complete but stays visible until the parent objective is finished)
--- Automatically removes any elements added with Objective_AddUIElements(). The showTitle and playIntel flags let you control whether the titlecard and Intel_Complete event are played (default: true).
---@param objTable LuaTable
---@param showTitle boolean | nil
---@param playIntel boolean | nil
---@return unknown
function Objective_Complete(objTable, showTitle, playIntel) end

--- Expires an objective and removes it from the list (unless it is a sub-objective, in which case it is marked as expired but stays visible until the parent objective is finished)
--- Automatically removes any elements added with Objective_AddUIElements(). The showTitle and playIntel flags let you control whether the titlecard and Intel_Expire event are played (default: true).
---@param objTable LuaTable
---@param showTitle boolean | nil
---@param playIntel boolean | nil
---@return unknown
function Objective_Expire(objTable, showTitle, playIntel) end

--- Fails an objective and removes it from the list (unless it is a sub-objective, in which case it is marked as failed but stays visible until the parent objective is finished)
--- Automatically removes any elements added with Objective_AddUIElements(). The showTitle and playIntel flags let you control whether the titlecard and Intel_Fail event are played (default: true).
---@param objTable LuaTable
---@param showTitle boolean | nil
---@param playIntel boolean | nil
---@return unknown
function Objective_Fail(objTable, showTitle, playIntel) end

--- Returns the current count associated with this objective.
---@param objTable LuaTable
---@return unknown
function Objective_GetCounter(objTable) end

--- Returns a table of all sub-objectives of the given objective
---@param objTable LuaTable
---@return unknown
function Objective_GetSubObjectives(objTable) end

--- Returns the amount of seconds on the timer (time remaining or time elapsed, based on the type of timer used)
---@param objTable LuaTable
---@return unknown
function Objective_GetTimerSeconds(objTable) end

--- Increases the counter that is associated with this objective in the UI. You can provide an amount to increase by.
---@param objTable LuaTable
---@param amount number | nil
---@return unknown
function Objective_IncreaseCounter(objTable, amount) end

--- Returns whether an objective is complete
---@param objTable LuaTable
---@return unknown
function Objective_IsComplete(objTable) end

--- Returns true if a counter has been set for this objective
---@param objTable LuaTable
---@return unknown
function Objective_IsCounterSet(objTable) end

--- Returns whether an objective is expired
---@param objTable LuaTable
---@return unknown
function Objective_IsExpired(objTable) end

--- Returns whether an objective is failed
---@param objTable LuaTable
---@return unknown
function Objective_IsFailed(objTable) end

--- Returns whether an objective has been started. Completed and failed / expired objectives will also return true.
---@param objTable LuaTable
---@return unknown
function Objective_IsStarted(objTable) end

--- Returns true if a timer has been set for this objective
---@param objTable LuaTable
---@return unknown
function Objective_IsTimerSet(objTable) end

--- Returns whether an objective is visible or not.
---@param objTable LuaTable
---@return unknown
function Objective_IsVisible(objTable) end

--- Pauses the objective's timer. If a timer has not been set, it does nothing.
---@param objTable LuaTable
---@return unknown
function Objective_PauseTimer(objTable) end

--- 'Registers' an objective. Wrapper function for Objective_Create with a few other features.
--- Includes pings as defined by the objective table created in the main scar file. You can pass in a team or player, so that the objective only applies to it.
---@param objTable LuaTable
---@param owner Player | TeamID | nil
---@return unknown
function Objective_Register(objTable, owner) end

--- Removes an existing ground reticule by its ID
---@return unknown
function Objective_RemoveGroundReticule() end

--- Removes a health bar monitor
---@param objectiveTable LuaTable
---@param healthBarID Element
---@return unknown
function Objective_RemoveHealthBar(objectiveTable, healthBarID) end

--- Removes a tactical map ping from an objective
---@param objectiveTable LuaTable
---@param PingID number
---@return unknown
function Objective_RemovePing(objectiveTable, PingID) end

--- Remove a progress bar for this objective.
---@param objTable LuaTable
---@return unknown
function Objective_RemoveProgressBar(objTable) end

--- Removes a timer bar monitor
---@param objectiveTable LuaTable
---@param timerBarID Element
---@return unknown
function Objective_RemoveTimerBar(objectiveTable, timerBarID) end

--- Removes a group of UI elements that were added by Objective_AddUIElements
---@param objTable LuaTable
---@param elementID number
---@return unknown
function Objective_RemoveUIElements(objTable, elementID) end

--- Resume the objective's timer. If a timer has not been set, it does nothing.
---@param objTable LuaTable
---@return unknown
function Objective_ResumeTimer(objTable) end

--- Sets whether this objective always shows detailed text, the HUD arrow, or the hintpoints. There can only be one objective at a time that forces the HUD arrow to show up. If you pass in 'nil' for hud_arrow then its behavior is not affected.
---@param objTable LuaTable
---@param title boolean
---@param hud_arrow boolean
---@param hintpoints boolean
---@return unknown
function Objective_SetAlwaysShowDetails(objTable, title, hud_arrow, hintpoints) end

--- Sets a counter that is associated with this objective in the UI. You can provide a 'maximum' so that it shows up as "1 of 5"
---@param objTable LuaTable
---@param current number
---@param maximum number | nil
---@return unknown
function Objective_SetCounter(objTable, current, maximum) end

--- Show a progress bar for this objective with the given value (which should be a percentage from 0.0 (empty) to 1.0 (full)). This bar can be removed with Objective_RemoveProgressBar or by completing or failing the mission.
--- If you want to use one of the "global" progress bars (if your project supports them), supply the relevant barIndex value and text string to show alongside it.
---@param objTable LuaTable
---@param value number
---@param flashing boolean | nil
---@param barIndex number | nil
---@param text string | nil
---@return unknown
function Objective_SetProgressBar(objTable, value, flashing, barIndex, text) end

--- Shows or hides an objective from the UI and tactical map
---@param objective_table LuaTable
---@param on_off boolean
---@param ShowTitle boolean
---@return unknown
function Objective_Show(objective_table, on_off, ShowTitle) end

--- Shows an objective to the player and activates it
--- Includes pings and FOW as defined by the SetupUI() function. The showTitle and playIntel flags let you control whether the titlecard and Intel_Start event are played (default: true).
---@param objTable LuaTable
---@param showTitle boolean | nil
---@param playIntel boolean | nil
---@return unknown
function Objective_Start(objTable, showTitle, playIntel) end

--- Starts a timer that is associated with this objective in the UI. Use COUNT_DOWN or COUNT_UP for the 'direction' parameter
---@param objTable LuaTable
---@param direction number
---@param initialTime number | nil
---@param flashThreshold number | nil
---@return unknown
function Objective_StartTimer(objTable, direction, initialTime, flashThreshold) end

--- Stops an objective that is in progress and puts it back into the waiting-to-start state
---@param objTable LuaTable
---@return unknown
function Objective_Stop(objTable) end

--- Stops the objective's counter. If a counter has not been set, it does nothing.
---@param objTable LuaTable
---@return unknown
function Objective_StopCounter(objTable) end

--- Stops the objective's timer. If a timer has not been set, it does nothing.
---@param objTable LuaTable
---@return unknown
function Objective_StopTimer(objTable) end

--- Toggles minimap blips on or off.
---@param objective_table LuaTable
---@param on_off boolean
---@return unknown
function Objective_TogglePings(objective_table, on_off) end

--- ONLY CALL THIS FROM INSIDE AN OBJECTIVE'S INTEL START / COMPLETE / FAIL / EXPIRE EVENT. The objective titlecard will present itself at this point inside the event.
--- If you omit this call, the titlecard will appear at the end of the event by default. You also do not have to wrap this with CTRL and WAIT stuff - it does all of the internally.
---@return unknown
function Objective_TriggerTitleCard() end

--- Add an ability to a player
---@param player Player
---@param pAbilityPBG Ability
---@return unknown
function Player_AddAbility(player, pAbilityPBG) end

--- Specifies a marker where an ability cannot be used. This only applies to abilities where you use the cursor to pick a location in the world (like a location to paradrop at).
---@param player Player
---@param abilityPBG Ability
---@param marker Marker
---@return unknown
function Player_AddAbilityLockoutZone(player, abilityPBG, marker) end

--- Add resource to player, as opposed to just setting it.
--- Player::AddResourceReason, the resource add reason enum, can be nil, RES_Other, RES_Gift, RES_Resourcing, RES_Refund, RES_RefundOnDeath
---@param playerId Player
---@param resourceType number
---@param value number
---@return unknown
function Player_AddResource(playerId, resourceType, value) end

--- Add resources to player, as opposed to just setting it.
---@param playerId Player
---@param resources table
---@return unknown
function Player_AddResources(playerId, resources) end

--- For the given player, get all of the squads gathered into a squadgroup of your naming.
--- Squads will be added to given squad group.  If the given squad group does not exist it will be created.
---@param playerId Player
---@param squadgroupName string
---@return unknown
function Player_AddSquadsToSGroup(playerId, squadgroupName) end

--- Gives the player new command points to spent on
---@param player Player
---@param points number
---@return unknown
function Player_AddUnspentCommandPoints(player, points) end

--- Returns true if ANY of a players squads are in proximity of a marker
---@param playerid Player
---@param marker Marker
---@return unknown
function Player_AreSquadsNearMarker(playerid, marker) end

--- Tests if the player can currently use an ability on target entity
---@param player Player
---@param abilityPBG Ability
---@param targetEntity Entity
---@return unknown
function Player_CanCastAbilityOnEntity(player, abilityPBG, targetEntity) end

--- Tests if the player can currently use an ability on target player
---@param player Player
---@param abilityPBG Ability
---@param targetPlayer Player
---@return unknown
function Player_CanCastAbilityOnPlayer(player, abilityPBG, targetPlayer) end

--- Tests if the player can currently use an ability on target position
---@param player Player
---@param abilityPBG Ability
---@param targetPosition Position
---@return unknown
function Player_CanCastAbilityOnPosition(player, abilityPBG, targetPosition) end

--- Tests if the player can currently use an ability on target squad
---@param player Player
---@param abilityPBG Ability
---@param targetSquad Squad
---@return unknown
function Player_CanCastAbilityOnSquad(player, abilityPBG, targetSquad) end

--- Tests if the player is able to construct a given blueprint
---@param player Player
---@param pbg PBG
---@return unknown
function Player_CanConstruct(player, pbg) end

--- Returns TRUE if player can construct the specified entity at specified position and facing.  Otherwise, returns FALSE.
---@param player Player
---@param sgroupid SGroup
---@param ebp Entity
---@param targetid EGroup
---@param Facing Position | nil
---@return unknown
function Player_CanConstructOnPosition(player, sgroupid, ebp, targetid, Facing) end

--- Check if a player of specified group can place an entity at the specified position and facing angle.
--- ebp is the structureBlueprint that must be a valid building that can be constructed by the sgroup.
---@param player Player
---@param sgroup SGroup
---@param ebp Entity
---@param position Position
---@param facing Position
---@return unknown
function Player_CanPlaceStructureOnPosition(player, sgroup, ebp, position, facing) end

--- Returns true if a player can see ALL or ANY items in an egroup
---@param playerid Player
---@param egroup EGroup
---@param all boolean
---@return unknown
function Player_CanSeeEGroup(playerid, egroup, all) end

--- Returns true if a player can see a given entity (revealed in FOW)
---@param player Player
---@param entity Entity
---@return unknown
function Player_CanSeeEntity(player, entity) end

--- Returns true if a player can see a given position.
---@param player Player
---@param pos Position
---@return unknown
function Player_CanSeePosition(player, pos) end

--- Returns true if a player can see ALL or ANY items in an sgroup
---@param playerid Player
---@param sgroup SGroup
---@param all boolean
---@return unknown
function Player_CanSeeSGroup(playerid, sgroup, all) end

--- Returns true if a player can see ALL or ANY units in a given squad (revealed in FOW)
--- Set all to true to check that ALL units are visible or set to false to check for ANY.
---@param player Player
---@param squad Squad
---@param all boolean
---@return unknown
function Player_CanSeeSquad(player, squad, all) end

--- Any of the player's units in the marker area move out of the area, and can be made invulnerable for a bit whilst they do it
--- You can replace the marker with a position and a range - i.e. Player_ClearArea(player, pos, range, invulnerable)
---@param player Player
---@param marker Marker
---@param invulnerable boolean
---@return unknown
function Player_ClearArea(player, marker, invulnerable) end

--- Clears item, command and construction menu availabilities for the player.
---@param player Player
---@return unknown
function Player_ClearAvailabilities(player) end

--- Clears the pop cap override so that modifiers can take effect again
---@param player Player
---@return unknown
function Player_ClearPopCapOverride(player) end

--- Clears a TargetHandle value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_ClearStateModelEnumTableTarget(player, key, tableRowIndex) end

--- Clears a TargetHandle value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_ClearStateModelTarget(player, key) end

--- Searches the player list in the world and returns the id of the first enemy player
---@param player Player
---@return unknown
function Player_FindFirstEnemyPlayer(player) end

--- Searches the player list in the world and returns the id of the first neutral player
---@param player Player
---@return unknown
function Player_FindFirstNeutralPlayer(player) end

--- Returns a player given a player id from the ME.
---@param id number
---@return unknown
function Player_FromId(id) end

--- Returns the type of the given player if it is an AI.
---@param player Player
---@return unknown
function Player_GetAIType(player) end

--- Creates/Clears groups that contain all of a player's units and buildings. Defaults - sg_allsquads and eg_allentities
--- Fills an SGroup with all of the given player's squads, and an EGroup with all the player's entities. If you don't provide and groups, then it defaults to using sg_allsquads and eg_allentities.
---@param player Player
---@param sgroup SGroup | nil
---@param egroup EGroup | nil
---@return unknown
function Player_GetAll(player, sgroup, egroup) end

--- Returns an sim::EntityGroupObs containing all the players entities including ones in squad.
--- This function returns a 'global' entity group with the name '__Player%dEntities', where %d is the player ID.  This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.
---@param player Player
---@return unknown
function Player_GetAllEntities(player) end

--- Returns an EGroup containing all of the players entities(including non_squad entities) of a specific unit_type (as defined by the type_ext on the entity)
--- This function returns a new EGroup to allow tracking of different types.
---@param player Player
---@param unitType string
---@return unknown
function Player_GetAllEntitiesFromType(player, unitType) end

--- Gather together all of a player's entities that are in proximity to a marker, a position, or within a territory sector into an EGroup. The EGroup is cleared beforehand.
--- You can override a marker's normal proximity by specifying a range.
---@param playerid Player
---@param egroup EGroup
---@param position Marker | Position | SectorID
---@param range number | nil
---@return unknown
function Player_GetAllEntitiesNearMarker(playerid, egroup, position, range) end

--- Gather together all of a player's squads that are in proximity to a marker, a position, or within a territory sector into an SGroup. The SGroup is cleared beforehand.
--- You can override a marker's normal proximity by specifying a range.
---@param player Player
---@param sgroup SGroup
---@param position Marker | Position | SectorID
---@param range number | nil
---@return unknown
function Player_GetAllSquadsNearMarker(player, sgroup, position, range) end

--- Returns the entityID of the first player owned building listed in the table.
--- This only looks at completed buildings
---@param player Player
---@param entitytypes_unit_types number
---@return unknown
function Player_GetBuildingID(player, entitytypes_unit_types) end

--- Returns the total number of buildings owned by this player.
---@param playerId Player
---@return unknown
function Player_GetBuildingsCount(playerId) end

--- Returns the total number of buildings owned by this player (with exclusions).
---@param playerId Player
---@param exceptions number
---@return unknown
function Player_GetBuildingsCountExcept(playerId, exceptions) end

--- Returns the number of buildings owned by this player (inclusive).
---@param playerId Player
---@param ebplist number
---@return unknown
function Player_GetBuildingsCountOnly(playerId, ebplist) end

--- Returns the entityID of the first player owned building listed in the table.
--- This only looks at under construction buildings
---@param player Player
---@param entitytypes_unit_types number
---@return unknown
function Player_GetBuildingUnderConstructionID(player, entitytypes_unit_types) end

--- Use capType CT_Personnel to get current squad cap, CT_Vehicle to get current vehicle cap, CT_Medic to get current medic cap
---@param player Player
---@param capType CapType
---@return unknown
function Player_GetCurrentPopulation(player, capType) end

--- Get current popcap. Use capType CT_Personnel to get current squad cap or CT_VehicleCap to get current vehicle cap.
---@param player Player
---@param capType CapType
---@return unknown
function Player_GetCurrentPopulationCap(player, capType) end

--- Returns the players UI name.
---@param player Player
---@return unknown
function Player_GetDisplayName(player) end

--- Returns an sim::EntityGroupObs containing all the players entities excluding ones in squad.
--- This function returns a 'global' entity group with the name '__Player%dEntities', where %d is the player ID.  This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.
---@param player Player
---@return unknown
function Player_GetEntities(player) end

--- Gets all the player's current entities and loads them into the specified egroup.
--- Gets all the player's current entities and loads them into the specified egroup. The egroup is cleared before being loaded.
---@param player Player
---@param group EGroup
---@return unknown
function Player_GetEntitiesEGroup(player, group) end

--- Returns an EGroup containing all of the players entities(excluding non_squad entities) of a specific unit_type (as defined by the type_ext on the entity)
--- This function returns a new EGroup to allow tracking of different types.
---@param player Player
---@param unitType string
---@return unknown
function Player_GetEntitiesFromType(player, unitType) end

--- Returns the modified cost of the given entity including all modifications added by the given player
---@param player Player
---@param pbg PBG
---@return unknown
function Player_GetEntityBPCost(player, pbg) end

--- Finds the greatest (or least) concentration of entities owned by a player.
--- This function is slow, so don't call it very often
---@param player Player
---@param popcapOnly boolean | nil
---@param includeBlueprints table | nil
---@param excludeBlueprints table | nil
---@param bLeastConcentrated boolean | nil
---@param onlyInThisMarker Marker | table | nil
---@return unknown
function Player_GetEntityConcentration(player, popcapOnly, includeBlueprints, excludeBlueprints, bLeastConcentrated, onlyInThisMarker) end

--- Returns the number of entities a player currently owns
---@param player Player
---@return unknown
function Player_GetEntityCount(player) end

--- Returns the number of entities of a certain unit type
---@param player Player
---@param unitTypeString string
---@return unknown
function Player_GetEntityCountByUnitType(player, unitTypeString) end

--- Returns the name of an entity a player currently owns
---@param player Player
---@param index number
---@return unknown
function Player_GetEntityName(player, index) end

--- Get maximum popcap. Use capType CT_Personnel to get max squad cap or CT_VehicleCap to get max vehicle cap.
---@param player Player
---@param capType CapType
---@return unknown
function Player_GetMaxPopulationCap(player, capType) end

--- Get maximum popcap including any overrides. Use capType CT_Personnel to get max squad cap or CT_VehicleCap to get max vehicle cap. If there are no overrides, the default max pop cap is returned.
---@param player Player
---@param capType CapType
---@return unknown
function Player_GetMaxPopulationCapOverride(player, capType) end

--- Returns the number of squads currently gathering resources of a given type
---@param player Player
---@param type number
---@return unknown
function Player_GetNumGatheringSquads(player, type) end

--- Returns the number of strategic points (not objectives) this player owns
---@param p Player
---@return unknown
function Player_GetNumStrategicPoints(p) end

--- Returns the number of strategic objectives this player owns
---@param p Player
---@return unknown
function Player_GetNumVictoryPoints(p) end

--- Gets the current personnel or vehicle population as a percetange of the current max-cap. The captype is either CT_Personnel or CT_Vehicle.
--- If MaxPopulation is 0, returns 1.0 captype is CT_Personnel by default.
---@param playerid Player
---@param captype number | nil
---@return unknown
function Player_GetPopulationPercentage(playerid, captype) end

--- DEPRECATED, use Player_ObserveRelationship instead.
---@param player1 Player
---@param player2 Player
---@return unknown
function Player_GetRelationship(player1, player2) end

--- Returns the amount of resources a given player has.
---@param player Player
---@param type number
---@return unknown
function Player_GetResource(player, type) end

--- Returns the amount of resources a given player is getting per second.
---@param player Player
---@param type number
---@return unknown
function Player_GetResourceRate(player, type) end

--- Returns the list of all the resources a given player has.
---@param player Player
---@return unknown
function Player_GetResources(player) end

--- Returns the lobby slot index for this player, starting at one
---@param player Player
---@return unknown
function Player_GetSlotIndex(player) end

--- Returns the modified cost of the given unit including all modifications added by the given player
---@param pPlayer Player
---@param pbg PBG
---@return unknown
function Player_GetSquadBPCost(pPlayer, pbg) end

--- Finds the greatest (or least) concentration of squads owned by a player.
--- This function is slow, so don't call it very often
---@param player Player
---@param popcapOnly boolean | nil
---@param includeBlueprints table | nil
---@param excludeBlueprints table | nil
---@param bLeastConcentrated boolean | nil
---@param onlyInThisMarker Marker | table | nil
---@return unknown
function Player_GetSquadConcentration(player, popcapOnly, includeBlueprints, excludeBlueprints, bLeastConcentrated, onlyInThisMarker) end

--- Returns the number of squads a player currently owns
---@param player Player
---@return unknown
function Player_GetSquadCount(player) end

--- Returns a SquadGroupObs containing all the players units.
--- This function returns a 'global' squad group with the name '__Player%dSquads', where %d is the player ID.  This means that you should never need to destroy it./n However, if you do destroy it, it will be recreated the next time this function is called.
---@param player Player
---@return unknown
function Player_GetSquads(player) end

--- Returns an SGroup containing all of the players squads of a specific unit_type (as defined by the type_ext on the squad)
--- This function returns a new SGroup.
---@param player Player
---@param unitType string
---@return unknown
function Player_GetSquadsFromType(player, unitType) end

--- Returns a boolean value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelBool(player, key) end

--- Returns an Entity value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelEntityTarget(player, key) end

--- Returns a boolean value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableBool(player, key, tableRowIndex) end

--- Returns an Entity value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableEntityTarget(player, key, tableRowIndex) end

--- Returns a float value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableFloat(player, key, tableRowIndex) end

--- Returns an integer value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableInt(player, key, tableRowIndex) end

--- Returns a Player value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTablePlayerTarget(player, key, tableRowIndex) end

--- Returns a Squad value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableSquadTarget(player, key, tableRowIndex) end

--- Returns a Vector3f value from the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@return unknown
function Player_GetStateModelEnumTableVector3f(player, key, tableRowIndex) end

--- Returns a float value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelFloat(player, key) end

--- Returns an integer value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelInt(player, key) end

--- Returns a Player value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelPlayerTarget(player, key) end

--- Returns a Squad value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelSquadTarget(player, key) end

--- Returns a Vector3f value from the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@return unknown
function Player_GetStateModelVector3f(player, key) end

--- Returns a value (-1.0 to 1.0) of how close a point is to being controlled by the team of the player provided
--- Progress between -1.0 and 0 means an enemy has progress toward owning a point.  Values between 0 and 1.0 represent progress being made toward capture. 1.0 is a team controlled point.  -1.0 is an enemy controlled point.
---@param player Player
---@param strategicPoint Entity
---@return unknown
function Player_GetStrategicPointCaptureProgress(player, strategicPoint) end

--- Get the team a player is on
---@param p Player
---@return unknown
function Player_GetTeam(p) end

--- Gets the toal population including Personnel, Vehicle and Medic
--- Directly uses the C++ API Player_GetCurrentPopulation to get the current population for CT_Personnel, CT_Vehicle and CT_Medic.
---@param player Player
---@return unknown
function Player_GetTotalPopulation(player) end

--- Returns the UI colour of a player with respect to the local machine. Access with .r .g .b .a. Values are in the range 0-255.
---@param player Player
---@return unknown
function Player_GetUIColour(player) end

--- Returns the current number of units the player has.
---@param player Player
---@return unknown
function Player_GetUnitCount(player) end

--- Returns the cost of an upgrade.
---@param player Player
---@param upgradePBG Upgrade
---@return unknown
function Player_GetUpgradeBPCost(player, upgradePBG) end

--- Returns the cost of an upgrade in a specific resource.
---@param player Player
---@param upgradePBG Upgrade
---@param type number
---@return unknown
function Player_GetUpgradeBPCostByResource(player, upgradePBG, type) end

--- Set the gifted resource amount for a given player A positive resource amount means the player receives the resources A negative resource amount means the player sends the resources Ignores income cap and resource sharing.
---@param player Player
---@param type number
---@param amount number
---@return unknown
function Player_GiftResource(player, type, amount) end

--- Tests to see if a player has an ability
---@param player Player
---@param pAbilityPBG Ability
---@return unknown
function Player_HasAbility(player, pAbilityPBG) end

--- Returns true if this player owns any buildings listed in the table.
--- This only looks at completed buildings - use Player_HasBuildingUnderConstruction to see if the player is building something
---@param player Player
---@param entitytypes_unit_types number
---@return unknown
function Player_HasBuilding(player, entitytypes_unit_types) end

--- Returns true if this player owns any buildings. (with exclusions).
---@param playerId Player
---@param exceptions_unit_types number
---@return unknown
function Player_HasBuildingsExcept(playerId, exceptions_unit_types) end

--- Returns true if this player owns any buildings listed in the table currently under construction.
---@param player Player
---@param entitytypes_unit_types number
---@return unknown
function Player_HasBuildingUnderConstruction(player, entitytypes_unit_types) end

--- Returns true if the given player has units that are able to capture in the capturable area of the given strategic point
---@param player Player
---@param strategicPoint Entity
---@return unknown
function Player_HasCapturingSquadNearStrategicPoint(player, strategicPoint) end

--- Tests to see if the player has any entities with the specified PBG
---@param player Player
---@param entity Entity
---@return unknown
function Player_HasEntity(player, entity) end

--- Returns whether a player has a map entry position
---@param player Player
---@return unknown
function Player_HasMapEntryPosition(player) end

--- Return true if the squad has purchased the specified upgrade.
---@param pPlayer Player
---@param upgradePBG Upgrade
---@return unknown
function Player_HasUpgrade(pPlayer, upgradePBG) end

--- Returns true or false, depending on whether the passed in player ability is active on the player
---@param player Player
---@param abilityPBG Ability
---@return unknown
function Player_IsAbilityActive(player, abilityPBG) end

--- Returns true if player is still alive and false if player is dead.  Will error if playerIdx is an invalid index.
---@param player Player
---@return unknown
function Player_IsAlive(player) end

--- Returns true if the players are allied and false if they are not.
---@param playerId1 Player
---@param playerId2 Player
---@return unknown
function Player_IsAllied(playerId1, playerId2) end

--- Returns whether a player is human controlled (local or remote), not dead, and not replaced by an AI
---@param player Player
---@return unknown
function Player_IsHuman(player) end

--- Returns true if player has surrendered and false if not.  Will error if playerIdx is an invalid index.
---@param player Player
---@return unknown
function Player_IsSurrendered(player) end

--- Check if id corresponds to a player
---@param id number
---@return unknown
function Player_IsValid(id) end

--- Returns the number of upgrades that this player has.
---@param player Player
---@param upgradePBG Upgrade
---@return unknown
function Player_NumUpgradeComplete(player, upgradePBG) end

--- Get the relationship that observer has to target.
---@param observer Player
---@param target Player
---@return unknown
function Player_ObserveRelationship(observer, target) end

--- Get the reputation that observer has to target.
---@param observer Player
---@param target Player
---@return unknown
function Player_ObserveReputation(observer, target) end

--- Returns true if a given player owns ALL or ANY items in a group
---@param player Player
---@param egroup EGroup
---@param all boolean | nil
---@return unknown
function Player_OwnsEGroup(player, egroup, all) end

--- Returns true if a given player owns an entity
---@param playerid Player
---@param entity Entity
---@return unknown
function Player_OwnsEntity(playerid, entity) end

--- Returns true if a given player owns ALL or ANY items in a group
---@param player Player
---@param sgroup SGroup
---@param all boolean | nil
---@return unknown
function Player_OwnsSGroup(player, sgroup, all) end

--- Returns true if a given player owns a squad
---@param playerid Player
---@param squad Squad
---@return unknown
function Player_OwnsSquad(playerid, squad) end

--- Removes a marker that was previously a lockout zone.
---@param player Player
---@param abilityPBG Ability
---@param marker Marker
---@return unknown
function Player_RemoveAbilityLockoutZone(player, abilityPBG, marker) end

--- Removes all upgrade from a player
---@param player Player
---@return unknown
function Player_RemoveAllUpgrades(player) end

--- Removes an upgrade from a player
---@param player Player
---@param upgrade Upgrade
---@return unknown
function Player_RemoveUpgrade(player, upgrade) end

--- Reset the cooldown of an ability on every unit a player has, and the player itself.
---@param player Player
---@param ability Ability
---@return unknown
function Player_ResetAbilityCooldowns(player, ability) end

--- Reset the resource amount for a given player to zero.
---@param player Player
---@param type number
---@return unknown
function Player_ResetResource(player, type) end

--- Restrict a list of addons.
--- list should contain an array of strings to restrict.
---@param playerid Player
---@param addonlist table
---@return unknown
function Player_RestrictAddOnList(playerid, addonlist) end

--- Restrict a list of buildings.
--- list should contain an array of strings to restrict.
---@param playerid Player
---@param blueprintlist table
---@return unknown
function Player_RestrictBuildingList(playerid, blueprintlist) end

--- Restrict a list of research items.
--- list should contain an array of strings to restrict.
---@param playerid Player
---@param list string
---@return unknown
function Player_RestrictResearchList(playerid, list) end

--- Sets availability of ALL entity, squad and player commands.
---@param player Player
---@param availability Availability
---@param reason string
---@return unknown
function Player_SetAllCommandAvailabilityInternal(player, availability, reason) end

--- Sets the availability of entity, squad and player commands. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT
---@param player Player
---@param command number
---@param availability number
---@return unknown
function Player_SetCommandAvailability(player, command, availability) end

--- Sets the availability of a construction menu. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT
---@param player Player
---@param menuname string
---@param availability number
---@return unknown
function Player_SetConstructionMenuAvailability(player, menuname, availability) end

--- Set default squad mood mode which can be overrided by squad level mood mode settings
---@param player Player
---@param mood SquadCombatBehaviourMoodMode
---@return unknown
function Player_SetDefaultSquadMoodMode(player, mood) end

--- Sets the availability of an entity production item. Availability can be either ITEM_LOCKED, ITEM_UNLOCKED, ITEM_REMOVED or ITEM_DEFAULT
---@param player Player
---@param bp number
---@param availability number
---@return unknown
function Player_SetEntityProductionAvailability(player, bp, availability) end

--- Sets the current personnel or vehicle max-cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet).
--- Note that any modifiers that adjust the current max cap will be applied on top of this.  Also note, this is only adjusting the max cap, not the current cap, you will have to call Player_SetMaxPopulation to adjust the current max population to do this.
---@param playerid Player
---@param captype number
---@param newcap number
---@return unknown
function Player_SetMaxCapPopulation(playerid, captype, newcap) end

--- Sets the current personnel or vehicle cap for a player. The captype is either CT_Personnel or CT_Vehicle (you can't adjust Medic caps just yet).
--- Note that any modifiers that adjust the current cap will be applied on top of this.  Also note, the current cap cannot go higher than the max cap.
---@param playerid Player
---@param captype number
---@param newcap number
---@return unknown
function Player_SetMaxPopulation(playerid, captype, newcap) end

--- Sets a pop cap override that ignores any modifiers.
---@param player Player
---@param personnel number
---@return unknown
function Player_SetPopCapOverride(player, personnel) end

--- Set the relationship that observer has to target. If the relationship does not match the current reputation, the reputation will be changed to match it.
---@param observer Player
---@param target Player
---@param relationship Relation
---@return unknown
function Player_SetRelationship(observer, target, relationship) end

--- Set the reputation that observer has to target. If the reputation does not match the current relationship, the relationship will be changed to match it.
---@param observer Player
---@param target Player
---@param reputation BaseType
---@return unknown
function Player_SetReputation(observer, target, reputation) end

--- Set the resource amount for a given player.  Ignores income cap and resource sharing.
---@param player Player
---@param type number
---@param amt number
---@return unknown
function Player_SetResource(player, type, amt) end

--- Set the resource amount for a given player.  Ignores income cap and resource sharing.
---@param player Player
---@param type number
---@param amt number
---@param reason AddResourceReason
---@return unknown
function Player_SetResourceInternal(player, type, amt, reason) end

--- Set all the resource amount for a given player.  Ignores income cap and resource sharing.
---@param player Player
---@param resourceAmount ResourceAmount
---@return unknown
function Player_SetResources(player, resourceAmount) end

--- Sets a boolean value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value boolean
---@return unknown
function Player_SetStateModelBool(player, key, value) end

--- Sets an Entity TargetHandle value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value Entity
---@return unknown
function Player_SetStateModelEntityTarget(player, key, value) end

--- Sets a boolean value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value boolean
---@return unknown
function Player_SetStateModelEnumTableBool(player, key, tableRowIndex, value) end

--- Sets an Entity TargetHandle value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value Entity
---@return unknown
function Player_SetStateModelEnumTableEntityTarget(player, key, tableRowIndex, value) end

--- Sets a float value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Player_SetStateModelEnumTableFloat(player, key, tableRowIndex, value) end

--- Sets an integer value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Player_SetStateModelEnumTableInt(player, key, tableRowIndex, value) end

--- Sets a Player TargetHandle value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value Player
---@return unknown
function Player_SetStateModelEnumTablePlayerTarget(player, key, tableRowIndex, value) end

--- Sets a Squad TargetHandle value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value Squad
---@return unknown
function Player_SetStateModelEnumTableSquadTarget(player, key, tableRowIndex, value) end

--- Sets a Vector3f value in the player's state model corresponding to the given key and table row index (0 based).
---@param player Player
---@param key string
---@param tableRowIndex number
---@param value Position
---@return unknown
function Player_SetStateModelEnumTableVector3f(player, key, tableRowIndex, value) end

--- Sets a float value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value number
---@return unknown
function Player_SetStateModelFloat(player, key, value) end

--- Sets an integer value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value number
---@return unknown
function Player_SetStateModelInt(player, key, value) end

--- Sets a Player TargetHandle value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value Player
---@return unknown
function Player_SetStateModelPlayerTarget(player, key, value) end

--- Sets a Squad TargetHandle value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value Squad
---@return unknown
function Player_SetStateModelSquadTarget(player, key, value) end

--- Sets a Vector3f value in the Player's state model corresponding to the given key.
---@param player Player
---@param key string
---@param value Position
---@return unknown
function Player_SetStateModelVector3f(player, key, value) end

--- Abruptly stops an active ability
---@param player Player
---@param ability Ability
---@param bIsEarlyExit boolean
---@return unknown
function Player_StopAbility(player, ability, bIsEarlyExit) end

--- Prevents a player from earning any action points (and by extention, command points)
---@param player Player
---@return unknown
function Player_StopEarningActionPoints(player) end

--- Returns the relationship between 2 teams.
---@param team1 number
---@param team2 number
---@return unknown
function Team_GetRelationship(team1, team2) end

--- Applies the defaults listed in the prefab schema to the instance data. Any items NOT included explicitly in the instance data will have default values pulled from the schema.
---@param instance_data string
---@param prefab_schema table
---@return unknown
function Prefab_ApplyDefaults(instance_data, prefab_schema) end

--- Calls an action function with a given name on an instance, making sure it calls the right version for the type of Prefab. Instance can be a string, this will convert it.
--- Example: Calling the "Trigger" action on an instance that is a PlaneCrash prefab will look for a function called "PlaneCrash_Trigger"
---@param instance_data string
---@param actionName string
---@param param1 any | nil
---@param param2___ any | nil
---@return unknown
function Prefab_DoAction(instance_data, actionName, param1, param2___) end

--- Finalize the initialization of any prefab instances that have been run through Prefab_Init(). This is automatically called one frame after a prefab is initialized, but you can force it early if necessary.
--- If you are creating prefabs and using them in the same frame, call this function once, after all the Prefab_Inits, but before you start using them. This will force the post-initialization to occur early.
---@return unknown
function Prefab_ForcePostInit() end

--- Returns a table of all current prefabs matching the instance type
---@param instance_data string
---@param prefab_schema table
---@return unknown
function Prefab_GetAllOfType(instance_data, prefab_schema) end

--- Returns the instance data for a given instance, specified by a number of methods.
--- This normalizes your instance data. You can pass in the instance name as a string, a data table with an instance subtable (i.e. the input params from an event function) or a real instance data table, and it normalizes the format and returns you the instance data table.
---@param instance string
---@return unknown
function Prefab_GetInstance(instance) end

--- Initialize a specific prefab instance. In many cases, this is all you need to do (see the documentation for the specific prefab for details)
---@param instance_data table
---@return unknown
function Prefab_Init(instance_data) end

--- Returns if a String is a valid
---@param instance string
---@return unknown
function Prefab_IsValid(instance) end

--- Stop and restart a prefab instance, pulling a fresh set of the instance data from the WB-exported prefabs. This is meant for testing and debug purposes, rather than use in mission scripts.
---@param instance_data string
---@return unknown
function Prefab_Reset(instance_data) end

--- Stops a prefab instance from continuing to run.
--- If the prefab has a prefabName_Stop() function, that will be called. Also, all events with the instance as the data parameter will be removed.
---@param instance_data string
---@return unknown
function Prefab_Stop(instance_data) end

--- Triggers the specified prefab
---@param instance_data string
---@return unknown
function Prefab_Trigger(instance_data) end

--- Add this helper function to your prefab's Init function to cover standard trigger zone functionality.
--- It will call a Trigger function in your prefab when appropriate. Your schema needs to include the standard elements: trigger_enable, ignore_planes, trigger_player, trigger_zone and delay
---@param instance_data string
---@param action_name string
---@param trigger_parameters table
---@return unknown
function PrefabHelper_StandardTriggerSystem(instance_data, action_name, trigger_parameters) end

--- Plays a speech event for a given actor WITH a portrait and subtitle
--- If the speech file is not available, a placeholder time will be calculated for the message using the number of words and the message will be displayed for that length of time.\n speechbubble: Who a speech bubble should appear over ingame. Can be a squadID or an SGroup (where it appears over the first guy in the group) \n It can also be a table in the format {sgroup = sg_orkboys, closest_to = sg_gorgutz} where it finds the squad in the group closest to the reference point. It can also be in the format {sbp = SBP.ORKS.ORK_BOY, closest_to = mkr_orkIdol} to find the closest unit of the specified type, and you can also add a player entry to that table to specify which player (default is the local player)\n You can also specify just an SBP, in which case it will play on the first SBP found owned - use this for elite units who may or may not be on the map audioCtrlEvent:  is a wwise event name. This parameter is used to apply an effect on the line of speech. Ex. "Comm_on" plays speech through a comm effect. Work with an audio designer to get more effects.
---@param actor ActorTable
---@param locID number
---@param speechbubble SGroup | nil
---@param audioCtrlEvent string | nil
---@return unknown
function Actor_PlaySpeech(actor, locID, speechbubble, audioCtrlEvent) end

--- Plays a speech event for a given actor WITHOUT a portrait or subtitle. See Actor_PlaySpeech for more details
---@param actor ActorTable
---@param locID number
---@param speechbubble SGroup | nil
---@param audioCtrlEvent string | nil
---@return unknown
function Actor_PlaySpeechWithoutPortrait(actor, locID, speechbubble, audioCtrlEvent) end

--- Returns true if ANY or ALL entities from a group are in range of a given position, marker, or territory sector.
--- You MUST specify a range if you are using a position rather than a marker. Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param egroup EGroup
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@return unknown
function Prox_AreEntitiesNearMarker(egroup, position, all, range) end

--- Returns true if ANY or ALL of a player's entities are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY.
--- You MUST specify a range if you are using a position rather than a marker.\n Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param player Player
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@param filterlist EntityPBG | table | nil
---@param filtertype number | nil
---@param ignore_camouflage boolean | nil
---@return unknown
function Prox_ArePlayerEntitiesNearMarker(player, position, all, range, filterlist, filtertype, ignore_camouflage) end

--- Returns true if ANY or ALL of a player's members (i.e. individual guys, not squads as a whole) are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!!
--- You MUST specify a range if you are using a position rather than a marker.
---@param player Player
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@param filterlist SBP | table | nil
---@param filtertype number | nil
---@param ignore_camouflage boolean | nil
---@return unknown
function Prox_ArePlayerMembersNearMarker(player, position, all, range, filterlist, filtertype, ignore_camouflage) end

--- Returns true if ANY or ALL of a player's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY.
--- You MUST specify a range if you are using a position rather than a marker.\n Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param player Player
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@param filterlist SBP | table | nil
---@param filtertype number | nil
---@param ignore_camouflage boolean | nil
---@return unknown
function Prox_ArePlayersNearMarker(player, position, all, range, filterlist, filtertype, ignore_camouflage) end

--- Returns true if ANY or ALL squad members (i.e. individual guys, not squads as a whole) from a group are in range of a given position, marker, or territory sector. DO NOT USE THIS FUNCTION UNLESS YOU ABSOLUTELY HAVE TO!!
--- You MUST specify a range if you are using a position rather than a marker.\n Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param sgroup SGroup
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@return unknown
function Prox_AreSquadMembersNearMarker(sgroup, position, all, range) end

--- Returns true if ANY or ALL squads from a group are in range of a given position, marker, or territory sector
--- You MUST specify a range if you are using a position rather than a marker.\n Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param sgroup SGroup
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@return unknown
function Prox_AreSquadsNearMarker(sgroup, position, all, range) end

--- Returns true if ANY or ALL of a teams's squads are in range of a given position, marker, or territory sector. THIS FUNCTION IS VERY SLOW. DO NOT USE THIS UNLESS ABSOLUTELY NECESSARY.
--- You MUST specify a range if you are using a position rather than a marker.\n Markers with proximity type rectangle will use circular proximity check if custom range is supplied\n
---@param team TeamID
---@param position Marker | Position | SectorID
---@param all boolean
---@param range number | nil
---@param filterlist SBP | table | nil
---@param filtertype number | nil
---@param ignore_camouflage boolean | nil
---@return unknown
function Prox_AreTeamsNearMarker(team, position, all, range, filterlist, filtertype, ignore_camouflage) end

--- Returns the distance between two entity groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER.
--- If check is PROX_SHORTEST this will return the shortest distance between the two groups.\n If check is PROX_LONGEST this will return the longest distance between the two groups.\n If check is PROX_CENTER this will return the distance between the two groups centers.\n
---@param egroup1 EGroup
---@param egroup2 EGroup
---@param checktype ProxType
---@return unknown
function Prox_EGroupEGroup(egroup1, egroup2, checktype) end

--- Returns the distance between an entity group and a squad group.  use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER.
--- If check is PROX_SHORTEST this will return the shortest distance between the two groups.\n If check is PROX_LONGEST this will return the longest distance between the two groups.\n If check is PROX_CENTER this will return the distance between the two groups centers.\n
---@param egroup1 EGroup
---@param sgroup2 SGroup
---@param checktype ProxType
---@return unknown
function Prox_EGroupSGroup(egroup1, sgroup2, checktype) end

--- Checks if ALL or ANY entities are in proximity of a given entity group.
--- Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.
---@param egroup1 EGroup
---@param egroup2 EGroup
---@param proximity number
---@param all boolean
---@return unknown
function Prox_EntitiesInProximityOfEntities(egroup1, egroup2, proximity, all) end

--- Takes something (Entity, Squad, SGroup, EGroup, Position) in, then returns a random position
--- Minimum is the distance from the origin point that is guaranteed to have a return greater than Minimum is ignored if it is greater than the radius
---@param item Object
---@param radius number
---@param minimum number
---@return unknown
function Prox_GetRandomPosition(item, radius, minimum) end

--- Returns the distance between a marker and an entity group.  use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER.
--- If check is PROX_SHORTEST this will return the shortest distance between the two groups.\n If check is PROX_LONGEST this will return the longest distance between the two groups.\n If check is PROX_CENTER this will return the distance between the two groups centers.\n
---@param marker Marker
---@param egroup EGroup
---@param checktype ProxType
---@return unknown
function Prox_MarkerEGroup(marker, egroup, checktype) end

--- Returns the distance between a marker and a squad group.  use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER.
--- If check is PROX_SHORTEST this will return the shortest distance between the two groups.\n If check is PROX_LONGEST this will return the longest distance between the two groups.\n If check is PROX_CENTER this will return the distance between the two groups centers.\n
---@param marker Marker
---@param sgroup SGroup
---@param checktype ProxType
---@return unknown
function Prox_MarkerSGroup(marker, sgroup, checktype) end

--- Checks if ALL or ANY players squads are in proximity of a given entity group.
--- Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.
---@param playerid Player
---@param egroup EGroup
---@param proximity number
---@param all boolean
---@param exclude Entity
---@return unknown
function Prox_PlayerEntitiesInProximityOfEntities(playerid, egroup, proximity, all, exclude) end

--- Checks if ALL or ANY players entities are in proximity of a given squad group.
--- Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.
---@param playerentities Player
---@param playersquads Player
---@param proximity number
---@param all boolean
---@return unknown
function Prox_PlayerEntitiesInProximityOfPlayerSquads(playerentities, playersquads, proximity, all) end

--- Checks if ALL or ANY players entities are in proximity of a given squad group.
--- Set "all" to true to check that ALL entities are in proximity, or set "all" to false to check for ANY.
---@param playerid Player
---@param sgroup SGroup
---@param proximity number
---@param all boolean
---@return unknown
function Prox_PlayerEntitiesInProximityOfSquads(playerid, sgroup, proximity, all) end

--- Checks if ALL or ANY players squads are in proximity of a given entity group.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param playerid Player
---@param egroup EGroup
---@param proximity number
---@param all boolean
---@param filterlist SBP | table
---@param filtertype number
---@param ignore_camouflage boolean
---@return unknown
function Prox_PlayerSquadsInProximityOfEntities(playerid, egroup, proximity, all, filterlist, filtertype, ignore_camouflage) end

--- Checks if ALL or ANY players squads are in proximity of a given players entities.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param playersquads Player
---@param playerentities Player
---@param proximity number
---@param all boolean
---@return unknown
function Prox_PlayerSquadsInProximityOfPlayerEntities(playersquads, playerentities, proximity, all) end

--- Checks if ALL or ANY players squads are in proximity of a given players squads.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param playerid1 Player
---@param playerid2 Player
---@param proximity number
---@param all boolean
---@return unknown
function Prox_PlayerSquadsInProximityOfPlayerSquads(playerid1, playerid2, proximity, all) end

--- Checks if ALL or ANY players squads are in proximity of a given squad group.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param playerid Player
---@param sgroup SGroup
---@param proximity number
---@param all boolean
---@param exclude Squad
---@param filterlist SBP | table
---@param filtertype number
---@param ignore_camouflage boolean
---@return unknown
function Prox_PlayerSquadsInProximityOfSquads(playerid, sgroup, proximity, all, exclude, filterlist, filtertype, ignore_camouflage) end

--- Returns the distance between two squad groups. use checktype PROX_SHORTEST, PROX_LONGEST, or PROX_CENTER.
--- If check is PROX_SHORTEST this will return the shortest distance between the two groups.\n If check is PROX_LONGEST this will return the longest distance between the two groups.\n If check is PROX_CENTER this will return the distance between the two groups centers.\n
---@param sgroup1 SGroup
---@param sgroup2 SGroup
---@param checktype ProxType
---@return unknown
function Prox_SGroupSGroup(sgroup1, sgroup2, checktype) end

--- Checks if ALL or ANY squads are in proximity of a given entity group.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param sgroup SGroup
---@param egroup EGroup
---@param proximity number
---@param all boolean
---@return unknown
function Prox_SquadsInProximityOfEntities(sgroup, egroup, proximity, all) end

--- Checks if ALL or ANY squads are in proximity of a given squad group.
--- Set "all" to true to check that ALL squads are in proximity, or set "all" to false to check for ANY.
---@param sgroup1 SGroup
---@param sgroup2 SGroup
---@param proximity number
---@param all boolean
---@return unknown
function Prox_SquadsInProximityOfSquads(sgroup1, sgroup2, proximity, all) end

--- Add a decal to the terrain. Returns a unique decal id allow for future removal via Decal_Destroy
---@param decalName string
---@param position Position
---@param xScale number
---@param yScale number
---@param zScale number
---@param rotationDegrees number
---@param r number
---@param g number
---@param b number
---@param a number
---@return unknown
function Decal_Create(decalName, position, xScale, yScale, zScale, rotationDegrees, r, g, b, a) end

--- Destroy a decal by unique id
---@param decalID number
---@return unknown
function Decal_Destroy(decalID) end

--- Get the Decal ID that represents an invalid decal (useful to check if creation failed)
---@return unknown
function Decal_GetInvalidID() end

--- Cleanup resources in cache. Only for debug purposes, not in RTM.
---@param cacheName string
---@return unknown
function ResourceContainer_ClearCache(cacheName) end

--- Create a cache to load resources into giving its name and number of resources to hold
--- Once cache is full, the oldest resource will get removed and clean itself up
---@param cacheName string
---@param cacheSize number
---@return unknown
function ResourceContainer_CreateCache(cacheName, cacheSize) end

--- Log resource references to log. Only for debug purposes, not in RTM.
--- dumps inventory information to ResourceContainerLog file
---@return unknown
function ResourceContainer_LogRefs() end

--- Add a splat to the terrain. Returns a unique decal id allow for future removal via Splat_Destroy
---@param splatName string
---@param position Position
---@param xScale number
---@param zScale number
---@param rotationDegrees number
---@param r number
---@param g number
---@param b number
---@param a number
---@param mirrorX boolean
---@param mirrorZ boolean
---@return unknown
function Splat_Create(splatName, position, xScale, zScale, rotationDegrees, r, g, b, a, mirrorX, mirrorZ) end

--- Destroy a splat by unique id
---@param handle TerrainSplatObject
---@return unknown
function Splat_Destroy(handle) end

--- Get the Splat ID that represents an invalid splat (useful to check if creation failed)
---@return unknown
function Splat_GetInvalidID() end

--- Load the saved terrain height map. This will restore the state of the terrain height map to
---@return unknown
function Terrain_LoadHeightMap() end

--- Save the current terrain height map. It can be restored to that state by using Terrain_LoadHeightMap.
---@return unknown
function Terrain_SaveHeightMap() end

--- Hide metadata layer overlay on terrain
---@return unknown
function TerrainHighlight_Hide() end

--- Display metadata layer on terrain. Replaces previously displayed terrain highlight
---@param metadataLayerName string
---@param opacity number
---@return unknown
function TerrainHighlight_Show(metadataLayerName, opacity) end

--- Add a rule to be executed every frame.
--- Returns the ID of the rule just added.
---@param f function
---@param data table | nil
---@param group EGroup | nil
---@return unknown
function Rule_Add(f, data, group) end

--- Add a rule to be executed when the event of 'eventType' has happened on entities in the 'egroup'
--- Event types are: GE_EntityKilled, GE_EntityParadropComplete, GE_EntityCommandIssued, GE_ProjectileFired, GE_AbilityExecuted, GE_SpawnActionComplete
---@param rule function
---@param egroup EGroup
---@param eventtype number
---@return unknown
function Rule_AddEGroupEvent(rule, egroup, eventtype) end

--- Add a rule to be executed when the event of 'eventType' has happened on the 'entity'
--- Event types are: GE_EntityKilled, GE_EntityParadropComplete, GE_EntityCommandIssued, GE_ProjectileFired, GE_AbilityExecuted, GE_SpawnActionComplete
---@param rule function
---@param entity Entity
---@param eventtype number
---@return unknown
function Rule_AddEntityEvent(rule, entity, eventtype) end

--- Adds a filter to the given rule that will cause the event to only be invoked if - The blueprint of the entity pointed to by context is in includeTypes and none in excludeTypes.
--- Valid contexts are dependent on the event this filter is applied to. When multiple filters exist op defines how the result of the previous filter is combined with this filter. Blueprint can be either a PBG or the name of a type (where in it acts the same as Rule_AddEventFilter_EntityType).
---@param rule function
---@param context RuleFilterContext
---@param op RuleFilterOperator
---@param includeTypes table
---@param excludeTypes table
---@return unknown
function Rule_AddEventFilter_EntityBlueprint(rule, context, op, includeTypes, excludeTypes) end

--- Adds a filter to the given rule that will cause the event to only be invoked if - The type of the entity pointed to by context is owned by a player that is in includeTypes and none in excludeTypes.
--- Valid contexts are dependent on the event this filter is applied to. When multiple filters exist op defines how the result of the previous filter is combined with this filter.
---@param rule function
---@param context RuleFilterContext
---@param op RuleFilterOperator
---@param includeTypes table
---@param excludeTypes table
---@return unknown
function Rule_AddEventFilter_EntityPlayerOwner(rule, context, op, includeTypes, excludeTypes) end

--- Adds a filter to the given rule that will cause the event to only be invoked if - The type of the entity pointed to by context is in includeTypes and not in excludeTypes.
--- Valid contexts are dependent on the event this filter is applied to. When multiple filters exist op defines how the result of the previous filter is combined with this filter.
---@param rule function
---@param context RuleFilterContext
---@param op RuleFilterOperator
---@param includeTypes table
---@param excludeTypes table
---@return unknown
function Rule_AddEventFilter_EntityType(rule, context, op, includeTypes, excludeTypes) end

--- Adds a filter to the given rule that will cause the event to only be invoked if - The type of the entity pointed to by context has at least one true state model value from includeTypes and none from excludeTypes.
--- Valid contexts are dependent on the event this filter is applied to. When multiple filters exist op defines how the result of the previous filter is combined with this filter.
---@param rule function
---@param context RuleFilterContext
---@param op RuleFilterOperator
---@param includeTypes table
---@param excludeTypes table
---@return unknown
function Rule_AddEventFilter_StateModelBool(rule, context, op, includeTypes, excludeTypes) end

--- Add a rule to be executed. Can include a start delay, an interval between rule calls and a count of how many times the rule is called.
--- interval can be a number (the interval between subsequent rule calls) or a table with the keys: "delay", "interval" and "count". Returns the ID of the rule just added.
---@param f function
---@param interval number | table
---@param data table | nil
---@param group EGroup | nil
---@return unknown
function Rule_AddInterval(f, interval, data, group) end

--- Add a rule to be executed once, after 'delay' seconds.
--- Returns the ID of the rule just added.
---@param rule function
---@param delay number | nil
---@param data table | nil
---@param group EGroup | nil
---@return unknown
function Rule_AddOneShot(rule, delay, data, group) end

--- Add a rule to be executed when the event of 'eventType' has happened on squads in the 'sgroup'
--- Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadParadropComplete, GE_SquadCommandIssued, GE_AbilityExecuted, GE_SpawnActionComplete
---@param rule function
---@param sgroup SGroup
---@param eventtype number
---@return unknown
function Rule_AddSGroupEvent(rule, sgroup, eventtype) end

--- Add a rule to be executed when the event of 'eventType' has happened on the 'squad'
--- Event types are: GE_SquadKilled, GE_SquadPinned, GE_SquadParadropComplete, GE_SquadCommandIssued, GE_AbilityExecuted, GE_SpawnActionComplete
---@param rule function
---@param squad Squad
---@param eventtype number
---@return unknown
function Rule_AddSquadEvent(rule, squad, eventtype) end

--- Change 'interval' seconds of all rules with LuaFunction f
---@param rule function
---@param interval number
---@return unknown
function Rule_ChangeInterval(rule, interval) end

--- Change 'interval' seconds of an existing rule with id
---@param id number
---@param interval number
---@return unknown
function Rule_ChangeIntervalWithID(id, interval) end

--- Triggers when a group (SGroup/EGroup) gets close enough to a location
---@param f function
---@param all boolean
---@param who EGroup
---@param where Marker
---@param range number | nil
---@param recur boolean | nil
---@param data table | nil
---@return unknown
function Rule_EnterProximity(f, all, who, where, range, recur, data) end

--- Test if a rule with LuaFunction f is currently active
---@param rule function
---@return unknown
function Rule_Exists(rule) end

--- Test if a rule with id is currently active. Only for TimeRules
---@param id number
---@return unknown
function Rule_ExistsWithID(id) end

--- Triggers when a group (SGroup/EGroup) gets far enough from a location (the group must enter the range before this can trigger)
---@param f function
---@param all boolean
---@param who EGroup
---@param where Marker
---@param range number | nil
---@param recur boolean | nil
---@param data table | nil
---@return unknown
function Rule_ExitProximity(f, all, who, where, range, recur, data) end

--- Comparison is one of IS_LESS_THAN; IS_LESS_THAN_OR_EQUAL; IS_EQUAL; IS_NOT_EQUAL; IS_GREATER_THAN; IS_GREATER_THAN_OR_EQUAL. Triggers when the number of objects in the group, when compared to value by comparison, is true
---@param f function
---@param group EGroup
---@param comparison Comparison
---@param value number
---@param recur boolean
---@param data table
---@return unknown
function Rule_GroupCount(f, group, comparison, value, recur, data) end

--- Pause all rules with LuaFunction for
---@param f function
---@return unknown
function Rule_Pause(f) end

--- Pause all currently active rules. Ignores Unpauseable rules.
---@param __Table_groupsToIgnore number
---@return unknown
function Rule_PauseAll(__Table_groupsToIgnore) end

--- Pause all rules with with id. Only for TimeRules
---@param id number
---@return unknown
function Rule_PauseWithID(id) end

--- Refreshes all Time and Event rules
---@return unknown
function Rule_Refresh() end

--- Remove all currently active rules with LuaFunction f (this does not remove any event rules)
---@param rule function
---@return unknown
function Rule_Remove(rule) end

--- Kills ALL rules.
---@return unknown
function Rule_RemoveAll() end

--- Remove an active event rule for entities in the 'egroup'
---@param rule function
---@param egroup EGroup
---@return unknown
function Rule_RemoveEGroupEvent(rule, egroup) end

--- Remove an active event rule for the 'entity'
---@param rule function
---@param entity Entity
---@return unknown
function Rule_RemoveEntityEvent(rule, entity) end

--- Remove an active event rule that's been applied 'globally'
---@param rule function
---@return unknown
function Rule_RemoveGlobalEvent(rule) end

--- Remove a currently executing rule (only works inside a rule function)
---@return unknown
function Rule_RemoveMe() end

--- Remove an active event rule for the 'player'
---@param rule function
---@param player Player
---@return unknown
function Rule_RemovePlayerEvent(rule, player) end

--- Remove an active event rule for squads in the 'sgroup'
---@param rule function
---@param sgroup SGroup
---@return unknown
function Rule_RemoveSGroupEvent(rule, sgroup) end

--- Remove an active event rule for the 'squad'
---@param rule function
---@param squad Squad
---@return unknown
function Rule_RemoveSquadEvent(rule, squad) end

--- Remove a currently active rule with id (this does not remove any event rules)
---@param id number
---@return unknown
function Rule_RemoveWithID(id) end

--- Replaces the function callback for all currently active rules with LuaFunction f (This only applies to TimeRules)
---@param oldf function
---@param newf function
---@return unknown
function Rule_Replace(oldf, newf) end

--- Replaces the function callback for all currently active rules with an id (This only applies to TimeRules)
---@param id number
---@param newf function
---@return unknown
function Rule_ReplaceWithID(id, newf) end

--- Unpause all rules with LuaFunction for
---@param f function
---@return unknown
function Rule_Unpause(f) end

--- Unpause all rules
---@return unknown
function Rule_UnpauseAll() end

--- Unpause all rules with with id. Only for TimeRules
---@param id number
---@return unknown
function Rule_UnpauseWithID(id) end

--- Triggers every interval seconds that the group is within range of the location
---@param f function
---@param all boolean
---@param who EGroup
---@param where Marker
---@param range number | nil
---@param interval number | nil
---@param recur boolean | nil
---@param data table | nil
---@return unknown
function Rule_WhileInProximity(f, all, who, where, range, interval, recur, data) end

--- Pass in a group to command to 'stop'. Pass in booleans for capturing and building
---@param sgroup1 SGroup
---@param stopCapture boolean | nil
---@param stopBuild boolean | nil
---@return unknown
function Cmd_StopSquadsExcept(sgroup1, stopCapture, stopBuild) end

--- Instantly adds an upgrade to all entities in a given EGroup.
---@param egroup EGroup
---@param upgrade number
---@return unknown
function EGroup_CompleteUpgrade(egroup, upgrade) end

--- Filters an EGroup to either FILTER_REMOVE or FILTER_KEEP entities that are currently camouflaged (stealthed included)
---@param sgroup EGroup
---@param filtertype number
---@param splitEGroup EGroup | nil
---@return unknown
function EGroup_FilterCamouflaged(sgroup, filtertype, splitEGroup) end

--- Restore the targeting type of the entities in this EGroup to their respective defaults (as found in their EBPs)
---@param egroup EGroup
---@return unknown
function EGroup_RestoreTargetingType(egroup) end

--- Enables or disables the burn extenstion
---@param egroup EGroup
---@param enabled boolean
---@return unknown
function EGroup_SetBurnExtEnabled(egroup, enabled) end

--- Set the allowable methods of targeting the entities in this EGroup.
---@param egroup EGroup
---@param targetingType TargetingType
---@return unknown
function EGroup_SetTargetingType(egroup, targetingType) end

--- Test whether ANY or ALL of an EGroup is on screen currently (not strict)
---@param group EGroup
---@param percent number
---@param all boolean
---@return unknown
function Misc_IsEGroupOnScreen(group, percent, all) end

--- Test whether ANY or ALL of an SGroup is on screen currently (not strict)
---@param group SGroup
---@param percent number
---@param all boolean
---@return unknown
function Misc_IsSGroupOnScreen(group, percent, all) end

--- Adds an squadron to the end of a group if the group doesn't already have it.
---@param group SGroup
---@param squadron Squad
---@return unknown
function SGroup_Add(group, squadron) end

--- Adds an ability to all squads in an sgroup.
---@param sgroup SGroup
---@param ability number
---@return unknown
function SGroup_AddAbility(sgroup, ability) end

--- Same as EGroup_AddGroup.  Note: You cannot mix squad groups and entity groups.
---@param group SGroup
---@param grouptoadd SGroup
---@return unknown
function SGroup_AddGroup(group, grouptoadd) end

--- Add a list of multiple sgroups into an existing group.
---@param sgroup SGroup
---@param groupList table
---@return unknown
function SGroup_AddGroups(sgroup, groupList) end

--- Adds a leader to all squads in a group that can take a leader.
--- This function will bypass all cost and queue prereqs
---@param sgroup SGroup
---@return unknown
function SGroup_AddLeaders(sgroup) end

--- Adds the amount of resource type for a squad.
--- If SGroup contains multiple squads, it will add for all
---@param sgroup SGroup
---@param resource ResourceType
---@param amount number
---@return unknown
function SGroup_AddResource(sgroup, resource, amount) end

--- Add to the list of slot items to drop when any one of the squads is wiped out
--- Drop chance is percentage chance the item will drop (0.0-1.0) exlusive means the squad would only drop this item, thus erasing all previous items in list example:	local item = Util_GetSlotItemID( "slot_item/allies_m9bazooka.lua" ) SGroup_AddSlotItemToDropOnDeath( squadid, item, false )
---@param groupid SGroup
---@param itemid number
---@param drop_chance number
---@param exclusive boolean
---@return unknown
function SGroup_AddSlotItemToDropOnDeath(groupid, itemid, drop_chance, exclusive) end

--- Test whether ANY or ALL of a group can be ordered to do this ability on the target squad
---@param caster SGroup
---@param ability number
---@param target_entity Entity
---@param all boolean
---@return unknown
function SGroup_CanCastAbilityOnEntity(caster, ability, target_entity, all) end

--- Test whether ANY or ALL of a group can be ordered to do this ability on the target position
---@param caster SGroup
---@param ability number
---@param position Position
---@param all boolean
---@return unknown
function SGroup_CanCastAbilityOnPosition(caster, ability, position, all) end

--- Test whether ANY or ALL of a group can be ordered to do this ability on the target entity
---@param caster SGroup
---@param ability number
---@param target_squad Squad
---@param all boolean
---@return unknown
function SGroup_CanCastAbilityOnSquad(caster, ability, target_squad, all) end

--- Return true if ANY or ALL of a group can reinforce now
---@param group SGroup
---@param all boolean
---@return unknown
function SGroup_CanInstantReinforceNow(group, all) end

--- Returns true if ALL or ANY entities in a group can see ALL or ANY entities in a given egroup.
---@param sgroup SGroup
---@param targetegroup EGroup
---@param all boolean
---@return unknown
function SGroup_CanSeeEGroup(sgroup, targetegroup, all) end

--- Returns true if ALL or ANY squads in a group can see ALL or ANY squads in a target sgroup.
---@param sgroup SGroup
---@param targetsgroup SGroup
---@param all boolean
---@return unknown
function SGroup_CanSeeSGroup(sgroup, targetsgroup, all) end

--- Removes all entities from a group.
---@param sgroup SGroup
---@return unknown
function SGroup_Clear(sgroup) end

--- Clears any previous posture suggestions made to a squad
---@param sgroup SGroup
---@return unknown
function SGroup_ClearPostureSuggestion(sgroup) end

--- Returns true if the contents of the two groups are equal. Order of the entities does not matter.
---@param group1 SGroup
---@param group2 SGroup
---@return unknown
function SGroup_Compare(group1, group2) end

--- Applies an upgrade to all squad entities in an sgroup.
---@param sgroup SGroup
---@param upgrade Upgrade
---@return unknown
function SGroup_CompleteEntityUpgrade(sgroup, upgrade) end

--- Instantly adds an upgrade to all squads in a given SGroup.
---@param sgroup SGroup
---@param upgrade number
---@return unknown
function SGroup_CompleteUpgrade(sgroup, upgrade) end

--- Check if a group contains ALL or ANY of the blueprints.
---@param sgroup SGroup
---@param blueprints BP | table
---@param all boolean
---@return unknown
function SGroup_ContainsBlueprints(sgroup, blueprints, all) end

--- Returns true if SGroup1 contains ANY or ALL of SGroup2
---@param group1 SGroup
---@param group2 SGroup
---@param all boolean
---@return unknown
function SGroup_ContainsSGroup(group1, group2, all) end

--- Returns true if SGroup contains a particular SquadID
---@param group SGroup
---@param SquadID number
---@param includeDespawned boolean
---@return unknown
function SGroup_ContainsSquad(group, SquadID, includeDespawned) end

--- Returns the total number of spawned and despawned squads in a group.
--- NOTE: SGroup_Count does not count the individual soldiers in an SGroup.  For that, use SGroup_TotalMembersCount
---@param sgroup SGroup
---@return unknown
function SGroup_Count(sgroup) end

--- Returns the number of squads within an Sgroup that match an alliance with the player passed in
---@param group SGroup
---@param player Player
---@return unknown
function SGroup_CountAlliedSquads(group, player) end

--- Returns the total count of all squads in a given SGroup with the provided blueprint or type
---@param sgroup SGroup
---@param sbp string
---@return unknown
function SGroup_CountBlueprints(sgroup, sbp) end

--- Returns the number of despawned squads in a group.
---@param sgroup SGroup
---@return unknown
function SGroup_CountDeSpawned(sgroup) end

--- Returns the number of squads within an Sgroup that match an alliance with the player passed in
---@param group SGroup
---@param player Player
---@return unknown
function SGroup_CountEnemySquads(group, player) end

--- Counts the total population cost of an SGroup by iterating over each individual Squad
---@param sgroup SGroup
---@return unknown
function SGroup_CountPopulation(sgroup) end

--- Returns the number of spawned squads in a group.
---@param sgroup SGroup
---@return unknown
function SGroup_CountSpawned(sgroup) end

--- Returns a new squadron group with the given name.
--- Squad groups are used for all units and vehicles.  You can issue orders such as move and attack to an entire squad group. If you want a group for buildings or objects such as trees, use an sim::EntityGroupObs instead.\n Note that you cannot create sgroups with duplicate names.\n To be safe, you can check if the SGroup you want to create exists using SGroup_Exists( )
---@param name string
---@return unknown
function SGroup_Create(name) end

--- Find a squad group from name.  Creates a new one with given name if it doesnt exist.
---@param name string
---@return unknown
function SGroup_CreateIfNotFound(name) end

--- Returns an SGroup with a unique name, prefixed by the 'prefix' parameter.
---@param prefix string | nil
---@return unknown
function SGroup_CreateUnique(prefix) end

--- Returns a new squad group with an autogenerated unique name, optionally prefixed by the string passed in.
--- Use this if you want to create a new SGroup but don't necessarily care about the name.\n Squad groups are used for all units and vehicles.  You can issue orders such as move and attack to an entire squad group.\n
---@param prefix string
---@return unknown
function SGroup_CreateUniqueWithPrefix(prefix) end

--- Despawn all spawned squads in a group.
---@param groupid SGroup
---@return unknown
function SGroup_DeSpawn(groupid) end

--- Manually destroy a group that you don't need anymore.
---@param sgroup SGroup
---@return unknown
function SGroup_Destroy(sgroup) end

--- Destroys all items in a group that are in proximity to a given marker.
---@param sgroup SGroup
---@param marker Marker
---@return unknown
function SGroup_DestroyAllInMarker(sgroup, marker) end

--- Destroys all spawned and despawned squads in a group.
--- Be careful not to confuse this with SGroup_Destroy which destroys the group and NOT the squads it contains.  This function will destroy spawned and despawned items in a group
---@param sgroup SGroup
---@return unknown
function SGroup_DestroyAllSquads(sgroup) end

--- Disables all current combat plans for the squads in the sgroup
---@param groupID SGroup
---@return unknown
function SGroup_DisableCombatPlans(groupID) end

--- Duplicates an SGroup. Creates a copy of sgroup1 in sgroup2. The function will clear sgroup2 beforehand if necessary.
---@param sgroup1 SGroup
---@param sgroup2 SGroup
---@return unknown
function SGroup_Duplicate(sgroup1, sgroup2) end

--- Sets whether an entity pays attention to its surroundings
---@param sgroup SGroup
---@param attentive boolean
---@return unknown
function SGroup_EnableAttention(sgroup, attentive) end

--- Enable or disable minimap indicator on all squads in the sgroup
---@param group SGroup
---@param enable boolean
---@return unknown
function SGroup_EnableMinimapIndicator(group, enable) end

--- Enables or disables the surprise feature for an sgroup
---@param groupid SGroup
---@param enable boolean
---@return unknown
function SGroup_EnableSurprise(groupid, enable) end

--- Enable or disable decorators on all squads in the sgroup
---@param group SGroup
---@param enable boolean
---@return unknown
function SGroup_EnableUIDecorator(group, enable) end

--- Returns true if the squad group with the given name exists
---@param name string
---@return unknown
function SGroup_Exists(name) end

--- Makes two SGroups face each other
---@param sgroup1 SGroup
---@param sgroup2 SGroup
---@return unknown
function SGroup_FaceEachOther(sgroup1, sgroup2) end

--- Makes a SGroup face a marker.
---@param sgroup SGroup
---@param marker Marker
---@return unknown
function SGroup_FaceMarker(sgroup, marker) end

--- Filters an SGroup by blueprint.
--- A table of blueprints can be specified if you want to filter on more than one type. Setting filtertype to FILTER_KEEP results in the group only containing squads of the types listed in the blueprint table. Setting filtertype to FILTER_REMOVE will strip those same squads out and leave those that aren't of the types listed. Setting splitSGroup will move any squads being KEEP or REMOVE to it.  This SGroup will NOT be cleared beforehand. SquadTypes can also be used in place of Blueprints. If you want a squad to match a bunch of SquadTypes at the same time (i.e. AND instead of OR) then they can be listed together in a sub-table.
---@param sgroup SGroup
---@param blueprint SBP | SquadType | table
---@param filtertype number
---@param splitSGroup SGroup | nil
---@return unknown
function SGroup_Filter(sgroup, blueprint, filtertype, splitSGroup) end

--- Filters an sgroup base on proximity. Use FILTER_KEEP to keep the affected units, or FILTER_REMOVE to remove them. Set invertPosition to TRUE to affect the units outside the position.
---@param sgroup SGroup
---@param position Position
---@param filtertype number
---@param OPT_range number | nil
---@param OPT_splitSGroup SGroup | nil
---@return unknown
function SGroup_FilterByProximity(sgroup, position, filtertype, OPT_range, OPT_splitSGroup) end

--- Filters an SGroup to either FILTER_REMOVE or FILTER_KEEP units that are currently camouflaged (stealthed included)
---@param sgroup SGroup
---@param filtertype number
---@param splitSGroup SGroup | nil
---@return unknown
function SGroup_FilterCamouflaged(sgroup, filtertype, splitSGroup) end

--- Pass in a group and it will filter it down to the indicated number
---@param sgroup1 SGroup
---@param groupSize number
---@param splitSGroup SGroup | nil
---@return unknown
function SGroup_FilterCount(sgroup1, groupSize, splitSGroup) end

--- Filters an SGroup by whether units are on screen or not. Percent refers to the screen area you are considering (0.8 is a good value to use - it won't include things that are right at the screen edge).
--- Setting filtertype to FILTER_KEEP results in the group only containing those squads that are on screen.
---@param egroup SGroup
---@param percent number
---@param filtertype number
---@return unknown
function SGroup_FilterOnScreen(egroup, percent, filtertype) end

--- Filters an sgroup on spawned/despawned status. Use FILTER_KEEP to keep the spawned units (therefore removing the despawned), or FILTER_REMOVE to remove the spawned units (and keep the despawned).
---@param sgroup SGroup
---@param filtertype number
---@param splitSGroup SGroup | nil
---@return unknown
function SGroup_FilterSpawned(sgroup, filtertype, splitSGroup) end

--- Searches an SGroup and finds the first threat within the table (searching first to last) and removes all other SBPs.
--- Optional parameter bEmpty can be set to true, will clear the SGroup if none of the SBPS in the table are found.
---@param sgroup SGroup
---@param tableSBPs LuaTable
---@param bEmpty boolean | nil
---@return unknown
function SGroup_FilterThreat(sgroup, tableSBPs, bEmpty) end

--- Filters an sgroup on spawned/despawned status. Use FILTER_KEEP to keep the spawned units (therefore removing the despawned), or FILTER_REMOVE to remove the spawned units (and keep the despawned).
---@param sgroup SGroup
---@param filtertype number
---@param splitSGroup SGroup | nil
---@return unknown
function SGroup_FilterVisibleToPlayer(sgroup, filtertype, splitSGroup) end

--- Call a lua function for each item in a group. Function will recieve (groupid, itemindex, itemid) and should return true to break or false to continue.
--- function Rule_Test( )\n \tlocal DespawnSquad = function( sgroupid, itemindex, squadID )\n \t\tSquad_Despawn( squadID )\n \tend\n\n \tSGroup_ForEach( SGroup_FromName("sg_Squads"), DespawnSquad )\n end\n\n This functions iterates over spawned squads only.
---@param sgroup SGroup
---@param f function
---@return unknown
function SGroup_ForEach(sgroup, f) end

--- Call a lua function for each item in a group. Function will receive (groupid, itemindex, itemid) and should return a bool.
--- Only use this to TEST conditions on squads. DO NOT use this to perform operations on all squads, since it may not call your function on all squads (due to short circuit evaluation). This is used for checking if ALL or ANY items in a group match a given predicate. (eg. Are all items in a group chaos marines)\n This functions iterates over spawned squads only.
---@param sgroup SGroup
---@param all boolean
---@param f function
---@return unknown
function SGroup_ForEachAllOrAny(sgroup, all, f) end

--- Same as SGroup_ForEachAllOrAny except you have a choice to iterate over spawned squads, despawned squads, or both.
---@param sgroup SGroup
---@param all boolean
---@param f function
---@param spawned boolean
---@param despawned boolean
---@return unknown
function SGroup_ForEachAllOrAnyEx(sgroup, all, f, spawned, despawned) end

--- Same as SGroup_ForEach except you have a choice to iterate over spawned squads, despawned squads, or both.
---@param sgroup SGroup
---@param f function
---@param spawned boolean
---@param despawned boolean
---@return unknown
function SGroup_ForEachEx(sgroup, f, spawned, despawned) end

--- Find an squadron group with a given name.
---@param name string
---@return unknown
function SGroup_FromName(name) end

--- Returns the average health ratio of all units in a squad group.
--- It now uses the same health measure that's used by the UI, so it does take into account fallen members of a squad
---@param sgroup SGroup
---@return unknown
function SGroup_GetAvgHealth(sgroup) end

--- Return the average health ratio, including shield strengths, of the squads in the SGroup
---@param sgroup SGroup
---@param includeBonuses boolean
---@return unknown
function SGroup_GetAvgHealthPercentageWithShields(sgroup, includeBonuses) end

--- Returns the average loadout of all squads in a group as a percent [0.0, 1.0].
--- Example: A group of squads with loadouts of 4/8 and 1/1 would return 0.75
---@param sgroup SGroup
---@return unknown
function SGroup_GetAvgLoadout(sgroup) end

--- Return the average shield strengths of the squads in the SGroup (as a percentage)
---@param sgroup SGroup
---@return unknown
function SGroup_GetAvgShieldPercentage(sgroup) end

--- Get the closest squad in an sgroup to a given position
---@param sgroupid SGroup
---@param position Marker | Position
---@return unknown
function SGroup_GetClosestSquad(sgroupid, position) end

--- Returns the despawned squad at a certain position in the group.
--- This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_CountDeSpawned().
---@param group SGroup
---@param int number
---@return unknown
function SGroup_GetDeSpawnedSquadAt(group, int) end

--- Get the entity id of the building that any squad of the sgroup is garrisoned in
---@param groupid SGroup
---@return unknown
function SGroup_GetGarrisonedBuildingEntity(groupid) end

--- Gets all the entities that an SGroup may occupy and adds them to the EGroupHold
---@param sgroup SGroup
---@param EGroupHold EGroup
---@return unknown
function SGroup_GetHoldEGroup(sgroup, EGroupHold) end

--- Gets all the squads that an SGroup may occupy and adds them to the SGroupHold
---@param sgroup SGroup
---@param SGroupHold SGroup
---@return unknown
function SGroup_GetHoldSGroup(sgroup, SGroupHold) end

--- Check invulnerablity state for ALL or ANY squads in a squad group.
--- Set all param to true to check for ALL or set to false to check for ANY.
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_GetInvulnerable(sgroup, all) end

--- Gets the last attacker(s) for all the squads in an SGroup Gets the last attacker for all the squads in an SGroup and stores that in SGroupAttacker
---@param SGroupVictim SGroup
---@param SGroupAttacker SGroup
---@param seconds number | nil
---@return unknown
function SGroup_GetLastAttacker(SGroupVictim, SGroupAttacker, seconds) end

--- Get the squad id of the vehicle squad that any squad of the sgroup is loaded in
---@param groupid SGroup
---@return unknown
function SGroup_GetLoadedVehicleSquad(groupid) end

--- Returns the name of a given squad group.
---@param sgroup SGroup
---@return unknown
function SGroup_GetName(sgroup) end

--- Get the number of slot items with the same ID that the squads in the sgroup own
---@param group SGroup
---@param itemID number
---@return unknown
function SGroup_GetNumSlotItem(group, itemID) end

--- Returns a position (a certain distance away) relative to a squad's current position/orientation. see ScarUtil.scar for explanation of 'offset' parameter
---@param sgroup SGroup
---@param offset number
---@param value number
---@return unknown
function SGroup_GetOffsetPosition(sgroup, offset, value) end

--- Returns the center position of a squad group.
--- Despawned squads are ignored.
---@param group SGroup
---@return unknown
function SGroup_GetPosition(group) end

--- Get a random spawned squad from sgroup
---@param sgroupid SGroup
---@return unknown
function SGroup_GetRandomSpawnedSquad(sgroupid) end

--- Gets the amount of resource type for a squad.
--- If SGroup contains multiple squads, it will be the total of all
---@param sgroup SGroup
---@param resource ResourceType
---@return unknown
function SGroup_GetResource(sgroup, resource) end

--- Builds a table of SGroupIDs that are named in a sequence. i.e. a name of "sg_killer" will find groups "sg_killer1", "sg_killer2" and so on, up until it looks for a group that isn't there.
---@param name string
---@return unknown
function SGroup_GetSequence(name) end

--- Returns the spawned squad at a certain position in the group.
--- This is a one-based index (use index 1 to get the first squad in the group.) It is an error if index > SGroup_CountSpawned().
---@param group SGroup
---@param int number
---@return unknown
function SGroup_GetSpawnedSquadAt(group, int) end

--- Returns the distance from the centre of the group of the unit that furthest out.
---@param sgroup SGroup
---@return unknown
function SGroup_GetSpread(sgroup) end

--- Returns an sgroup containing all squads held by any squad in an sgroup
---@param sgroup SGroup
---@param sgroupRecipient SGroup
---@return unknown
function SGroup_GetSquadsHeld(sgroup, sgroupRecipient) end

--- Get the suppression level for the first squad in the sgroup
---@param groupid SGroup
---@return unknown
function SGroup_GetSuppression(groupid) end

--- Get the veterancy experience value for the first squad in the sgroup
---@param groupid SGroup
---@return unknown
function SGroup_GetVeterancyExperience(groupid) end

--- Get the veterancy rank for the first squad in the sgroup
---@param groupid SGroup
---@return unknown
function SGroup_GetVeterancyRank(groupid) end

--- Test whether ANY or ALL units in a group have a specified ability
---@param sgroup SGroup
---@param ability number
---@param all boolean
---@return unknown
function SGroup_HasAbility(sgroup, ability, all) end

--- Check if ALL or ANY squads in a sgroup have a leader
--- Set all param to true to check for ALL or set to false to check for ANY.
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_HasLeader(sgroup, all) end

--- Check if ALL or ANY of the squads in a group have a specific blueprint.
--- The blueprint can be a table of blueprints or types (see Squad_HasBlueprint() for details)
---@param sgroup SGroup
---@param blueprint SBP | SquadType | table
---@param all boolean
---@return unknown
function SGroup_HasSquadBlueprint(sgroup, blueprint, all) end

--- Returns true if ANY or ALL of the squads in an SGroup are carrying some kind of team weapon
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_HasTeamWeapon(sgroup, all) end

--- Returns whether ANY or ALL squads in an SGroup have the specified upgrade
---@param sgroup SGroup
---@param upgrade Upgrade
---@param all boolean
---@return unknown
function SGroup_HasUpgrade(sgroup, upgrade, all) end

--- Hide or show all entities in all squads in an SGroup
--- Bool should be true to hide, false to show
---@param sgroup SGroup
---@param hide boolean
---@return unknown
function SGroup_Hide(sgroup, hide) end

--- Increase squad veterancy experience for all squads in the sgroup. Can do silent promotion (no sound/UI). Can skip modifiers, giving you direct control of experience gained.
---@param groupid SGroup
---@param experience number
---@param silent boolean | nil
---@param applyModifiers boolean | nil
---@return unknown
function SGroup_IncreaseVeterancyExperience(groupid, experience, silent, applyModifiers) end

--- Increase squad veterancy rank for all squads in the sgroup. By default, increases rank by 1. Can do silent promotion (no sound/UI. ex: mass rank insrease at mission start)
---@param groupid SGroup
---@param numranks number | nil
---@param silent boolean | nil
---@return unknown
function SGroup_IncreaseVeterancyRank(groupid, numranks, silent) end

--- Same as EGroup_Intersection. Note: You cannot mix squad groups and entity groups.
--- Only squads that are in both groups will be added to 'group'.\n The contents of 'grouptointersect' will not be changed.\n Example: group = (1,2,3,4,5,6)  grouptointersect = (2,4,6,8,10)   --> group will now equal (2,4,6)
---@param group SGroup
---@param grouptointersect SGroup
---@return unknown
function SGroup_Intersection(group, grouptointersect) end

--- Returns true if a named squad group is not empty and its average health is > 0.0
---@param sgroup SGroup
---@return unknown
function SGroup_IsAlive(sgroup) end

--- Returns true if ANY or ALL squads in an SGroup are attack moving.
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsAttackMoving(sgroup, all) end

--- Returns true if ANY or ALL of the squads in an SGroup are camouflaged
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsCamouflaged(sgroup, all) end

--- Checks if ANY or ALL squads in an SGroup are capturing
---@param sgroup SGroup
---@param ALL boolean
---@return unknown
function SGroup_IsCapturing(sgroup, ALL) end

--- Returns true if ALL or ANY squads in a group are currently constructing a building.
--- Set all to true to check for ALL or set to false to check for ANY
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsConstructingBuilding(sgroup, all) end

--- Returns if ANY or ALL members of an SGroup are doing an ability
---@param sgroupid SGroup
---@param ability Ability
---@param all boolean
---@return unknown
function SGroup_IsDoingAbility(sgroupid, ability, all) end

--- Returns true if ALL or ANY squads are attacking within the time.
---@param sgroup SGroup
---@param all boolean
---@param time number
---@return unknown
function SGroup_IsDoingAttack(sgroup, all, time) end

--- Returns true if ANY or ALL of the squads in the SGroup is dug in (or in the process of digging in)
---@param group SGroup
---@param all boolean
---@return unknown
function SGroup_IsDugIn(group, all) end

--- Returns true if a named squad group is empty
---@param sgroup SGroup
---@return unknown
function SGroup_IsEmpty(sgroup) end

--- Returns true if ANY or ALL squads are female
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsFemale(sgroup, all) end

--- Returns whether any entity in an SGroup has a hold on anything
---@param sgroup SGroup
---@return unknown
function SGroup_IsHoldingAny(sgroup) end

--- Checks if ANY or ALL squads in an SGroup are idle
---@param sgroup SGroup
---@param ALL boolean
---@return unknown
function SGroup_IsIdle(sgroup, ALL) end

--- Returns the percentage of the SGroup members that are in cover. Alternatively, specify ANY or ALL as a second parameter to return true/false.
---@param sgroup SGroup
---@param all boolean | nil
---@return unknown
function SGroup_IsInCover(sgroup, all) end

--- Returns true if ALL or ANY squads in a group are infiltrated
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsInfiltrated(sgroup, all) end

--- Checks if ANY or ALL squads in an SGroup are garrisoned in an entity (building)
---@param sgroup SGroup
---@param ALL boolean
---@return unknown
function SGroup_IsInHoldEntity(sgroup, ALL) end

--- Checks if ANY or ALL squads in an SGroup are garrisoned in a squad (transport vehicle)
---@param sgroup SGroup
---@param ALL boolean
---@return unknown
function SGroup_IsInHoldSquad(sgroup, ALL) end

--- Returns true if ANY or ALL squads in an SGroup are moving.
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsMoving(sgroup, all) end

--- Returns true if ANY or ALL (use those keywords) of the squads in the group are present onscreen. You can pass in a percentage of the screen to check, so 0.8 would be a centered rectangle occupying 80% of the screen.
---@param player Player
---@param group SGroup
---@param all boolean
---@param percent number | nil
---@return unknown
function SGroup_IsOnScreen(player, group, all, percent) end

--- Returns true if ANY or ALL of a group is pinned
---@param group SGroup
---@param all boolean
---@return unknown
function SGroup_IsPinned(group, all) end

--- Returns true if ALL or ANY squads in a group are currently calling for reinforcments.
--- Set all to true to check for ALL or set to false to check for ANY
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsReinforcing(sgroup, all) end

--- Returns true if ANY or ALL of the squads in an SGroup are currently retreating
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsRetreating(sgroup, all) end

--- Returns true if ANY or ALL squads are setting demolitions
---@param sgroup SGroup
---@param all boolean
---@return unknown
function SGroup_IsSettingDemolitions(sgroup, all) end

--- Returns true is ANY or ALL of a group is suppressed
---@param group SGroup
---@param all boolean
---@return unknown
function SGroup_IsSuppressed(group, all) end

--- Returns true if ALL or ANY squads are under attack within the time.
---@param sgroup SGroup
---@param all boolean
---@param time number
---@return unknown
function SGroup_IsUnderAttack(sgroup, all, time) end

--- Check if the squads are attacked by the player
---@param group SGroup
---@param attackerplayer Player
---@param duration number
---@return unknown
function SGroup_IsUnderAttackByPlayer(group, attackerplayer, duration) end

--- Returns true if ALL or ANY squads are under attack from a direction within the time. see ScarUtil.scar for types of directions. you can pass in a table of directions
---@param sgroup SGroup
---@param all boolean
---@param offset number
---@param time number
---@return unknown
function SGroup_IsUnderAttackFromDirection(sgroup, all, offset, time) end

--- Returns true if ALL or ANY squads in a group are currently upgrading. You can pass in nil for upgradeid if it doesn't matter what is being upgraded.
--- Set all to true to check for ALL or set to false to check for ANY
---@param sgroup SGroup
---@param blueprint number
---@param all boolean
---@return unknown
function SGroup_IsUpgrading(sgroup, blueprint, all) end

--- Checks if ANY or ALL squads in an SGroup are using an ability
--- Does not check WHAT ability a squad is using.
---@param sgroup SGroup
---@param ALL boolean
---@return unknown
function SGroup_IsUsingAbility(sgroup, ALL) end

--- Check to see if an sgroup still exists without needing the name.
---@param sgroupID number
---@return unknown
function SGroup_IsValid(sgroupID) end

--- Kills all squads in an SGroup. This kills them 'naturally', as opposed to SGroup_DestroyAllSquads() which makes them blink out of existance.
---@param sgroup SGroup
---@return unknown
function SGroup_Kill(sgroup) end

--- Removes an squadron from a group.
---@param group SGroup
---@param squadron Squad
---@return unknown
function SGroup_Remove(group, squadron) end

--- Removes an ability that was previously added by SGroup_AddAbility. You cannot remove static abilities (from AE: squad_ability_ext)
---@param sgroup SGroup
---@param ability number
---@return unknown
function SGroup_RemoveAbility(sgroup, ability) end

--- Remove from the first SGroup all squads contained in the second SGroup. SGroup2 remains untouched.
---@param group SGroup
---@param grouptoremove SGroup
---@return unknown
function SGroup_RemoveGroup(group, grouptoremove) end

--- Removes upgrade(s) from an sgroup
---@param sgroup SGroup
---@param upgrade number
---@return unknown
function SGroup_RemoveUpgrade(sgroup, upgrade) end

--- Respawn all despawned squads in a group.
---@param groupid SGroup
---@return unknown
function SGroup_ReSpawn(groupid) end

--- Restore all current combat plans for the squads in the sgroup
---@param sgroupID SGroup
---@return unknown
function SGroup_RestoreCombatPlans(sgroupID) end

--- Give action points to the squad
---@param sgroup SGroup
---@param actionpoint number
---@return unknown
function SGroup_RewardActionPoints(sgroup, actionpoint) end

--- Trigger animation action for an SGroup. Please only use this for simple animations
---@param sgroupid SGroup
---@param actionName string
---@return unknown
function SGroup_SetAnimatorAction(sgroupid, actionName) end

--- Trigger animation event for an SGroup. Please only use this for simple animations
---@param sgroupid SGroup
---@param eventName string
---@return unknown
function SGroup_SetAnimatorEvent(sgroupid, eventName) end

--- Set animation state of a state machine for an SGroup. Please only use this for simple animations
---@param sgroupid SGroup
---@param stateMachineName string
---@param stateName string
---@return unknown
function SGroup_SetAnimatorState(sgroupid, stateMachineName, stateName) end

--- Sets whether a weapon will auto-target things or not
---@param group SGroup
---@param hardpoint number
---@param enable boolean
---@return unknown
function SGroup_SetAutoTargetting(group, hardpoint, enable) end

--- Sets the health of each squad in a squad group to a given percent [0.0, 1.0].
---@param sgroup SGroup
---@param healthpercent number
---@return unknown
function SGroup_SetAvgHealth(sgroup, healthpercent) end

--- Sets the moral of each squad in a squad group to a given percent [0.0, 1.0].
---@param sgroup SGroup
---@param moralepercent number
---@return unknown
function SGroup_SetAvgMorale(sgroup, moralepercent) end

--- Overrides crushable behavior for an sgroup
---@param sgroup SGroup
---@param crushable boolean
---@return unknown
function SGroup_SetCrushable(sgroup, crushable) end

--- Enable/Disable invulnerablity for an entire SGroup. Use true and false for simple on/off, or use a number between 0.0 and 1.0 for more precise control on how much damage a squad can take before it takes no more.
--- The optional reset_time is used to automatically remove invulnerability after a set time. If invulnerable, both health damage is disabled.
---@param sgroup SGroup
---@param enabled boolean
---@param reset_time number | nil
---@return unknown
function SGroup_SetInvulnerable(sgroup, enabled, reset_time) end

--- Set soldier mood mode. Mode could be MM_Auto, MM_ForceCalm or MM_ForceTense
---@param group SGroup
---@param mode number
---@return unknown
function SGroup_SetMoodMode(group, mode) end

--- Changes the player owner of spawned and despawned squads in an SGroup.
---@param sgroup SGroup
---@param owner Player
---@return unknown
function SGroup_SetPlayerOwner(sgroup, owner) end

--- Sets all squads in as sgroup to be recrewable or not when abandoned
---@param sgroup SGroup
---@param recrewable boolean
---@return unknown
function SGroup_SetRecrewable(sgroup, recrewable) end

--- Sets the amount of resource type for a squad.
--- If SGroup contains multiple squads, it will set for all
---@param sgroup SGroup
---@param resource ResourceType
---@param amount number
---@return unknown
function SGroup_SetResource(sgroup, resource, amount) end

--- Set player selectable state of squads in the sgroup
---@param sgroupid SGroup
---@param selectable boolean
---@return unknown
function SGroup_SetSelectable(sgroupid, selectable) end

--- Enables shared team production on a building (teammates can build using THEIR resources)
---@param egroup SGroup
---@param enable boolean
---@return unknown
function SGroup_SetSharedProductionQueue(egroup, enable) end

--- Set the suppression level for all squads in the sgroup
---@param groupid SGroup
---@param suppression number
---@return unknown
function SGroup_SetSuppression(groupid, suppression) end

--- Set team weapon in the squads to be capturable or not
---@param group SGroup
---@param enable boolean
---@return unknown
function SGroup_SetTeamWeaponCapturable(group, enable) end

--- Sets the visibility of in-game veterancy art for the squads in given SGroup
---@param groupid SGroup
---@param visible boolean
---@return unknown
function SGroup_SetVeterancyDisplayVisibility(groupid, visible) end

--- Makes an sgroup neutral
---@param sgroup SGroup
---@return unknown
function SGroup_SetWorldOwned(sgroup) end

--- Creates a squad group containing a single squad
--- Creates an SGroup containing just one squad, creating the group if it doesn't exist and clearing it if it does. It returns the name of the SGroup.
---@param groupID SGroup
---@param squad Squad
---@return unknown
function SGroup_Single(groupID, squad) end

--- Makes two SGroups face each other at no time
---@param sgroup1 SGroup
---@param sgroup2 SGroup
---@return unknown
function SGroup_SnapFaceEachOther(sgroup1, sgroup2) end

--- Suggests a posture to an SGroup, lasting the passed duration
--- Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing.  Duration is in seconds, negative means indefinite.
---@param sgroup SGroup
---@param posture number
---@param duration number
---@return unknown
function SGroup_SuggestPosture(sgroup, posture, duration) end

--- Returns the total count of all members of all the squads in a given SGroup.
---@param sgroup SGroup
---@param dontCountTeamWeapons boolean
---@return unknown
function SGroup_TotalMembersCount(sgroup, dontCountTeamWeapons) end

--- Warps all members of an SGroup immediately to a marker
---@param sgroup SGroup
---@param marker Marker
---@return unknown
function SGroup_WarpToMarker(sgroup, marker) end

--- Warps all members of an SGroup immediately to a new position
---@param sgroup SGroup
---@param pos Position
---@return unknown
function SGroup_WarpToPos(sgroup, pos) end

--- Grabs the selected squads/entities and returns them in a group. Only works with -dev.
--- Tries to return an SGroup first. If it's empty, it will return an EGroup. (Both types can't be selected at the same time)
---@param subselect boolean
---@return unknown
function Util_Grab(subselect) end

--- for the cheat menu
---@return unknown
function Sound_ForceMusicEnabled() end

--- Force set the combat intensity to be at least combatIntensity for a duration.
--- Use a duration of -1 for an indefinite override. Use a duration of 0 to cancel the override. Does not trigger any music events.
---@param combatIntensity number
---@param durationSeconds number
---@return unknown
function Sound_ForceSetMinimumMusicCombatIntensity(combatIntensity, durationSeconds) end

--- for the cheat menu
---@return unknown
function Sound_ForceSilenceEnabled() end

--- stops the music immediately and go into silence.
---@return unknown
function Sound_MusicStop() end

--- Play a speech event based on the local player's race.
---@param eventName string
---@param eventArgs number
---@return unknown
function Sound_PlaySpeech(eventName, eventArgs) end

--- Play a speech event based on a player's race.
---@param player Player
---@param eventName string
---@param eventArgs number
---@return unknown
function Sound_PlaySpeechForPlayer(player, eventName, eventArgs) end

--- tells the music system if it should be trying to enter/stay in the playing music state
---@param value boolean
---@return unknown
function Sound_SetForceMusic(value) end

--- tells the music system if it should be trying to enter/stay in the silent state
---@param value boolean
---@return unknown
function Sound_SetForceSilence(value) end

--- Prevents the music system from automatically switching between layers and stopping for the duration.
---@param durationSecs number
---@return unknown
function Sound_SetManualMusicSelectDuration(durationSecs) end

--- Set the target combat intensity to at least the value of value combatIntensity for a duration.
--- Use a duration of -1 for an indefinite override. Use a duration of 0 to cancel the override.
---@param combatIntensity number
---@param durationSeconds number
---@return unknown
function Sound_SetMinimumMusicCombatIntensity(combatIntensity, durationSeconds) end

--- sets the scaling multiplier for the music intensity value
---@param scale number
---@return unknown
function Sound_SetMusicIntensityScaling(scale) end

--- sets the race rtpc for controlling what race's music gets played
---@param raceCode string
---@return unknown
function Sound_SetMusicRaceCode(raceCode) end

--- stops the music immediately and go into silence.
---@param outroEvent string
---@return unknown
function Sound_StartMusicOutro(outroEvent) end

--- Try to group the squads, returning the squads in groupings that are at least the ideal squad range apart
---@param _not boolean
---@param smallvector_SGroup SGroup
---@param sgroup SGroup
---@param spawnedOnly boolean
---@param idealSquadRadius number
---@return unknown
function separated(_not, smallvector_SGroup, sgroup, spawnedOnly, idealSquadRadius) end

--- Try group the given list of squads into clusters and returns the average distance between these clusters.  Returns -1 if any error occurs.
---@param sgroup SGroup
---@param spawnedOnly boolean
---@param numClusters number
---@return unknown
function SGroup_CalculateClusterSeparation(sgroup, spawnedOnly, numClusters) end

--- Works like Squad_FacePosition.  All Squads will face the same direction, with the squad the closest to the center determining the direction.
--- This function works on spawned squads only.
---@param sgroup SGroup
---@param pos Position
---@return unknown
function SGroup_FacePosition(sgroup, pos) end

--- Works like SGroup_FacePosition except with no interpolation.  All Squads will face the same direction, with the squad the closest to the center determining the direction.
--- This function works on spawned squads only.
---@param sgroup SGroup
---@param pos Position
---@return unknown
function SGroup_SnapFacePosition(sgroup, pos) end

--- Allows the squad to use this ability
---@param squad Squad
---@param ability Ability
---@return unknown
function Squad_AddAbility(squad, ability) end

--- Add resources of all types to the specified squad by the specified amount, specifically to the SquadResourceExt.
---@param squad Squad
---@param amount number
---@return unknown
function Squad_AddAllResources(squad, amount) end

--- Add to the list of slot items to drop when this squad is wiped out
--- Drop chance is percentage chance the item will drop (0.0-1.0) exlusive means the squad would only drop this item, thus erasing all previous items in list example:	local item = Util_GetSlotItemID( "slot_item/allies_m9bazooka.lua" ) Squad_AddSlotItemToDropOnDeath( squadid, item, false )
---@param squad Squad
---@param pbg ScarSlotItemPBG
---@param dropChance number
---@param exclusive boolean
---@return unknown
function Squad_AddSlotItemToDropOnDeath(squad, pbg, dropChance, exclusive) end

--- Advance ability cooldown
---@param squad Squad
---@param tickAmount number
---@return unknown
function Squad_AdjustAbilityCooldown(squad, tickAmount) end

--- Check if squad can attack target
---@param attacker Squad
---@param target Entity
---@param checkFOW boolean
---@param checkVis boolean
---@return unknown
function Squad_CanAttackEntity(attacker, target, checkFOW, checkVis) end

--- Returns true if squad can capture stategic point
---@param squad Squad
---@param entity Entity
---@return unknown
function Squad_CanCaptureStrategicPoint(squad, entity) end

--- True if the squad can capture the entity sync weapon
---@param pSquad Squad
---@param pEntity Entity
---@return unknown
function Squad_CanCaptureTeamWeapon(pSquad, pEntity) end

--- Test whether a squad can be ordered to do this ability on any member of the target EGroup
---@param caster Squad
---@param ability number
---@param target_egroup EGroup
---@return unknown
function Squad_CanCastAbilityOnEGroup(caster, ability, target_egroup) end

--- Test whether a squad can be ordered to do this ability on the target squad
---@param castingSquad Squad
---@param abilityPBG Ability
---@param targetEntity Entity
---@return unknown
function Squad_CanCastAbilityOnEntity(castingSquad, abilityPBG, targetEntity) end

--- Test whether a squad can be ordered to do this ability on the target squad
---@param castingSquad Squad
---@param abilityPBG Ability
---@param targetPos Position
---@return unknown
function Squad_CanCastAbilityOnPosition(castingSquad, abilityPBG, targetPos) end

--- Test whether a squad can be ordered to do this ability on any member of the target SGroup
---@param caster Squad
---@param ability number
---@param target_sgroup SGroup
---@return unknown
function Squad_CanCastAbilityOnSGroup(caster, ability, target_sgroup) end

--- Test whether a squad can be ordered to do this ability on the target squad
---@param castingSquad Squad
---@param abilityPBG Ability
---@param targetSquad Squad
---@return unknown
function Squad_CanCastAbilityOnSquad(castingSquad, abilityPBG, targetSquad) end

--- Cancels an item in a production queue.  Index 0 is the currently producing item.
---@param squad Squad
---@param index number
---@return unknown
function Squad_CancelProductionQueueItem(squad, index) end

--- Checks whether a squad can hold any squad
---@param squad Squad
---@return unknown
function Squad_CanHold(squad) end

--- Returns true if the squad is available to be reinforced
---@param squad Squad
---@return unknown
function Squad_CanInstantReinforceNow(squad) end

--- Checks whether a squad can load another squad
---@param squad Squad
---@param loadthis Squad
---@param assumeEmpty boolean
---@param assumeVisible boolean
---@return unknown
function Squad_CanLoadSquad(squad, loadthis, assumeEmpty, assumeVisible) end

--- True if the squad can pickup the entity slot item
---@param pSquad Squad
---@param pEntity Entity
---@return unknown
function Squad_CanPickupSlotItem(pSquad, pEntity) end

--- True if the squad can recrew the entity
---@param pSquad Squad
---@param pEntity Entity
---@return unknown
function Squad_CanRecrew(pSquad, pEntity) end

--- Returns true if the distance between a target entity and the source squad is less than it squad's sight distance.  There is no LOS or FOW check.
--- Try Player_CanSeeEntity() if you care about LOS or FOW.
---@param squad Squad
---@param entity Entity
---@return unknown
function Squad_CanSeeEntity(squad, entity) end

--- Returns true if the distance between a target squad and the source squad is less than it squad's sight distance.  There is no LOS or FOW check.
--- Try Player_CanSeeSquad() if you care about LOS or FOW.
---@param squad Squad
---@param target Squad
---@return unknown
function Squad_CanSeeSquad(squad, target) end

--- Check if a squad can target and attack a given entity.
---@param squad Squad
---@param target Entity
---@param checkFOW boolean
---@return unknown
function Squad_CanTargetEntity(squad, target, checkFOW) end

--- Check if a squad can target and attack at least one entity in the given target squad.
---@param squad Squad
---@param target Squad
---@param checkFOW boolean
---@return unknown
function Squad_CanTargetSquad(squad, target, checkFOW) end

--- Clears any previous posture suggestions made to a squad
---@param squad Squad
---@return unknown
function Squad_ClearPostureSuggestion(squad) end

--- Clears a TargetHandle value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_ClearStateModelEnumTableTarget(squad, key, tableRowIndex) end

--- Clears a TargetHandle value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_ClearStateModelTarget(squad, key) end

--- Instantly adds an upgrade to a given squad
---@param pSquad Squad
---@param upgradePBG Upgrade
---@return unknown
function Squad_CompleteUpgrade(pSquad, upgradePBG) end

--- Returns the number of units currently in a squad (spawned AND despawned!!)
---@param squad Squad
---@return unknown
function Squad_Count(squad) end

--- Despawn the entire squad at its current position.
---@param squad Squad
---@return unknown
function Squad_DeSpawn(squad) end

--- Remove an squad from the world and destroy it.
---@param squad Squad
---@return unknown
function Squad_Destroy(squad) end

--- Sets whether a squad can produce anything (including upgrades)
---@param squad Squad
---@param enable boolean
---@return unknown
function Squad_EnableProductionQueue(squad, enable) end

--- Enables or disables the surprise feature on thie given squad
---@param squad Squad
---@param enable boolean
---@return unknown
function Squad_EnableSurprise(squad, enable) end

--- Returns total squad extension count.
---@return unknown
function Squad_ExtensionCount() end

--- Returns a string name of the given extension on the squad.
---@param pSquad Squad
---@param extID ComponentDependencyIndex
---@return unknown
function Squad_ExtensionName(pSquad, extID) end

--- Set the rotation of all units in a squad to face the position.
--- The center of the squad will face the position and all other troops will use the same rotation as the from center vector.\n\n This function works on spawned squads only.
---@param squad Squad
---@param pos Position
---@return unknown
function Squad_FacePosition(squad, pos) end

--- Get 2 squads to face each other. This function works on spawned squads only.
---@param squad1 Squad
---@param squad2 Squad
---@return unknown
function Squad_FaceSquad(squad1, squad2) end

--- Tries to find cover within a certain radius of a position. If no cover is found, it returns the position used for the search.
---@param squad Squad
---@param pos Position
---@param coverSearchRadius number
---@return unknown
function Squad_FindCover(squad, pos, coverSearchRadius) end

--- Tries to find cover within a certain radius of a position, traveling a max distance to get there, and possibly comparing against current position's cover. If no cover is found, it returns the position used for the search.
---@param squad Squad
---@param pos Position
---@param coverSearchRadius number
---@param maxPathDistanceFromGoal number
---@param compareToCurrentCover boolean
---@return unknown
function Squad_FindCoverCompareCurrent(squad, pos, coverSearchRadius, maxPathDistanceFromGoal, compareToCurrentCover) end

--- Get a squad from a mission editor ID.
---@param id number
---@return unknown
function Squad_FromID(id) end

--- Find the squad member current or forced targets. The sgroup is cleared, and any attack target squads found are added to the sgroup. Entity targets like buildings are ignored.
---@param squad Squad
---@param sgroup SGroup
---@return unknown
function Squad_GetAttackTargets(squad, sgroup) end

--- Returns the squad blueprint of the squad (from the attribute editor)
---@param squad Squad
---@return unknown
function Squad_GetBlueprint(squad) end

--- Returns a number representing how good squad cover is -1 for awful, 0 for none, 1 for light, 2 for heavy
---@param squad Squad
---@return unknown
function Squad_GetCoverLevel(squad) end

--- Returns the squad's destination, if it's moving. IMPORTANT: you must only call this function if Squad_HasDestination has returned true.
---@param squad Squad
---@return unknown
function Squad_GetDestination(squad) end

--- Returns the average heading of the spawned units in the squad. The heading is currently a lua table with three entries (x, y, z)
---@param squad Squad
---@return unknown
function Squad_GetHeading(squad) end

--- Returns the current health of a squad.
--- The current health of the squad is the total health of each entity in that squad.
---@param squad Squad
---@return unknown
function Squad_GetHealth(squad) end

--- Returns the max health of the squad.
--- The max health of a squad is the max health of each entity in that squad.  This means that the max health of a squad may change when entities are added or removed from the squad.\n\n
---@param squad Squad
---@return unknown
function Squad_GetHealthMax(squad) end

--- Returns how much of an original squad's health is left, accounting for deaths (ex: a squad of 3 riflemen would be at 50% health, since they started with 6 members) Note: This is the same percentage that the UI uses.
---@param squad Squad
---@param bIncludeBonuses boolean
---@return unknown
function Squad_GetHealthPercentage(squad, bIncludeBonuses) end

--- Returns how much of the squad's health is left as a percentage.
---@param squad Squad
---@param includeBonuses boolean
---@return unknown
function Squad_GetHealthPercentageWithShields(squad, includeBonuses) end

--- Get which building (entity) is the squad garrisoned
--- Error if squad is not garrisoned in a building Please use Squad_IsInHold() to check first
---@param squad Squad
---@return unknown
function Squad_GetHoldEntity(squad) end

--- Get which vehicle (squad) is the squad garrisoned
--- Error if squad is not garrisoned in a vehicle squad Please use Squad_IsInHold() to check first
---@param squad Squad
---@return unknown
function Squad_GetHoldSquad(squad) end

--- Returns an integer containing the unqiue squad ID for this squad.
---@param squad Squad
---@return unknown
function Squad_GetID(squad) end

--- Check if the squad is invulnerable or not
---@param squad Squad
---@return unknown
function Squad_GetInvulnerable(squad) end

--- Returns the number of invulnerable member
---@param squad Squad
---@return unknown
function Squad_GetInvulnerableEntityCount(squad) end

--- Returns squad health min cap or the highest invulnerable min cap percentage from members of the squad.
---@param squad Squad
---@return unknown
function Squad_GetInvulnerableMinCap(squad) end

--- Find the last squad attacker on this squad. If found, the squad is added to the sgroup
---@param squad Squad
---@param sgroup SGroup
---@return unknown
function Squad_GetLastAttacker(squad, sgroup) end

--- Find the squad attackers on this squad from the last seconds specified. The sgroup is cleared, then any squads found are added to the sgroup. Building attackers are ignored.
---@param squad Squad
---@param group SGroup
---@param timeSeconds number
---@return unknown
function Squad_GetLastAttackers(squad, group, timeSeconds) end

--- Find the last entity attacker on this squad. If found, the entity added to egroup
---@param squad Squad
---@param egroup EGroup
---@return unknown
function Squad_GetLastEntityAttacker(squad, egroup) end

--- Returns the max number of units allowed in the squad
---@param squad Squad
---@return unknown
function Squad_GetMax(squad) end

--- Returns the sum of all entities in a squad's resourceDropOffDistance state model value if it exists and the entities have a state model ext.  Otherwise it will return 0.0f
---@param targetSquad Squad
---@return unknown
function Squad_GetMaxEntityDropOffDistance(targetSquad) end

--- Returns the current minimum armor of a squad.
--- The current armor of the squad is the minimum armor amongst all entities in that squad.
---@param squad Squad
---@return unknown
function Squad_GetMinArmor(squad) end

--- Returns the command ID of the most recent queued command on the Squad.
---@param squad Squad
---@return unknown
function Squad_GetMostRecentQueuedCommandID(squad) end

--- Get the number of slot items with the same ID that the squad has
--- example:	local item = Util_GetSlotItemID( "slot_item/allies_m1918_bar.lua" ) Squad_GetNumSlotItem( squadid, item )
---@param squad Squad
---@param pbg ScarSlotItemPBG
---@return unknown
function Squad_GetNumSlotItem(squad, pbg) end

--- Returns a position relative to a squad's current position and orientation. see ScarUtil.scar for explanation of 'offset' parameter.
---@param squad Squad
---@param offset number
---@param distance number
---@return unknown
function Squad_GetOffsetPosition(squad, offset, distance) end

--- Returns the average position of the despawned AND spawned units in the squad.
---@param squad Squad
---@return unknown
function Squad_GetPositionDeSpawned(squad) end

--- Returns the blueprint for a production queue item with index.
---@param squad Squad
---@param index number
---@return unknown
function Squad_GetProductionQueueItem(squad, index) end

--- Returns the production type (PITEM_Upgrade, PITEM_Spawn, PITEM_SquadUpgrade, PITEM_SquadReinforce, PITEM_PlayerUpgrade) for a production queue item with index.
---@param squad Squad
---@param index number
---@return unknown
function Squad_GetProductionQueueItemType(squad, index) end

--- Returns the number of items in the squad's production queue.
--- It is an error to call this function on a squad that does not have a production queue.\n Use Squad_HasProductionQueue to check that the squad has a queue.
---@param squad Squad
---@return unknown
function Squad_GetProductionQueueSize(squad) end

--- Returns the race property bag group for the given squad
---@param squad Squad
---@return unknown
function Squad_GetRace(squad) end

--- Returns how much of the squad's shield is left as a percentage.
---@param squad Squad
---@return unknown
function Squad_GetShieldPercentage(squad) end

--- Returns the ID of the slot item. Use Squad_GetSlotItemCount to determine how many slot items the squad has. The first index is 1
---@param squad Squad
---@param index number
---@return unknown
function Squad_GetSlotItemAt(squad, index) end

--- Returns how many slot items this squad has
---@param squad Squad
---@return unknown
function Squad_GetSlotItemCount(squad) end

--- Returns a table of SlotItem ID's that this squad currently owns
---@param squadid Squad
---@return unknown
function Squad_GetSlotItemsTable(squadid) end

--- returns the Squad that sent the passed squad in a disable state
--- Disable states are: knocked back, stunned, levitate, stasis
---@param pSquad Squad
---@return unknown
function Squad_GetSquadDoingDisableOnSquad(pSquad) end

--- Clear the sgroup, then add all squads held by 'squad' to it
---@param squad Squad
---@param sgroup SGroup
---@return unknown
function Squad_GetSquadsHeld(squad, sgroup) end

--- Returns a boolean value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelBool(squad, key) end

--- Returns an Entity value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelEntityTarget(squad, key) end

--- Returns a boolean value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableBool(squad, key, tableRowIndex) end

--- Returns an Entity value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableEntityTarget(squad, key, tableRowIndex) end

--- Returns a float value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableFloat(squad, key, tableRowIndex) end

--- Returns an integer value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableInt(squad, key, tableRowIndex) end

--- Returns a Player value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTablePlayerTarget(squad, key, tableRowIndex) end

--- Returns a Squad value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableSquadTarget(squad, key, tableRowIndex) end

--- Returns a Vector3f value from the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@return unknown
function Squad_GetStateModelEnumTableVector3f(squad, key, tableRowIndex) end

--- Returns a float value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelFloat(squad, key) end

--- Returns an integer value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelInt(squad, key) end

--- Returns a Player value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelPlayerTarget(squad, key) end

--- Returns a Squad value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelSquadTarget(squad, key) end

--- Returns a Vector3f value from the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@return unknown
function Squad_GetStateModelVector3f(squad, key) end

--- Check current squad suppresion level. Return value from 0 to 1
---@param squad Squad
---@return unknown
function Squad_GetSuppression(squad) end

--- Gets the mobile driver squad from a vehicle squad
---@param pSquad Squad
---@return unknown
function Squad_GetVehicleMobileDriverSquad(pSquad) end

--- Get current squad veterancy
---@param squad Squad
---@return unknown
function Squad_GetVeterancy(squad) end

--- Get current squad veterancy rank.
---@param squad Squad
---@return unknown
function Squad_GetVeterancyRank(squad) end

--- Gives a slot item to the squad. Can fail due to not enough slots left
---@param squad Squad
---@param pbg ScarSlotItemPBG
---@return unknown
function Squad_GiveSlotItem(squad, pbg) end

--- Gives all slot items in a table to the squad. The table should come from Squad_GetSlotItemsTable
---@param squadid Squad
---@param itemTable LuaTable
---@return unknown
function Squad_GiveSlotItemsFromTable(squadid, itemTable) end

--- Tests to see if a squad has an ability
---@param squad Squad
---@param ability Ability
---@return unknown
function Squad_HasAbility(squad, ability) end

--- Returns true if there's an active command currently for the squad
---@param squad Squad
---@return unknown
function Squad_HasActiveCommand(squad) end

--- Checks whether a squad is of any of the Blueprints or SquadTypes specified.
--- Blueprint can be a single Blueprint, a single SquadType, or a table of multiple Blueprints or SquadTypes. If you want to see if a squad has ALL of a set of SquadTypes, then wrap them all in a sub-table.
---@param squad Squad
---@param blueprints SBP | SquadType | table
---@return unknown
function Squad_HasBlueprint(squad, blueprints) end

--- Returns true if the given squad has a building in it (includes team weapons)
---@param pSquad Squad
---@return unknown
function Squad_HasBuilding(pSquad) end

--- Returns whether this squad is moving and has a destination, it will not return true on the same tick that the move request is issued
---@param squad Squad
---@return unknown
function Squad_HasDestination(squad) end

--- Returns if squad contains an entity with at least minAttachedCount attached interactibles of interactionTypeName type
---@param targetSquad Squad
---@param interactionTypeName string
---@param minAttachedCount number
---@return unknown
function Squad_HasEntityWithNInteractors(targetSquad, interactionTypeName, minAttachedCount) end

--- Returns true if the given squad has a heavy weapon (non moving setup weapon)
---@param pSquad Squad
---@return unknown
function Squad_HasHeavyWeapon(pSquad) end

--- Returns true if the given squad has at least one infantry unit in it (includes team weapons)
---@param pSquad Squad
---@return unknown
function Squad_HasInfantry(pSquad) end

--- Returns true if a squad has a production queue.
---@param squad Squad
---@return unknown
function Squad_HasProductionQueue(squad) end

--- Returns true if the given squad has team weapon setup for attack
---@param pSquad Squad
---@return unknown
function Squad_HasSetupTeamWeapon(pSquad) end

--- Check if a squad has a specific slot item
---@param squad Squad
---@param slotItem SlotItemID
---@return unknown
function Squad_HasSlotItem(squad, slotItem) end

--- Returns true if the given squad has a team weapon
---@param pSquad Squad
---@return unknown
function Squad_HasTeamWeapon(pSquad) end

--- Return true if the squad has purchased the specified upgrade.
---@param squad Squad
---@param pbg Upgrade
---@return unknown
function Squad_HasUpgrade(squad, pbg) end

--- Returns true if the given squad has a vehicle in it (includes team weapons)
---@param pSquad Squad
---@return unknown
function Squad_HasVehicle(pSquad) end

--- Returns true if the given squad has at least one Entity who has the specified weapon hardpoint.
---@param pSquad Squad
---@param hardPointName string
---@return unknown
function Squad_HasWeaponHardpoint(pSquad, hardPointName) end

--- Increase current squad veterancy
---@param squad Squad
---@param veterancy number
---@param silent boolean
---@param applyModifiers boolean
---@return unknown
function Squad_IncreaseVeterancy(squad, veterancy, silent, applyModifiers) end

--- Increase current squad veterancy rank
---@param squad Squad
---@param numranks number
---@param silent boolean
---@return unknown
function Squad_IncreaseVeterancyRank(squad, numranks, silent) end

--- Stops current squads activity and instant setup the team weapon if they have one
---@param squad Squad
---@return unknown
function Squad_InstantSetupTeamWeapon(squad) end

--- True if the ability is active
---@param squad Squad
---@param pbg Ability
---@return unknown
function Squad_IsAbilityActive_CS(squad, pbg) end

--- Check if the squad is alive
---@param squad Squad
---@return unknown
function Squad_IsAlive(squad) end

--- Returns true if any unit in the squad is attacking within the time
--- Time is in seconds
---@param squad Squad
---@param time number
---@return unknown
function Squad_IsAttacking(squad, time) end

--- Returns true if the squad is currently attack-moving.
---@param squad Squad
---@return unknown
function Squad_IsAttackMoving(squad) end

--- Returns whether ANY entity in the squad is camouflaged
---@param squad Squad
---@return unknown
function Squad_IsCamouflaged(squad) end

--- Returns true if the squad is currently capturing.
---@param squad Squad
---@return unknown
function Squad_IsCapturing(squad) end

--- Returns true if any spawned entity in the squad is a casualty
---@param squad Squad
---@return unknown
function Squad_IsCasualty(squad) end

--- Returns true if the squad is currently constructing.
---@param squad Squad
---@return unknown
function Squad_IsConstructing(squad) end

--- True if squad is currently performing the given ability
---@param squad Squad
---@param pbg Ability
---@return unknown
function Squad_IsDoingAbility(squad, pbg) end

--- Returns whether the passed in squad is female
---@param squad Squad
---@return unknown
function Squad_IsFemale(squad) end

--- Returns if squad contains an entity that is performing a specific unit role
---@param targetSquad Squad
---@param type number
---@return unknown
function Squad_IsGatheringResourceType(targetSquad, type) end

--- Check if the squad has a hold on anything (use this on vehicles)
---@param squad Squad
---@return unknown
function Squad_IsHoldingAny(squad) end

--- Returns true if Squad is holding position.
---@param squad Squad
---@return unknown
function Squad_IsHoldingPosition(squad) end

--- Returns true if the squad is idling
---@param squad Squad
---@return unknown
function Squad_IsIdle(squad) end

--- Returns whether or not the squad is in the background. Default returns false (if the squad is empty)
---@param pSquad Squad
---@return unknown
function Squad_IsInBackground(pSquad) end

--- Returns true if ALL or ANY troopers in a squad are in cover.
--- Set all to true to check if all troopers are in cover or set to false to check if any.
---@param squadId Squad
---@param all boolean
---@return unknown
function Squad_IsInCover(squadId, all) end

--- Check if the squad is garrisoned in entity (building)
---@param squad Squad
---@return unknown
function Squad_IsInHoldEntity(squad) end

--- Check if the squad is loaded in squad (vehicle
---@param squad Squad
---@return unknown
function Squad_IsInHoldSquad(squad) end

--- Returns true if the squad is in melee combat
---@param pSquad Squad
---@return unknown
function Squad_IsInMeleeCombat(pSquad) end

--- True if the squad is currently being knocked back
---@param squad Squad
---@return unknown
function Squad_IsKnockedBack(squad) end

--- Returns true if any unit in the squad is currently moving
---@param squad Squad
---@return unknown
function Squad_IsMoving(squad) end

--- Determines if this squad is of the given type. Types are defined in squad_type_ext/squad_type_list
---@param squad Squad
---@param type string
---@return unknown
function Squad_IsOfType(squad, type) end

--- Returns true if any entity of a squad (all=false) or the whole (all=true) squad is on walkable wall.
---@param squad Squad
---@param all boolean
---@return unknown
function Squad_IsOnWalkableWall(squad, all) end

--- Returns true if the given squad is owned by the given player
---@param squad Squad
---@param player Player
---@return unknown
function Squad_IsOwnedByPlayer(squad, player) end

--- True if squad is currently pinned
---@param squad Squad
---@return unknown
function Squad_IsPinned(squad) end

--- True if squad is currently pinned or suppressed
---@param squad Squad
---@return unknown
function Squad_IsPinnedOrSuppressed(squad) end

--- Returns true if the squad is currently reinforcing.  This function will return false if the squad does not have a reinforce ext.
---@param squad Squad
---@return unknown
function Squad_IsReinforcing(squad) end

--- Returns true if the squad is retreating
---@param squad Squad
---@return unknown
function Squad_IsRetreating(squad) end

--- Returns true if the given blueprint is of the given type. Types are defined in squad_type_ext/squad_type_list
---@param sbp Squad
---@param type string
---@return unknown
function Squad_IsSBPOfType(sbp, type) end

--- Returns true if the squad is currently placing charges.
---@param squad Squad
---@return unknown
function Squad_IsSettingDemolitions(squad) end

--- Returns true if the supplied squad pbg is a siege unit
---@param pbg Squad
---@return unknown
function Squad_IsSiege(pbg) end

--- True if the squad is currently stunned
---@param squad Squad
---@return unknown
function Squad_IsStunned(squad) end

--- True if squad is currently suppressed
---@param squad Squad
---@return unknown
function Squad_IsSuppressed(squad) end

--- Returns true if any unit in the squad is under attack within the time
--- Time is in seconds
---@param squad Squad
---@param time number
---@return unknown
function Squad_IsUnderAttack(squad, time) end

--- Returns true if squad is under attack by enemy from a particular player
--- Time is in seconds
---@param squad Squad
---@param pAttackerOwner Player
---@param time number
---@return unknown
function Squad_IsUnderAttackByPlayer(squad, pAttackerOwner, time) end

--- Returns true if the squad was under attack from a certain direction (8 offset types, see ScarUtil.scar)
---@param squad Squad
---@param offset number
---@param timeSeconds number
---@return unknown
function Squad_IsUnderAttackFromDirection(squad, offset, timeSeconds) end

--- Returns true if the squad is currently upgrading something specific.
---@param squad Squad
---@param upgrade Upgrade
---@return unknown
function Squad_IsUpgrading(squad, upgrade) end

--- Returns true if the squad is currently upgrading anything.
---@param squad Squad
---@return unknown
function Squad_IsUpgradingAny(squad) end

--- Check if a squad with the given ID can be found in the world
---@param id number
---@return unknown
function Squad_IsValid(id) end

--- Kill whole squad.  Sets health to 0, and triggers death effects.
---@param squad Squad
---@return unknown
function Squad_Kill(squad) end

--- Returns the number of upgrades that this squad has.
---@param squad Squad
---@param upgradePBG Upgrade
---@return unknown
function Squad_NumUpgradeComplete(squad, upgradePBG) end

--- get squad pop cost, use CT_Personnel, CT_Vehicle, CT_Medic for captype
---@param squad Squad
---@param type CapType
---@return unknown
function Squad_Population(squad, type) end

--- Removes an ability that was previously added by Squad_AddAbility. You cannot remove static abilities (from AE: squad_ability_ext)
---@param squad Squad
---@param ability Ability
---@return unknown
function Squad_RemoveAbility(squad, ability) end

--- Removes a slot item from the squad.
---@param squad Squad
---@param index number
---@param bInstantWeaponChange boolean
---@return unknown
function Squad_RemoveSlotItemAt(squad, index, bInstantWeaponChange) end

--- Removes a boolean value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value boolean
---@return unknown
function Squad_RemoveStateModelListBool(squad, key, value) end

--- Removes an Entity TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Entity
---@return unknown
function Squad_RemoveStateModelListEntityTarget(squad, key, value) end

--- Removes a float value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@return unknown
function Squad_RemoveStateModelListFloat(squad, key, value) end

--- Removes an integer value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@return unknown
function Squad_RemoveStateModelListInt(squad, key, value) end

--- Removes a Player TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Player
---@return unknown
function Squad_RemoveStateModelListPlayerTarget(squad, key, value) end

--- Removes a Squad TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Squad
---@return unknown
function Squad_RemoveStateModelListSquadTarget(squad, key, value) end

--- Removes a Vector3f value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Position
---@return unknown
function Squad_RemoveStateModelListVector3f(squad, key, value) end

--- Removes an upgrade from a squad
---@param squad Squad
---@param upgrade Upgrade
---@return unknown
function Squad_RemoveUpgrade(squad, upgrade) end

--- Give squad action points
---@param squad Squad
---@param actionPoint number
---@return unknown
function Squad_RewardActionPoints(squad, actionPoint) end

--- ZERO-BASED get of entity blueprints out of squad blueprint
---@param sbp Squad
---@param index number
---@return unknown
function Squad_SBPEntityAt(sbp, index) end

--- Returns the max number of units allowed in the squad blueprint
---@param sbp Squad
---@return unknown
function Squad_SBPGetMax(sbp) end

--- Trigger animation action for a squad. Please only use this for simple animations
---@param squadid Squad
---@param actionName string
---@return unknown
function Squad_SetAnimatorAction(squadid, actionName) end

--- Trigger animation event for a squad. Please only use this for simple animations
---@param squadid Squad
---@param actionName string
---@return unknown
function Squad_SetAnimatorEvent(squadid, actionName) end

--- Set animation state of a state machine for a squad. Please only use this for simple animations
---@param squadid Squad
---@param stateMachineName string
---@param stateName string
---@return unknown
function Squad_SetAnimatorState(squadid, stateMachineName, stateName) end

--- Sets the squad to be in the background or foreground. By default, all squads are in the foreground
---@param pSquad Squad
---@param isInBackground boolean
---@return unknown
function Squad_SetBackground(pSquad, isInBackground) end

--- Enables or disables the squad's UI extension (which controls all UI elements related to the squad)
---@param pSquad Squad
---@param extID string
---@param enabled boolean
---@return unknown
function Squad_SetExtEnabled(pSquad, extID, enabled) end

--- Set the health of all units in a squad.  Health must be in range [0.0, 1.0]
---@param squad Squad
---@param healthPercent number
---@return unknown
function Squad_SetHealth(squad, healthPercent) end

--- Set invulnerability on the squad. Reset time is in seconds. If it is non-negative, the invulnerability will expire after this time.
---@param squad Squad
---@param enable boolean
---@param reset_time number
---@return unknown
function Squad_SetInvulnerable(squad, enable, reset_time) end

--- Make a squad invulnerable to physical damage when number of members drop to or below specified count.
--- member count, 0 means squad is vulnerable; above 0 means number of alive entities will not go below this count resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever
---@param squad Squad
---@param invEntityCount number
---@param resetTime number
---@return unknown
function Squad_SetInvulnerableEntityCount(squad, invEntityCount, resetTime) end

--- Make a squad invulnerable to physical damage.
--- percentage of 0.0 means squad is vulnerable; percentage of 1.0 sets the squad in god mode resetTime is the time in seconds that vulnerability will be restored.; zero time for reset time means the buff will last forever
---@param squad Squad
---@param minHealthPercentage number
---@param resetTime number
---@return unknown
function Squad_SetInvulnerableMinCap(squad, minHealthPercentage, resetTime) end

--- Set soldier mood mode.
---@param squad Squad
---@param mood SquadCombatBehaviourMoodMode
---@return unknown
function Squad_SetMoodMode(squad, mood) end

--- Sets the squad's move type
---@param squad Squad
---@param movetypePBG ScarMoveTypePBG
---@return unknown
function Squad_SetMoveType(squad, movetypePBG) end

--- Changes the owner of the given squad.
---@param squad Squad
---@param owner Player
---@return unknown
function Squad_SetPlayerOwner(squad, owner) end

--- Moves the squad to a new position and snaps squad members onto grid cell centres.
--- `positionFacingToward` is passed in from the script as the position that they want the squad to face toward.
---@param squad Squad
---@param pos Position
---@param positionFacingToward Position
---@return unknown
function Squad_SetPosition(squad, pos, positionFacingToward) end

--- Moves the squad to an arbitrary new 3D position.
--- Note that the squad will still have the same properties, so any squad that snaps to the terrain (most land based squads) will interpolate to the terrain height immediately after this move. This function should really only be used for skimmers and other units that require the y axis to be specified. Use Squad_SetPosition() otherwise.
---@param squad Squad
---@param pos Position
---@param toward Position
---@return unknown
function Squad_SetPosition3D(squad, pos, toward) end

--- Set entity inside the squad to be recrewable or not when it becomes abandoned
---@param squad Squad
---@param capturable boolean
---@return unknown
function Squad_SetRecrewable(squad, capturable) end

--- This function uses squad resources rather than entity resources. For awarding resources to units, it's best to use Entity_AddResource instead (located in luaentity.cpp).
---@param squad Squad
---@param resourceType number
---@param newAmount number
---@return unknown
function Squad_SetResource(squad, resourceType, newAmount) end

--- Enables shared team production on a building (teammates can build using THEIR resources)
---@param squad Squad
---@param shared boolean
---@return unknown
function Squad_SetSharedProductionQueue(squad, shared) end

--- Sets a boolean value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value boolean
---@return unknown
function Squad_SetStateModelBool(squad, key, value) end

--- Sets an Entity TargetHandle value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Entity
---@return unknown
function Squad_SetStateModelEntityTarget(squad, key, value) end

--- Sets a boolean value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value boolean
---@return unknown
function Squad_SetStateModelEnumTableBool(squad, key, tableRowIndex, value) end

--- Sets an Entity TargetHandle value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value Entity
---@return unknown
function Squad_SetStateModelEnumTableEntityTarget(squad, key, tableRowIndex, value) end

--- Sets a float value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Squad_SetStateModelEnumTableFloat(squad, key, tableRowIndex, value) end

--- Sets an integer value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value number
---@return unknown
function Squad_SetStateModelEnumTableInt(squad, key, tableRowIndex, value) end

--- Sets a Player TargetHandle value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value Player
---@return unknown
function Squad_SetStateModelEnumTablePlayerTarget(squad, key, tableRowIndex, value) end

--- Sets a Squad TargetHandle value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value Squad
---@return unknown
function Squad_SetStateModelEnumTableSquadTarget(squad, key, tableRowIndex, value) end

--- Sets a Vector3f value in the squad's state model corresponding to the given key and table row index (0 based).
---@param squad Squad
---@param key string
---@param tableRowIndex number
---@param value Position
---@return unknown
function Squad_SetStateModelEnumTableVector3f(squad, key, tableRowIndex, value) end

--- Sets a float value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@return unknown
function Squad_SetStateModelFloat(squad, key, value) end

--- Sets an integer value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@return unknown
function Squad_SetStateModelInt(squad, key, value) end

--- Sets a boolean value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value boolean
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListBool(squad, key, value, allowDuplicates) end

--- Sets an Entity TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Entity
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListEntityTarget(squad, key, value, allowDuplicates) end

--- Sets a float value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListFloat(squad, key, value, allowDuplicates) end

--- Sets an integer value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value number
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListInt(squad, key, value, allowDuplicates) end

--- Sets a Player TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Player
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListPlayerTarget(squad, key, value, allowDuplicates) end

--- Sets a Squad TargetHandle value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Squad
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListSquadTarget(squad, key, value, allowDuplicates) end

--- Sets a Vector3f value in the squad's state model list corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Position
---@param allowDuplicates boolean
---@return unknown
function Squad_SetStateModelListVector3f(squad, key, value, allowDuplicates) end

--- Sets a Player TargetHandle value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Player
---@return unknown
function Squad_SetStateModelPlayerTarget(squad, key, value) end

--- Sets a Squad TargetHandle value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Squad
---@return unknown
function Squad_SetStateModelSquadTarget(squad, key, value) end

--- Sets a Vector3f value in the squad's state model corresponding to the given key.
---@param squad Squad
---@param key string
---@param value Position
---@return unknown
function Squad_SetStateModelVector3f(squad, key, value) end

--- Set current squad suppression level. Suppression value range from 0 to 1
---@param squad Squad
---@param percentage number
---@return unknown
function Squad_SetSuppression(squad, percentage) end

--- Turn on/off display of the unit portrait veterancy stars
---@param squad Squad
---@param visible boolean
---@return unknown
function Squad_SetVeterancyDisplayVisibility(squad, visible) end

--- Makes a squad neutral
---@param squad Squad
---@return unknown
function Squad_SetWorldOwned(squad) end

--- Spawn the entire squad at a give  n position
---@param squad Squad
---@param pos Position
---@param spawnType string
---@return unknown
function Squad_Spawn(squad, pos, spawnType) end

--- Spawn the entire squad at a given position
---@param squad Squad
---@param pos Position
---@param toward Position
---@param spawnType string
---@return unknown
function Squad_SpawnToward(squad, pos, toward, spawnType) end

--- Split the squad into 2. The new squad size is specified by the number passed in
--- The new squad size is specified by the number passed in.
---@param squad Squad
---@param int number
---@return unknown
function Squad_Split(squad, int) end

--- Abruptly stops an active ability
---@param squad Squad
---@param ability Ability
---@param bIsEarlyExit boolean
---@return unknown
function Squad_StopAbility(squad, ability, bIsEarlyExit) end

--- Suggests a posture to a squad, lasting the passed duration
--- Posture of 0 is prone, 1 is kneel/crouch, and 2 is standing.  Duration is in seconds, negative means indefinate.
---@param squad Squad
---@param posture number
---@param duration number
---@return unknown
function Squad_SuggestPosture(squad, posture, duration) end

--- Returns the closest free position to the target position for the squad
---@param squad Squad
---@param targetPosition Position
---@return unknown
function Squad_TryFindClosestFreePosition(squad, targetPosition) end

--- Warps a squad immediately to a new position
---@param squad Squad
---@param pos Position
---@return unknown
function Squad_WarpToPos(squad, pos) end

--- Returns true if the Territory contains the given SectorID.
---@param sectorID SectorID
---@return unknown
function Territory_ContainsSectorID(sectorID) end

--- Returns the SectorID of the closest Sector Generator point to the given ScarPosition.
---@param pos3D Position
---@return unknown
function Territory_FindClosestSectorToPoint(pos3D) end

--- Returns a table of SectorIDs that are adjacent to the given SectorID.
---@param sectorID SectorID
---@return unknown
function Territory_GetAdjacentSectors(sectorID) end

--- Returns the primary entity in the given sector, if one exists, and nil otherwise.
---@param sectorID SectorID
---@return unknown
function Territory_GetPrimaryEntityInSector(sectorID) end

--- Returns the sector containing the given ScarPosition.
---@param pos3D Position
---@return unknown
function Territory_GetSectorContainingPoint(pos3D) end

--- Get the creator entity of the sector by sectorID
---@param sectorID SectorID
---@return unknown
function Territory_GetSectorCreatorEntity(sectorID) end

--- Returns the generator point of the given sector, snapped to the surface of the terrain.
---@param sectorID SectorID
---@return unknown
function Territory_GetSectorGeneratorPointOnTerrain(sectorID) end

--- Get the ID of the owner of the sector
---@param sectorID SectorID
---@return unknown
function Territory_GetSectorOwnerID(sectorID) end

--- Returns true if the territory is a HexagonTerritory.
---@return unknown
function Territory_IsHexagonTerritory() end

--- Add the amount of time to the specified timer
---@param timerID number
---@param period number
---@return unknown
function Timer_Add(timerID, period) end

--- Advances the timer by the specified amount of time
---@param timerID number
---@param period number
---@return unknown
function Timer_Advance(timerID, period) end

--- Display (in the console) the amount of time remaining in the specified timer.
---@param timerID number
---@return unknown
function Timer_Display(timerID) end

--- Displays a timer on the screen - You need to call this regularly (i.e. every second) to update the onscreen display. THIS IS A TEMPORARY FUNCTION - WELL GET PROPER UI SUPPORT LATER ON
---@param timerID number
---@return unknown
function Timer_DisplayOnScreen(timerID) end

--- Stop the specified timer.
---@param timerID number
---@return unknown
function Timer_End(timerID) end

--- Returns whether the timer with this ID exists
---@param timerID number
---@return unknown
function Timer_Exists(timerID) end

--- Returns how much time has elapsed since this timer has been started
---@param timerID number
---@return unknown
function Timer_GetElapsed(timerID) end

--- Returns TWO values: minutes and seconds. Provide it a function like Timer_GetRemaining or Timer_GetElapsed
---@param getTimeFunction function
---@param TimerID number
---@return unknown
function Timer_GetMinutesAndSeconds(getTimeFunction, TimerID) end

--- Get the remaining time for the specified timer.
---@param timerID number
---@return unknown
function Timer_GetRemaining(timerID) end

--- Check if the timer is paused.
---@param timerID number
---@return unknown
function Timer_IsPaused(timerID) end

--- Pause the specified timer.
--- Pause and Resume calls are ref-counted: if you have called Pause *twice* on a timer, you will also need to call Resume twice in order to start the timer up again.
---@param timerID number
---@return unknown
function Timer_Pause(timerID) end

--- Resume the specified timer.
--- Pause and Resume calls are ref-counted: if you have called Pause *twice* on a timer, you will also need to call Resume twice in order to start the timer up again. Set the force parameter to true if you want to bypass the refcounting and make sure a timer starts up again.
---@param timerID number
---@param force boolean | nil
---@return unknown
function Timer_Resume(timerID, force) end

--- Start a timer with the specified id, taking the required period ( in seconds )
---@param timerID number
---@param period number
---@return unknown
function Timer_Start(timerID, period) end

--- register two callbacks to a goal. One fires when starts while the other fires when completes.
---@param target_goal_onStart__a_function_with_GoalStartReason_as_argument__E_G__function_OnGoalStart_startReason__onComplete__a_function_with_GoalCompletionReason_as_argument__E_G__function_OnGoalComplete_completeReason_ the
---@return unknown
function Training_AddCallbacksToGoal(target_goal_onStart__a_function_with_GoalStartReason_as_argument__E_G__function_OnGoalStart_startReason__onComplete__a_function_with_GoalCompletionReason_as_argument__E_G__function_OnGoalComplete_completeReason_) end

--- add an extra tag to an existing goal.
---@return unknown
function Training_AddExTagToGoal() end

--- Adds a sequence of goals to the training system, also starting the sequence's timer
---@return unknown
function Training_AddGoalSequence() end

--- Enable/disable goal sequence
--- Also restarts the timer for the goal sequence
---@param goalSequence GoalSequence
---@param enabled boolean
---@return unknown
function Training_EnableGoalSequence(goalSequence, enabled) end

--- Enable/disable goal sequence with given id
---@param id string
---@param enabled boolean
---@return unknown
function Training_EnableGoalSequenceByID(id, enabled) end

--- Terminates a goal sequence
---@return unknown
function Training_EndGoalSequence() end

--- Creates a goal object
--- A goal represents one step in a training sequence. Each goal gets one hint popup. Only one goal hint will be displayed at a time. key is the object to visually anchor the hint to. This can be: - the name of an adornable UI element - an entity - a squad - the pbg of a production button - a squad or entity unique id - UniqueSquadButton will anchor to the hero selection - UniqueRespawningSquadButton will anchor to the respawning hero element - CenterLeftSecondaryInfo will anchor to the information panel left of the command card. data is a table of arbitrary information for use in the isCompletePredicate and is routed to the ui. It should include: Message: Localized text to display on the hint pop-up. Use DataTemplate: template for the UI hint. Options are: - LeftClickTrainingDataTemplate: a box displaying an image of a left clicking mouse and message text - RightClickTrainingDataTemplate: a box displaying an image of a right clicking mouse and message text - PanCameraTrainingDataTemplate: a box displaying an image of a middle clicking mouse and message text - GenericTrainingDataTemplate: a box displaying message text - LargeGenericDataTemplate: a larger box dislpaying message text isComplete predicate to run on the goal. It should return true if and only if the goal is complete.
---@param key string
---@param data table
---@return unknown
function Training_Goal(key, data) end

--- Creates a goal sequence
--- A Goal Sequence represents the a single high-level task to prompt the user to do, composed of one or more goals. The goal sequence will begin when its trigger predicate is met, assuming its ignore and bypass conditions aren't met first. Only one goal sequence will be run at a time. id - unique string id to identify or reference the goal seqeuence repeatMax - if the goal sequence has been completed less than repeatMax times and its triggerPredicate passes, the goal sequence will run again. Infinite if less than 0. remindMax - if the . Infinite if less than 0. trigger - predicate to run on the goal sequence. If it returns true, start the goal sequence. ignore - predicate to run on the goal sequence. If it returns true, don't show the goal sequence even if trigger passes. remind - predicate to run on the goal sequence. It should indicate that the player needs a reminder on how to do the task. If it returns true, show the goal sequence again. bypass - predicate to run on the goal sequence. It should indicate whether the player has completed the goal without prompting. If true, the goal sequence will be ended and its completion count incremented. canRegress - if the complete condition for the current goal in the sequence stops passing, back up to the previous goal goals - list of goals to proceed through to as part of this goal sequence repeatMax and remindMax will be infinite if less than 0.
---@param id string
---@param repeatMax number
---@param remindMax number
---@param goalTriggeredAudioEvent string
---@param completeAudioEvent string
---@return unknown
function Training_GoalSequence(id, repeatMax, remindMax, goalTriggeredAudioEvent, completeAudioEvent) end

--- Send a message to a player with generic type a body
---@param player Player
---@param dest Player
---@param messageType number
---@param message string
---@return unknown
function Command_PlayerBroadcastMessage(player, dest, messageType, message) end

--- Enables or disables the FOW, including out of bound areas and all entities on the map
---@param enable boolean
---@return unknown
function FOW_Enable(enable) end

--- Returns the input enabled flag as an integer.
---@param flag InputEnabledFlag
---@return unknown
function Game_ConvertInputEnabledFlagEnumToInt(flag) end

--- Returns the visibility flag as an integer.
---@param flag VisibilityFlag
---@return unknown
function Game_ConvertVisibilityFlagEnumToInt(flag) end

--- Removes title text displayed with Game_SubTextFade(...) immediately
---@return unknown
function Game_EndSubTextFade() end

--- Removes title text displayed with Game_TextTitleFade(...) immediately
---@return unknown
function Game_EndTextTitleFade() end

--- Returns the input enabled flag.
---@return unknown
function Game_GetInputEnabledFlag() end

--- Get the local player. (should only be used for UI purpose) (not deterministic)
---@return unknown
function Game_GetLocalPlayer() end

--- Get the local player id. (should only be used for UI purpose) (not deterministic)
---@return unknown
function Game_GetLocalPlayerID() end

--- Returns the game's visibility flag.
---@return unknown
function Game_GetVisibilityFlag() end

--- Determine if there is a valid local player. (UI only -- nondeterminstic) (not deterministic)
---@return unknown
function Game_HasLocalPlayer() end

--- Returns whether the game is paused.
---@return unknown
function Game_IsPaused() end

--- Returns true if the we're running the performance test.
---@return unknown
function Game_IsPerformanceTest() end

--- Requests the local player to be set on the next update. (not deterministic)
---@param player Player
---@return unknown
function Game_RequestSetLocalPlayer(player) end

--- Sets the input enabled flag.
---@param flag number
---@return unknown
function Game_SetInputEnabledFlag(flag) end

--- Sets the map explored state for the ExploredAll cheat
---@param player Player
---@return unknown
function Game_SetMapExplored(player) end

--- Set the player color for the world visuals from preset colors defined in tuning_simulation\ui_team_colours.
---@param player target
---@param _Colour_Neutral__ boolean
---@return unknown
function Game_SetPlayerColour(player, _Colour_Neutral__) end

--- Set the player color for the world visuals by slot index from preset colors defined in tuning_simulation\ui_player_colours.
---@param player target
---@param based_player_slot_index unknown
---@return unknown
function Game_SetPlayerSlotColour(player, based_player_slot_index) end

--- Set the player color for the UI from preset colors defined in tuning_simulation\ui_team_colours. Does not affect world visuals.
---@param player target
---@param _Colour_Neutral__ boolean
---@return unknown
function Game_SetPlayerUIColour(player, _Colour_Neutral__) end

--- Set the player color for the UI by slot index from preset colors defined in tuning_simulation\ui_player_colours. Does not affect world visuals.
---@param player target
---@param based_player_slot_index unknown
---@return unknown
function Game_SetPlayerUISlotColour(player, based_player_slot_index) end

--- Sets the visibility of the specified game visibility flag.
---@param flag VisibilityFlag
---@param visible boolean
---@return unknown
function Game_SetVisibility(flag, visible) end

--- Sets the game visibility flag.
---@param flag number
---@return unknown
function Game_SetVisibilityFlag(flag) end

--- Skips all events. Can either delete or skip queued events.
---@param deleteQueued boolean
---@return unknown
function Game_SkipAllEvents(deleteQueued) end

--- Skips the currently playing event (and stops current sound).
---@return unknown
function Game_SkipEvent() end

--- Fade in and out two or three lines of subtext.
--- This function has to support two lines, for backwards compatibility. The 'detail' line is therefore optional.
---@param location string
---@param time string
---@param detail string
---@param _in number
---@param lifetime number
---@param out number
---@return unknown
function Game_SubTextFade(location, time, detail, _in, lifetime, out) end

--- Fade in and out one, two or three lines of subtext with an icon
---@param line_1 string
---@param line_2 string
---@param line3 string
---@param detail string
---@param _in number
---@param lifetime number
---@param out number
---@param icon string
---@return unknown
function Game_SubTextFadeWithIcon(line_1, line_2, line3, detail, _in, lifetime, out, icon) end

--- Shows title text that fades in and out over a specified durations
--- Call UI_TitleDestroy to remove.
---@param text string
---@param fadeIn number
---@param duration number
---@param fadeOut number
---@return unknown
function Game_TextTitleFade(text, fadeIn, duration, fadeOut) end

--- Disable the spotting of enemy entities that may become ghosts in the FoW.
---@return unknown
function Ghost_DisableSpotting() end

--- Enable the spotting of enemy entities that may become ghosts in the FoW.
---@return unknown
function Ghost_EnableSpotting() end

--- Adds a Hint Point that will only appear on Mouseover of the target.
---@param hintText string
---@param hintTarget EGroup
---@param targetRadius number
---@param looping boolean
---@return unknown
function HintMouseover_Add(hintText, hintTarget, targetRadius, looping) end

--- Removes a Mouseover Hint Point from the managing function.
---@param hintText string
---@param hintTarget EGroup
---@return unknown
function HintMouseover_Remove(hintText, hintTarget) end

--- Deprecated.
---@param egroup EGroup
---@param priority number
---@param visible boolean
---@param _function function
---@param dataTemplate string
---@param hint string
---@param arrow boolean
---@param arrowOffset Position
---@param actionType number
---@param iconName string
---@param visibleInFOW boolean
---@return unknown
function HintPoint_AddToEGroup(egroup, priority, visible, _function, dataTemplate, hint, arrow, arrowOffset, actionType, iconName, visibleInFOW) end

--- For internal use only.
---@param entity Entity
---@param priority number
---@param visible boolean
---@param _function function
---@param dataTemplate string
---@param hint string
---@param arrow boolean
---@param arrowOffset Position
---@param objectiveID number
---@param actionType number
---@param iconName string
---@param visibleInFOW boolean
---@return unknown
function HintPoint_AddToEntity(entity, priority, visible, _function, dataTemplate, hint, arrow, arrowOffset, objectiveID, actionType, iconName, visibleInFOW) end

--- For internal use only.
---@param position Position
---@param priority number
---@param visible boolean
---@param _function function
---@param dataTemplate string
---@param hint string
---@param arrow boolean
---@param arrowOffset Position
---@param objectiveID number
---@param actionType number
---@param iconName string
---@param visibleInFOW boolean
---@return unknown
function HintPoint_AddToPosition(position, priority, visible, _function, dataTemplate, hint, arrow, arrowOffset, objectiveID, actionType, iconName, visibleInFOW) end

--- Deprecated.
---@param sgroup SGroup
---@param priority number
---@param visible boolean
---@param _function function
---@param dataTemplate string
---@param hint string
---@param arrow boolean
---@param arrowOffset Position
---@param actionType number
---@param iconName string
---@param visibleInFOW boolean
---@return unknown
function HintPoint_AddToSGroup(sgroup, priority, visible, _function, dataTemplate, hint, arrow, arrowOffset, actionType, iconName, visibleInFOW) end

--- For internal use only.
---@param squad Squad
---@param priority number
---@param visible boolean
---@param _function function
---@param dataTemplate string
---@param hint string
---@param arrow boolean
---@param arrowOffset Position
---@param objectiveID number
---@param actionType number
---@param iconName string
---@param visibleInFOW boolean
---@return unknown
function HintPoint_AddToSquad(squad, priority, visible, _function, dataTemplate, hint, arrow, arrowOffset, objectiveID, actionType, iconName, visibleInFOW) end

--- Clear the hint point arrow facing value.
---@param id number
---@return unknown
function HintPoint_ClearFacing(id) end

--- Removes a hintpoint.
---@param HintPointID number
---@return unknown
function HintPoint_Remove(HintPointID) end

--- Remove all hint points.
---@return unknown
function HintPoint_RemoveAll() end

--- Sets a hintpoint's display offset, which is 3D for world hintpoints and 2D for taskbar binding hintpoints (ignore z)
---@param hintpointID number
---@param x number
---@param y number
---@param z number | nil
---@return unknown
function HintPoint_SetDisplayOffset(hintpointID, x, y, z) end

--- Add a projected offset to the specified hint point.
---@param id number
---@param offset Position
---@return unknown
function HintPoint_SetDisplayOffsetInternal(id, offset) end

--- Face the hint point arrow towards this entity.
---@param id number
---@param entity Entity
---@return unknown
function HintPoint_SetFacingEntity(id, entity) end

--- Face the hint point arrow towards this position.
---@param id number
---@param position Position
---@return unknown
function HintPoint_SetFacingPosition(id, position) end

--- Face the hint point arrow towards this squad.
---@param id number
---@param squad Squad
---@return unknown
function HintPoint_SetFacingSquad(id, squad) end

--- Sets a hintpoint's visibility. Currently, FOW is not accounted for.
---@param HintPointID number
---@param bVisible boolean
---@return unknown
function HintPoint_SetVisible(HintPointID, bVisible) end

--- Show or hide the specified hint point.
---@param id number
---@param visible boolean
---@return unknown
function HintPoint_SetVisibleInternal(id, visible) end

--- Appends the provided EntityIDs to the EGroup
---@param group EGroup
---@param entityIDsEncoded string
---@param includeSquads boolean
---@return unknown
function Misc_AddEntitiesToGroup(group, entityIDsEncoded, includeSquads) end

--- Add another circle in which commands are restricted to.
---@param position Position
---@param radius number
---@return unknown
function Misc_AddRestrictCommandsCircle(position, radius) end

--- Add another marker in which commands are restricted to.
---@param marker Marker
---@return unknown
function Misc_AddRestrictCommandsMarker(marker) end

--- Add another AABB in which commands are restricted to.
---@param minPosition Position
---@param maxPosition Position
---@return unknown
function Misc_AddRestrictCommandsOBB(minPosition, maxPosition) end

--- Appends the provided SquadIDs to the SGroup
---@param group SGroup
---@param entityIDsEncoded string
---@return unknown
function Misc_AddSquadsToGroup(group, entityIDsEncoded) end

--- Returns the enabled/disabled state of the right-click command input.  (not deterministic)
---@return unknown
function Misc_AreDefaultCommandsEnabled() end

--- Clears a specific control group.
---@param groupIndex number
---@return unknown
function Misc_ClearControlGroup(groupIndex) end

--- Clears the current selection.
---@return unknown
function Misc_ClearSelection() end

--- Clears the current sub selection.
---@return unknown
function Misc_ClearSubselection() end

--- Do weapon hit effect on the entity from the view camera origin
--- WeaponID is the property bag group id; if penetrated is set to false, deflection effect would be played instead
---@param entity Entity
---@param pos Position
---@param weaponPBG ScarWeaponPBG
---@param penetrated boolean
---@return unknown
function Misc_DoWeaponHitEffectOnEntity(entity, pos, weaponPBG, penetrated) end

--- Returns contents of a control group (0 to 9). Squads are put into an sgroup, and non-squad entities are put into an egroup.
---@param groupIndex number
---@param squads SGroup
---@param nonSquadEntities EGroup
---@return unknown
function Misc_GetControlGroupContents(groupIndex, squads, nonSquadEntities) end

--- Returns the control group index that this entity belongs to, from 0 to 9, or -1 if none.
---@param entity Entity
---@return unknown
function Misc_GetEntityControlGroup(entity) end

--- Returns a hidden position on path from origin to destination. If there's none, it returns the origin position
--- Possible check types are CheckHiddenFromCamera, CheckHiddenInFOW and CheckHiddenBothCameraFOW Camera check determined by the camera frustum. use cameraPadding to increase the area around the camera when doing the check FOW check requires a valid player ID passed in stepDistance is the interval along the path that the hidden points will be checked ( min is 1 metre ) If no hidden position is found, position ( 0, 0, 0 ) is returned Don't use this for multi-player SCAR script!!
---@param checkType number
---@param origin Position
---@param destination Position
---@param ebpID number
---@param stepDistance number
---@param cameraPadding number
---@param FOWPlayer Player
---@param debugDisplay boolean
---@return unknown
function Misc_GetHiddenPositionOnPath(checkType, origin, destination, ebpID, stepDistance, cameraPadding, FOWPlayer, debugDisplay) end

--- Returns the world position of the mouse on the terrain (not deterministic)
---@return unknown
function Misc_GetMouseOnTerrain() end

--- Returns the entity under the mouse (if any) (not deterministic)
---@return unknown
function Misc_GetMouseOverEntity() end

--- Returns the entity squad under the mouse (if any) (not deterministic)
---@return unknown
function Misc_GetMouseOverSquad() end

--- Clears a given group and adds the current full selection (or subselection if true) to the group.
---@param group EGroup
---@param subselection boolean
---@return unknown
function Misc_GetSelectedEntities(group, subselection) end

--- Clears a given group and adds the current full selection (or subselection if true) to the group.
---@param group SGroup
---@param subselection boolean
---@return unknown
function Misc_GetSelectedSquads(group, subselection) end

--- Returns the default simulation rate.
---@return unknown
function Misc_GetSimDefaultStepsPerSecond() end

--- Returns the current simulation rate.
---@return unknown
function Misc_GetSimRate() end

--- Returns the control group index that this squad belongs to, from 0 to 9, or -1 if none.
---@param squad Squad
---@return unknown
function Misc_GetSquadControlGroup(squad) end

--- Returns true if ANY or ALL of the EGroup is selected
---@param egroup EGroup
---@param all boolean
---@return unknown
function Misc_IsEGroupSelected(egroup, all) end

--- Check if the squad is on screen currently (not deterministic)
---@param entity Entity
---@param percent number
---@return unknown
function Misc_IsEntityOnScreen(entity, percent) end

--- Returns true if the specified entity is currently selected.
---@param entity Entity
---@return unknown
function Misc_IsEntitySelected(entity) end

--- Returns true if the mouse is over an entity (not deterministic)
---@return unknown
function Misc_IsMouseOverEntity() end

--- Returns true if the mouse is over a squad (not deterministic)
---@return unknown
function Misc_IsMouseOverSquad() end

--- Returns the enabled/disabled state of the selection input.  (not deterministic)
---@return unknown
function Misc_IsSelectionInputEnabled() end

--- Returns true if ANY or ALL of the SGroup is selected
---@param sgroup SGroup
---@param all boolean
---@return unknown
function Misc_IsSGroupSelected(sgroup, all) end

--- Check if the entity is on screen currently (not deterministic)
---@param squad Squad
---@param percent number
---@return unknown
function Misc_IsSquadOnScreen(squad, percent) end

--- Returns true if the specified squad is currently selected.
---@param squad Squad
---@return unknown
function Misc_IsSquadSelected(squad) end

--- Remove all command restrictions.
---@return unknown
function Misc_RemoveCommandRestriction() end

--- Set the marker in which commands are restricted to.
---@param marker Marker
---@return unknown
function Misc_RestrictCommandsToMarker(marker) end

--- Select all the entities in an EGroup
---@param egroup EGroup
---@return unknown
function Misc_SelectEGroup(egroup) end

--- Set the full selection to the specified entity.
---@param entity Entity
---@return unknown
function Misc_SelectEntity(entity) end

--- Select (or deselect) all the squads in an SGroup
---@param sgroup SGroup
---@param selected boolean
---@return unknown
function Misc_SelectSGroup(sgroup, selected) end

--- Set the full selection to the specified entity.
---@param squad Squad
---@param selected boolean
---@return unknown
function Misc_SelectSquad(squad, selected) end

--- Enables/disables right-click command input.
---@param enabled boolean
---@return unknown
function Misc_SetDefaultCommandsEnabled(enabled) end

--- Allow all entities in an EGroup to be selectable (or not)
---@param egroup EGroup
---@param selectable boolean
---@return unknown
function Misc_SetEGroupSelectable(egroup, selectable) end

--- Makes an entity belong to a specific control group. If it already belongs to another control group, it's removed from that one before being added to the new one.
---@param entity Entity
---@param groupIndex number
---@return unknown
function Misc_SetEntityControlGroup(entity, groupIndex) end

--- Disable/enable selectability of the specified entity.
---@param entity Entity
---@param selectable boolean
---@return unknown
function Misc_SetEntitySelectable(entity, selectable) end

--- Enables/disables selection input.
---@param enabled boolean
---@return unknown
function Misc_SetSelectionInputEnabled(enabled) end

--- Allow all squads in an SGroup to be selectable (or not)
---@param sgroup SGroup
---@param selectable boolean
---@return unknown
function Misc_SetSGroupSelectable(sgroup, selectable) end

--- Set the simulation rate
---@param rate number
---@return unknown
function Misc_SetSimRate(rate) end

--- Makes a squad belong to a specific control group. If it already belongs to another control group, it's removed from that one before being added to the new one.
---@param squad Squad
---@param groupIndex number
---@return unknown
function Misc_SetSquadControlGroup(squad, groupIndex) end

--- Disable/enable selectability of the specified squad.
---@param squad Squad
---@param selectable boolean
---@return unknown
function Misc_SetSquadSelectable(squad, selectable) end

--- Hide the objective progress panel.
---@return unknown
function Obj_HideProgress() end

--- Hide the specified objective progress panel.
---@param progressBarIndex number
---@return unknown
function Obj_HideProgressEx(progressBarIndex) end

--- Make the objective progress bar blink or stop blinking.
---@param blinking boolean
---@return unknown
function Obj_SetProgressBlinking(blinking) end

--- Show the objective progress panel with a progress bar - call repeatedly to update progress.  Value should be normalized between [0 - 1].
---@param title string
---@param progress number
---@return unknown
function Obj_ShowProgress(title, progress) end

--- Show the objective progress panel with a progress bar - call repeatedly to update progress.  Value should be normalized between [0 - 1].  Appears in center of screen.
---@param title string
---@param progress number
---@return unknown
function Obj_ShowProgress2(title, progress) end

--- Show the specified objective progress panel with a progress bar - call repeatedly to update progress. Value should be normalized between [0 - 1].  If critical, progress bar will pulse.
---@param progressBarIndex number
---@param title string
---@param progress number
---@param critical boolean
---@return unknown
function Obj_ShowProgressEx(progressBarIndex, title, progress, critical) end

--- Show the objective progress panel with a timer icon - call repeatedly to update progress.  Value should be in seconds.
---@param progress number
---@return unknown
function Obj_ShowProgressTimer(progress) end

--- Clears the config changed callback
---@return unknown
function PlayerColour_ClearConfigChangedCallback() end

--- Clear player color overriding and use the "PlayerColour" setting instead.
---@return unknown
function PlayerColour_Disable() end

--- Force enable player color that overrides the current "PlayerColour" setting.
---@return unknown
function PlayerColour_Enable() end

--- Sets a callback firing when user changes the config for player colour
---@param _function function
---@return unknown
function PlayerColour_SetConfigChangedCallback(_function) end

--- Prematurely finish all queued speech
--- This is useful for skipping all speech events that may have been queued
---@return unknown
function Subtitle_EndAllSpeech() end

--- Prematurely finish currently playing speech and advance the next one in queue
--- This is useful for skipping speech events
---@return unknown
function Subtitle_EndCurrentSpeech() end

--- Plays a narrative event as a series of subtitled speech transitions when given the event's reflect ID.
--- Pass in the reflect ID (make sure it is represented as an integer) of a NarrativeEvent which is authored in a NarrativeCollection data object. This function will add a wait object which will terminate when all transitions are complete.
---@param str string
---@return unknown
function Subtitle_PlayNarrativeEvent(str) end

--- Plays a global speech with subtitle and actor icon specified in the narrative line with given ID.
--- The line should be present in an authorable narrative collection and referenced by the reflect ID Adds a wait object if successful. Returns the title ID, call UI_TitleDestroy to remove.
---@param str string
---@return unknown
function Subtitle_PlayNarrativeLine(str) end

--- Plays a global speech with subtitle and actor icon in the overlay with speech bubbles on squad decorators.
--- localization id is used for both subtitle text and speech If the speech file is 3D, make sure that is3D is set to true. Shows speech bubble indicator on squad decorator. Call UI_TitleDestroy to remove.
---@param briefingActorPBG ScarBriefingActorPBG
---@param loc string
---@param disableIconSubtitle boolean
---@param audioCtrlEvent string
---@param squad Squad
---@param is3D boolean
---@return unknown
function Subtitle_PlaySpeechForSquadFromLocString(briefingActorPBG, loc, disableIconSubtitle, audioCtrlEvent, squad, is3D) end

--- Plays a global speech with subtitle and actor icon in the overlay
--- localization id is used for both subtitle text and speech please make sure that the the speech file is 2D Call UI_TitleDestroy to remove.
---@param briefingActorPBG ScarBriefingActorPBG
---@param loc string
---@param disableIconSubtitle boolean
---@param audioCtrlEvent string
---@param squad Squad
---@param is3D boolean
---@return unknown
function Subtitle_PlaySpeechInternal(briefingActorPBG, loc, disableIconSubtitle, audioCtrlEvent, squad, is3D) end

--- Removes "sticky" state from currently playing speech (if any)
---@return unknown
function Subtitle_UnstickCurrentSpeech() end

--- Send a player ability command (PCMD_Ability) to a player.
--- Only use this function from code which is executed for a single player (such as UI button callbacks).
---@param player Player
---@param dest Player
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function SynchronizedCommand_PlayerAbility(player, dest, abilityPBG, skipCostAndPrereq) end

--- Send a positional ability command (PCMD_Ability) to a player
--- Only use this function from code which is executed for a single player (such as UI button callbacks).
---@param player Player
---@param dest Player
---@param pos Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function SynchronizedCommand_PlayerPosAbility(player, dest, pos, abilityPBG, skipCostAndPrereq) end

--- Send a positional/directional ability command (PCMD_Ability) to a player
--- Only use this function from code which is executed for a single player (such as UI button callbacks).
---@param player Player
---@param dest Player
---@param pos Position
---@param dir Position
---@param abilityPBG Ability
---@param skipCostAndPrereq boolean
---@return unknown
function SynchronizedCommand_PlayerPosDirAbility(player, dest, pos, dir, abilityPBG, skipCostAndPrereq) end

--- Returns true if the taskbar is visible. (not deterministic)
---@return unknown
function Taskbar_IsVisible() end

--- Sets taskbar visibility.
---@param visible boolean
---@return unknown
function Taskbar_SetVisibility(visible) end

--- Adds a threat to an existing group
---@param GroupID number
---@param Threat EGroup
---@param icon string | nil
---@return unknown
function ThreatArrow_Add(GroupID, Threat, icon) end

--- Creates a group of threats that are represented by a single arrow. Threats can be entities, squads, egroups, sgroups, positions or markers
---@param dataTemplate string
---@param target1 Marker | Position | Entity | Squad | Group
---@param target2___ Marker | Position | Entity | Squad | Group | nil
---@return unknown
function ThreatArrow_CreateGroup(dataTemplate, target1, target2___) end

--- Destroy all threat groups
---@return unknown
function ThreatArrow_DestroyAllGroups() end

--- Destroy a threat group
---@param GroupID number
---@return unknown
function ThreatArrow_DestroyGroup(GroupID) end

--- Removes a threat from an existing group
---@param GroupID number
---@param Threat EGroup
---@return unknown
function ThreatArrow_Remove(GroupID, Threat) end

--- Creates and flashes an ability button on the taskbar if the unit is selected
--- Length parameter determines how long to flash the item, and the blueprint filter is used if certain squad types need to be selected before flashing the button.
---@param playerid Player
---@param abilityID Ability
---@param text string
---@param length number
---@param blueprint_filter number | nil
---@return unknown
function UI_AddHintAndFlashAbility(playerid, abilityID, text, length, blueprint_filter) end

--- Toggle off all territory lines. Each call to UI_AllTerritoryHide must be matched by a call to UI_AllTerritoryShow
---@return unknown
function UI_AllTerritoryHide() end

--- Toggle on all territory lines. Each call to UI_AllTerritoryShow must be matched by a call to UI_AllTerritoryHide
---@return unknown
function UI_AllTerritoryShow() end

--- DEPRECATED! Removes a message added by UI_AutosaveMessageShow.
---@return unknown
function UI_AutosaveMessageHide() end

--- DEPRECATED! Shows a message indicating that the game is autosaving.
--- DEPRECATED! Call UI_AutosaveMessageHide to remove the message.
---@return unknown
function UI_AutosaveMessageShow() end

--- Toggle off capture-point boundary lines. Each call to UI_CapturePointLinesHide must be matched by a call to UI_CapturePointLinesShow
---@return unknown
function UI_CapturePointLinesHide() end

--- Toggle on capture-point boundary lines. Each call to UI_CapturePointLinesShow must be matched by a call to UI_CapturePointLinesHide
---@return unknown
function UI_CapturePointLinesShow() end

--- Clears an event cue with a specific ID. The ID is obtained as a return value from either UI_CreateEventCueClickable or UI_CreateEventCueClickableByType.
---@param id number
---@return unknown
function UI_ClearEventCueFromID(id) end

--- Clears all active event cues
---@return unknown
function UI_ClearEventCues() end

--- Clears the ability phase callback.
---@return unknown
function UI_ClearModalAbilityPhaseCallback() end

--- Clears the construction phase callback.
---@return unknown
function UI_ClearModalConstructionPhaseCallback() end

--- Clears the construction phase callback.
---@return unknown
function UI_ClearModalHoverCallback() end

--- Clears the try-to-skip-NIS callback
---@return unknown
function UI_ClearSkipNISCallback() end

--- Set the numner of columns in the command card.
---@param columns number
---@return unknown
function UI_CommandCardSetColumns(columns) end

--- Set the numner of rows in the command card.
---@param rows number
---@return unknown
function UI_CommandCardSetRows(rows) end

--- Toggle off cover preview. Each call to UI_CoverPreviewHide must be matched by a call to UI_CoverPreviewShow
---@return unknown
function UI_CoverPreviewHide() end

--- Toggle on cover preview. Each call to UI_CoverPreviewShow must be matched by a call to UI_CoverPreviewHide
---@return unknown
function UI_CoverPreviewShow() end

--- Create a event cue from a sender.
---@param player__Can_be_null__Used_for_retrieving_player_information__E_g__team_color_ sender
---@param type_id event
---@param duration_of_the_event_cue_ visible
---@param repeat_filtering_if___0__Make_the_event_cue_alive_but_not_visible_beyond_its_lifetime_ enable
---@param repeatTime___0__how_many_times_a_event_cue_with_the_same_customEventType_can_be_repeated_during_repeatTime when
---@param repeatTime___0__filter_out_a_event_cue_if_it_s_within_the_range_of_a_existing_one_with_the_same_customEventType when
---@param data_template_of_the_event_cue_ ui
---@param cue_visibility_flags__ECV_None__not_visible_ECV_Queue__visible_in_the_queue_ECV_Title__visible_as_title_ECV_Queue___ECV_Title___both event
---@param cue_visibility_flags_ event
---@param event_cue_visibility_in_action_ECAV_Global_ECAV_ExecuterIsOwnOrAlly_ECAV_ExecuterIsEnemy_ECAV_CanSeeExecutor_ECAV_CanSeeTarget_ECAV_CanEnemySeeExecutor_ECAV_TargetIsOwn_ECAV_TargetIsAlly_ECAV_OwnsTargetAndExecuterIsEnemy_ECAV_AlliedToTargetAndExecuterIsEnemy_ECAV_ExecuterIsOwn_ECAV_ExecuterIsAlly_ECAV_CanSeeTargetAndExecutorIsOwnOrAlly_ECAV_CanSeeTargetAndExecutorIsOwn Control
---@return unknown
function UI_CreateCustomEventCueFrom(player__Can_be_null__Used_for_retrieving_player_information__E_g__team_color_, type_id, duration_of_the_event_cue_, repeat_filtering_if___0__Make_the_event_cue_alive_but_not_visible_beyond_its_lifetime_, repeatTime___0__how_many_times_a_event_cue_with_the_same_customEventType_can_be_repeated_during_repeatTime, repeatTime___0__filter_out_a_event_cue_if_it_s_within_the_range_of_a_existing_one_with_the_same_customEventType, data_template_of_the_event_cue_, cue_visibility_flags__ECV_None__not_visible_ECV_Queue__visible_in_the_queue_ECV_Title__visible_as_title_ECV_Queue___ECV_Title___both, cue_visibility_flags_, event_cue_visibility_in_action_ECAV_Global_ECAV_ExecuterIsOwnOrAlly_ECAV_ExecuterIsEnemy_ECAV_CanSeeExecutor_ECAV_CanSeeTarget_ECAV_CanEnemySeeExecutor_ECAV_TargetIsOwn_ECAV_TargetIsAlly_ECAV_OwnsTargetAndExecuterIsEnemy_ECAV_AlliedToTargetAndExecuterIsEnemy_ECAV_ExecuterIsOwn_ECAV_ExecuterIsAlly_ECAV_CanSeeTargetAndExecutorIsOwnOrAlly_ECAV_CanSeeTargetAndExecutorIsOwn) end

--- Creates an event cue without a callback (you won't know when it's clicked).
---@param title string
---@param description string
---@param data_template string
---@param icon_path string
---@param sound_path string
---@param visibility EventCueVisibility | nil
---@param lifetime number | nil
---@return unknown
function UI_CreateEventCue(title, description, data_template, icon_path, sound_path, visibility, lifetime) end

--- Creates a custom event cue. The Lua function callback passed in takes an ID as an argument which can be used to clear the event cue with UI_ClearEventCueFromID.
---@param customEventType number
---@param lifetime number
---@param repeatCount number
---@param repeatTime number
---@param title string
---@param description string
---@param dataTemplate string
---@param iconPath string
---@param soundPath string
---@param red number
---@param green number
---@param blue number
---@param alpha number
---@param visibility EventCueVisibility
---@param _function function
---@return unknown
function UI_CreateEventCueClickable(customEventType, lifetime, repeatCount, repeatTime, title, description, dataTemplate, iconPath, soundPath, red, green, blue, alpha, visibility, _function) end

--- Creates a named event cue. Returns the ID associated to the created event cue item. This ID can be used to clear the event cue item with UI_ClearEventCueFromID. The Lua function callback passed in takes an ID as an argument which can be used to clear the event cue with UI_ClearEventCueFromID.
---@param eventType UIEventType
---@param lifetime number
---@param title string
---@param description string
---@param dataTemplate string
---@param iconPath string
---@param soundPath string
---@param red number
---@param green number
---@param blue number
---@param alpha number
---@param visibility EventCueVisibility
---@param _function function
---@return unknown
function UI_CreateEventCueClickableByType(eventType, lifetime, title, description, dataTemplate, iconPath, soundPath, red, green, blue, alpha, visibility, _function) end

--- Create a blips on a ScarMarker from a sender. sender is used for retrieving player information like team color
---@param sender Player
---@param marker Marker
---@param lifeTime number
---@param dataTemplate string
---@return unknown
function UI_CreateMinimapBlipOnMarkerFrom(sender, marker, lifeTime, dataTemplate) end

--- Create a blips on a position from a sender. sender is used for retrieving player information like team color
---@param sender Player
---@param position Position
---@param lifeTime number
---@param dataTemplate string
---@return unknown
function UI_CreateMinimapBlipOnPosFrom(sender, position, lifeTime, dataTemplate) end

--- Create a position tag.
---@param scar_position__Won_t_accept_a_position_extremely_close__std__numeric_limits_float___min____to_the_existing_ones_ a
---@return unknown
function UI_CreateTagForPosition(scar_position__Won_t_accept_a_position_extremely_close__std__numeric_limits_float___min____to_the_existing_ones_) end

--- Hides the mouse cursor
---@return unknown
function UI_CursorHide() end

--- Shows the mouse cursor if it has been hidden
---@return unknown
function UI_CursorShow() end

--- Removes a blip already created on the minimap
---@param blipID number
---@return unknown
function UI_DeleteMinimapBlip(blipID) end

--- Destroy a position tag
---@param of_or_extremely_close__std__numeric_limits_float___min____to_an_existing_position__If_there_are_multiple_candidates same
---@param the_closest_ delete
---@return unknown
function UI_DestroyTagForPosition(of_or_extremely_close__std__numeric_limits_float___min____to_an_existing_position__If_there_are_multiple_candidates, the_closest_) end

--- Enable or disable entity decorator. The default is decorator enabled.
---@param entity Entity
---@param enabled boolean
---@return unknown
function UI_EnableEntityDecorator(entity, enabled) end

--- Enable or disable entity minimap indicator. The default is enabled.
---@param entity Entity
---@param enabled boolean
---@return unknown
function UI_EnableEntityMinimapIndicator(entity, enabled) end

--- Enable or disable entity selection visuals. The default is visuals enabled.
---@param entity Entity
---@param enabled boolean
---@return unknown
function UI_EnableEntitySelectionVisuals(entity, enabled) end

--- Enables or disables event cues.
---@param gameEventType GameEventID
---@param enable boolean
---@return unknown
function UI_EnableGameEventCueType(gameEventType, enable) end

--- Enables or disables resource kickers.
---@param resourceType ResourceType
---@param enable boolean
---@return unknown
function UI_EnableResourceTypeKicker(resourceType, enable) end

--- Enable or disable the squad decorator. The default is decorator enabled.
---@param squad Squad
---@param enabled boolean
---@return unknown
function UI_EnableSquadDecorator(squad, enabled) end

--- Enable or disable squad minimap indicator. The default is enabled.
---@param squad Squad
---@param enabled boolean
---@return unknown
function UI_EnableSquadMinimapIndicator(squad, enabled) end

--- Enables or disables event cues.
---@param uiEventType UIEventType
---@param enable boolean
---@return unknown
function UI_EnableUIEventCueType(uiEventType, enable) end

--- Triggers an event cue to start its fadeout animation. The animation is determined in XAML.
---@param id number
---@return unknown
function UI_FadeOutEventCueFromID(id) end

--- Flash an ability command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param ability Ability
---@param stopOnClick boolean
---@return unknown
function UI_FlashAbilityButton(ability, stopOnClick) end

--- Flash a construction item command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param ebp Entity
---@param stopOnClick boolean
---@return unknown
function UI_FlashConstructionButton(ebp, stopOnClick) end

--- Flashes the entity using attributes from [tuning][ui]
---@param entity Entity
---@param actionOnName string
---@return unknown
function UI_FlashEntity(entity, actionOnName) end

--- Flash an entity order command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param command EntityCommandType
---@param stopOnClick boolean
---@return unknown
function UI_FlashEntityCommandButton(command, stopOnClick) end

--- Flash an event cue item.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param eventCueID number
---@param stopOnClick boolean
---@return unknown
function UI_FlashEventCue(eventCueID, stopOnClick) end

--- Flash a menu command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param menuName string
---@param stopOnClick boolean
---@return unknown
function UI_FlashMenu(menuName, stopOnClick) end

--- Flash an objective counter.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param objectiveID number
---@return unknown
function UI_FlashObjectiveCounter(objectiveID) end

--- Flash an objective.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param objectiveID number
---@param stopOnClick boolean
---@return unknown
function UI_FlashObjectiveIcon(objectiveID, stopOnClick) end

--- Flash a production building button.  Pass the return value to UI_StopFlashing to stop flashing the button.
--- Type should match the unit_class of a Production Building in the army bag for the player's race
---@param type string
---@param stopOnClick boolean
---@return unknown
function UI_FlashProductionBuildingButton(type, stopOnClick) end

--- Flash a production item command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param type ProductionItemType
---@param pbg PBG
---@param stopOnClick boolean
---@return unknown
function UI_FlashProductionButton(type, pbg, stopOnClick) end

--- Flash a squad order command button.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param command SquadCommandType
---@param stopOnClick boolean
---@return unknown
function UI_FlashSquadCommandButton(command, stopOnClick) end

--- Flash a button on the USS for this entity.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param entity Entity
---@param stopOnClick boolean
---@return unknown
function UI_FlashUSSEntityButton(entity, stopOnClick) end

--- Flash a button on the USS for this squad.  Pass the return value to UI_StopFlashing to stop flashing the button.
---@param squad Squad
---@param stopOnClick boolean
---@return unknown
function UI_FlashUSSSquadButton(squad, stopOnClick) end

--- Returns the icon name for a given ability
---@param abilityBag Ability
---@return unknown
function UI_GetAbilityIconName(abilityBag) end

--- Returns whether all decorators are enabled or not
---@return unknown
function UI_GetDecoratorsEnabled() end

--- Gets an enum value indicating the visibility of decorators for an entity.
---@param entity Entity
---@return unknown
function UI_GetDecoratorVisibilityEntity(entity) end

--- Gets an enum value indicating the visibility of decorators for a squad.
---@param squad Squad
---@return unknown
function UI_GetDecoratorVisibilitySquad(squad) end

--- Highlights an SGroup in the UI for the given duration
---@param sgroup SGroup
---@param duration number
---@return unknown
function UI_HighlightSGroup(sgroup, duration) end

--- Turn on squad highlight UI feature for the specified duration.
---@param squad Squad
---@param duration number
---@return unknown
function UI_HighlightSquad(squad, duration) end

--- Is a replay match currently.
--- Removed in version 1.9.0. Use UI_IsLiveOrRecordedReplay instead.
---@deprecated
---@return unknown
function UI_IsReplay() end

--- Fades the letterbox to a given RGBA colour over a number of seconds by a given aspect ratio.
--- Call UI_TitleDestroy to remove.
---@param r number
---@param g number
---@param b number
---@param a number
---@param duration number
---@param aspectRatio number
---@param persistent boolean
---@return unknown
function UI_LetterboxFade(r, g, b, a, duration, aspectRatio, persistent) end

--- Create a reticule
---@param reticulePbg ScarReticulePBG
---@param radius number
---@return unknown
function UI_ModalVisual_CreateReticule(reticulePbg, radius) end

--- Destroy a modal visual
---@param id number
---@return unknown
function UI_ModalVisual_Destroy(id) end

--- Brings up a message and arrow pointing to a HUD feature.
--- Accepted parameters are:  HUDF_AbilityCard, HUDF_MiniMap, HUDF_Upgrades, HUDF_CommandCard, HUDF_None Call UI_TitleDestroy to remove.
---@param newHUDFeature HUDFeatureType
---@param featureText string
---@param featureIcon string
---@param duration number
---@return unknown
function UI_NewHUDFeature(newHUDFeature, featureText, featureIcon, duration) end

--- Toggle off terrain out of bounds lines. Each call to UI_OutOfBoundsLinesHide must be matched by a call to UI_OutOfBoundsLinesShow
---@return unknown
function UI_OutOfBoundsLinesHide() end

--- Toggle on terrain out of bounds lines. Each call to UI_OutOfBoundsLinesShow must be matched by a call to UI_OutOfBoundsLinesShowHide
---@return unknown
function UI_OutOfBoundsLinesShow() end

--- Only allow buildings to be placed inside a marker.
---@param marker Marker
---@return unknown
function UI_RestrictBuildingPlacement(marker) end

--- Fades the screen to a given RGBA colour over a number of seconds. mouse input is blocked during the fade, and you can control whether the input keeps being blocked after the fade has ended (be careful!)
--- Call UI_TitleDestroy to remove.
---@param r number
---@param g number
---@param b number
---@param a number
---@param duration number
---@param persistent boolean
---@return unknown
function UI_ScreenFade(r, g, b, a, duration, persistent) end

--- Toggle off sector lines. Each call to UI_SectorsHide must be matched by a call to UI_SectorsShow
---@return unknown
function UI_SectorsHide() end

--- Toggle on sector lines. Each call to UI_SectorsShow must be matched by a call to UI_SectorsHide
---@return unknown
function UI_SectorsShow() end

--- Sets the game to allow allied squads to be selected at the same time as your own squads
---@param allow boolean
---@return unknown
function UI_SetAlliedBandBoxSelection(allow) end

--- Enables or disable load and save features at the pause menu
---@param allowLoadAndSave boolean
---@return unknown
function UI_SetAllowLoadAndSave(allowLoadAndSave) end

--- Sets a callback firing when user select a control group either by hotkey or by control group button
---@param the_format_of_function_controlGroupIndex_ any
---@return unknown
function UI_SetControlGroupSelectedCallback(the_format_of_function_controlGroupIndex_) end

--- Sets the visibility of the Command Point meter.
---@param visible boolean
---@return unknown
function UI_SetCPMeterVisibility(visible) end

--- Enables or disables all decorators
---@param enabled boolean
---@return unknown
function UI_SetDecoratorsEnabled(enabled) end

--- Enable/Disable pause menu showing up when the pause menu hot key is pressed.
---@param isEnable boolean
---@return unknown
function UI_SetEnablePauseMenu(isEnable) end

--- Explicitly set the decorator a squad should use.
---@param entity Entity
---@param decorator string
---@return unknown
function UI_SetEntityDecorator(entity, decorator) end

--- Sets the game to show the entity ghost in a spotted state
---@param entity Entity
---@return unknown
function UI_SetEntityGhostSpottedStaggered(entity) end

--- Sets the game to force show subtitles even if the player has them turned off.
---@param forceShowSubtitles boolean
---@return unknown
function UI_SetForceShowSubtitles(forceShowSubtitles) end

--- Sets the angle of True North for the minimap in degrees
---@param trueNorthAngleDeg number
---@return unknown
function UI_SetMinimapTrueNorth(trueNorthAngleDeg) end

--- Sets a function to be called when the player clicks an ability and gets a targeting UI. Your function will have 2 arguments: [Blueprint] ability blueprint, [integer] phase: TP_Position, TP_Facing (only if ability requires facing), TP_Issued (not deterministic) or TP_Cancelled (for all issuables)
---@param _function function
---@return unknown
function UI_SetModalAbilityPhaseCallback(_function) end

--- Sets a function to be called when the player clicks a construction item and gets a targeting UI. Your function will have 2 arguments: [Blueprint] ability blueprint, [integer] phase: TP_Position, TP_Facing (only if ability requires facing), TP_Issued (not strict) or TP_Cancelled (for all issuables)
---@param _function function
---@return unknown
function UI_SetModalConstructionPhaseCallback(_function) end

--- Sets a function to be called when the player clicks a construction item and gets a targeting UI. Your function will have 2 arguments: [Blueprint] ability blueprint, [integer] phase: TP_Position, TP_Facing (only if ability requires facing), TP_Issued (not strict) or TP_Cancelled (for all issuables)
---@param _function function
---@return unknown
function UI_SetModalHoverCallback(_function) end

--- Sets a level decorator that's defined in all of the squads squad_ui_ext in the target SGroup
--- fields in the squad_ui_ext are special_decorator_friendly and special_decorator_enemy if level value is -1 it will hide the special decorator, if no level is defined -1 is default
---@param sgroup SGroup
---@param level number
---@return unknown
function UI_SetSGroupSpecialLevel(sgroup, level) end

--- Sets a callback firing when user try to skip the NIS
---@param _function function
---@return unknown
function UI_SetSkipNISCallback(_function) end

--- Explicitly set the decorator a squad should use.
---@param squad Squad
---@param decorator string
---@return unknown
function UI_SetSquadDecorator(squad, decorator) end

--- Turn on of off the squad decorator being always visible. The default is decorator not always visible.
---@param squad Squad
---@param alwaysVisible boolean
---@return unknown
function UI_SetSquadDecoratorAlwaysVisible(squad, alwaysVisible) end

--- Enables or disables the UI extensions for squads / entities
---@param unit EGroup
---@param enabled boolean
---@return unknown
function UI_SetUIExtEnabled(unit, enabled) end

--- Stop flashing a flash created with a previous call to UI_Flash*().
---@return unknown
function UI_StopFlashing() end

--- Removes a message added by Game_ShowSystemMessage.
---@param message string
---@return unknown
function UI_SystemMessageHide(message) end

--- Shows a system message in the area where Game Paused text appears.
--- Call Game_HideSystemMessage to remove the message.
---@param message string
---@return unknown
function UI_SystemMessageShow(message) end

--- Removes a title using an id returned by the title creating function.
---@return unknown
function UI_TitleDestroy() end

--- Toggles all decorators on or off.
---@return unknown
function UI_ToggleDecorators() end

--- Removes the restriction on building placement.
---@return unknown
function UI_UnrestrictBuildingPlacement() end

--- Displays a brief UI warning in the critical alert message area.
--- Call UI_TitleDestroy to remove.
---@param text string
---@return unknown
function UIWarning_Show(text) end

--- Triggers a UI event cue and an audio cue that the player is about to lose the game.
--- The lower the warningLevel, the closer the player is to losing and the more intense the warning is
---@param player Player
---@param warningLevel number
---@return unknown
function WinWarning_PublishLoseReminder(player, warningLevel) end

--- Call UI_TitleDestroy to remove.
---@param text string
---@param fadeIn number
---@param duration number
---@param fadeOut number
---@return unknown
function WinWarning_ShowLoseWarning(text, fadeIn, duration, fadeOut) end

--- E-mails a warning out with logfiles at the end of the game.
--- This is similar to fatal() only the game will continue on. Use the ErrorMessage to dump out relevent information to the scarlog Example: bug( "This shouldn't happen, fix "..problem.here)
---@param errormessage ErrorMessage
---@return unknown
function bug(errormessage) end

--- Clones a table allowing for unadulterated use of the data. By default this cloning is done recursively, but that can be changed with the optional recursive flag.
---@param data table
---@param recursive boolean | nil
---@return unknown
function Clone(data, recursive) end

--- Converts any enum value to a number
---@param var any
---@return unknown
function Enum_ToNumber(var) end

--- Converts any enum value to a string
---@param var any
---@return unknown
function Enum_ToString(var) end

--- Returns true if any standard (non-save) event has been queued to run. TODO: This function name is misleading. We should maybe change it, but this is being called in many mission scripts so we are leaving it for later.
---@return unknown
function Event_IsAnyRunning() end

--- Ends the single player game (win/lose).
---@param win boolean
---@param winReason WinReason | nil
---@param nis boolean | nil
---@param sandmap boolean | nil
---@return unknown
function Game_EndSP(win, winReason, nis, sandmap) end

--- Fades the screen to black - FADE_OUT to fade to black, FADE_IN to fade back in
---@param direction boolean
---@param length number
---@return unknown
function Game_FadeToBlack(direction, length) end

--- Loads a scar file if it hasn't been loaded yet
---@param Path string
---@return unknown
function Import_Once(Path) end

--- Modify whether or not the group is revealed in the fog of war.
---@param group EGroup
---@param enable boolean
---@param durationSeconds number
---@return unknown
function Modify_EnableIsVisibleInFOW(group, enable, durationSeconds) end

--- Modify the damage done to the entity per tick when it is on fire
--- Can modify the value to zero to allow buildings to be on fire without taking damage
---@param egroup EGroup
---@param mathtype ModifierUsageType
---@param value number
---@return unknown
function Modify_OnFireDamagePerTick(egroup, mathtype, value) end

--- Modify the amount that the burn level decays per tick when not on fire
---@param egroup EGroup
---@param mathtype ModifierUsageType
---@param value number
---@return unknown
function Modify_OnFireDecayAmountPerTick(egroup, mathtype, value) end

--- Modify the health threshold required to set the entity on fire
---@param egroup EGroup
---@param mathtype ModifierUsageType
---@param value number
---@return unknown
function Modify_OnFireHealthPercentage(egroup, mathtype, value) end

--- Modify the burn level threshold required to set the entity on fire. A LOWER value means it lights on fire FASTER.
---@param egroup EGroup
---@param mathtype ModifierUsageType
---@param value number
---@return unknown
function Modify_OnFireThreshold(egroup, mathtype, value) end

--- Modify the number of entities spawned in new squads
--- Intended use case is spawning damaged squadss
---@param player Player
---@param mathtype ModifierUsageType
---@param value number
---@return unknown
function Modify_PlayerSquadLoadoutMax(player, mathtype, value) end

--- Modifies an entity's shield regen
--- Should only be used on squads
---@param group SGroup
---@param Factor number
---@param Usage__MUT_Multiplication MUT
---@return unknown
function Modify_SquadShieldRegen(group, Factor, Usage__MUT_Multiplication) end

--- Check if a position is valid or not... useful for functions that may return INVALID_POS
---@param pos Position
---@return unknown
function Position_IsValid(pos) end

--- Play sound on the centermost squad in the sgroup
---@param soundpathname string
---@param sgroupid SGroup
---@return unknown
function Sound_PlayOnSquad(soundpathname, sgroupid) end

--- Finds the greatest (or least) concentration of entities owned by a team.
--- This function is slow, so don't call it very often
---@param team TeamID
---@param popcapOnly boolean | nil
---@param includeBlueprints table | nil
---@param excludeBlueprints table | nil
---@param bLeastConcentrated boolean | nil
---@param onlyInThisMarker Marker | table | nil
---@return unknown
function Team_GetEntityConcentration(team, popcapOnly, includeBlueprints, excludeBlueprints, bLeastConcentrated, onlyInThisMarker) end

--- Finds the greatest (or least) concentration of squads owned by a team.
--- This function is slow, so don't call it very often
---@param team TeamID
---@param popcapOnly boolean | nil
---@param includeBlueprints table | nil
---@param excludeBlueprints table | nil
---@param bLeastConcentrated boolean | nil
---@param onlyInThisMarker Marker | table | nil
---@return unknown
function Team_GetSquadConcentration(team, popcapOnly, includeBlueprints, excludeBlueprints, bLeastConcentrated, onlyInThisMarker) end

--- If there's a squad under the mouse cursor, this adds it to a unique SGroup. Return value is the SGroup it was added to, or nil if there was no squad under the mouse cursor. Pass in true for 'clearGroup' to clear the sgroup before adding the squad.
---@param clearGroup boolean | nil
---@return unknown
function Util_AddMouseoverSquadToSGroup(clearGroup) end

--- Applies any modifier to the target SGroup, EGroup, or Player
--- Valid applytypes are MAT_...(Entity, Squad etc.), if left default assumption is default type for the target Cases you want to define applytype: Weapon Modifiers, Enable Modifiers, or a player modifier for all entity or squad types Valid mathtypes are MUT...(Addition, Multiplication, etc.) Exclusive modifiers will replace all pre-existing modifiers of that modifier type on the target
---@param groupid EGroup
---@param modifier string
---@param scalefactor number
---@param mathtype number
---@param applytype number | nil
---@param exclusive boolean | nil
---@param targetname string | nil
---@return unknown
function Util_ApplyModifier(groupid, modifier, scalefactor, mathtype, applytype, exclusive, targetname) end

--- Auto-generate an Ambient Event. These are Low priority, and will hopefully interrupt nothing.
--- Takes a table of Actors and LOC numbers
---@param intelEventTable table
---@return unknown
function Util_AutoAmbient(intelEventTable) end

--- Auto-generate an Intel Event. These are medium priority, and will interrupt ambient, but not an NIS.
--- Takes a table of parameters defining speaker(s) and line(s)
---@param intelEventTable table
---@return unknown
function Util_AutoIntel(intelEventTable) end

--- Auto-generate an NISlet Event, a simple NIS meant to convey mission location. These are high priority, and will interrupt ambient and Intel Events.
--- Takes an NISLET type and a table of parameters defining speaker(s) and line(s) NISLET_BLACK2GAME	= 1 -- starts in black and fades up, ends in gamplay NISLET_GAME2GAME 	= 2 -- transitions from game play to letterbox and backto gameplay NISLET_GAME2BLACK	= 3 -- starts in gameplay and ends in black NISLET_GAME2LETTER	= 4 -- starts in gameplay and ends in letterbox mode (for transition to sitrep) NISLET_TIME 		= 1 -- use seconds to wait on camera movements NISLET_VO			= 2 -- use voice to wait on camera movements t_eventes.nislet_start = { {camPos = pos1, waitType = NISLET_TIME, waitValue = 5}, {camPos = pos2, waitType = NISLET_VO, waitValue = {ACTOR.GenericAlly, 000000}}, }
---@param nisletType number
---@param intelEventTable table
---@param bFOWvisible boolean | nil
---@return unknown
function Util_AutoNISlet(nisletType, intelEventTable, bFOWvisible) end

--- Automatically save the game for the player. The savegame name is built using the abbreviated mission name + checkpoint. You can optionally have it wait until the player is out of combat.
--- This function checks the user setting regarding autosaves (so you don't have to!), and does nothing if the player has them disabled.
---@param waitUntilOutOfCombat boolean | nil
---@param onlyCareAboutCombatOnScreen boolean | nil
---@param maxWaitTime number | nil
---@return unknown
function Util_AutoSave(waitUntilOutOfCombat, onlyCareAboutCombatOnScreen, maxWaitTime) end

--- Clears vehicle wrecks from a given area.
--- Area can be a marker (with or without a range override), a position and range combo, or a territory sector ID. Uses EBP.WRECKED_VEHICLES unless wrecksList is defined.
---@param position Marker | Position | SectorID
---@param range number | nil
---@param wrecksList table | nil
---@return unknown
function Util_ClearWrecksFromMarker(position, range, wrecksList) end

--- Helper function to process comparisons that use the Comparison enum... i.e. return true if value1 IS_LESS_THAN value2
--- Comparison type can be IS_EQUAL, IS_LESS_THAN, IS_LESS_THAN_OR_EQUAL, IS_GREATER_THAN, IS_GREATER_THAN_OR_EQUAL or IS_NOT_EQUAL
---@param value1 number
---@param comparison Comparison
---@param value2 number
---@return unknown
function Util_Comparison(value1, comparison, value2) end

--- Creates a given number of entities at a location and adds them to an egroup. A PlayerID of nil will create the entities as world objects.
--- The skipForceConstruct parameter allows you to skip the step that normally spawns buildings fully constructed, so you can spawn buildings that self-construct. The toward parameter should be a world location that the entity should look at, NOT a direction. Leave it blank if you want the location's orientation to be used for a direction (assuming location is a marker). The useMarkerTransform parameter, if no toward is passed in, will determine if the marker's transform should be used for the entity OR if the marker's direction should be used in which case the entity will face the same way as the marker.
---@param player Player
---@param egroup EGroup
---@param blueprintID number
---@param location Marker | Position
---@param numentities number
---@param toward Marker | Position | nil
---@param snapToGround boolean | nil
---@param skipForceConstruct boolean | nil
---@param useMarkerTransform boolean | nil
---@return unknown
function Util_CreateEntities(player, egroup, blueprintID, location, numentities, toward, snapToGround, skipForceConstruct, useMarkerTransform) end

--- High level function to create squads and give them basic orders upon spawning. Detailed explanation found in ScarUtil.scar
--- PlayerID player - player who will own the squads SGroupID/Table/String sgroup - sgroup that receives the new squads. Can be nil if you don't need to manage the new squads or a string if you want to create a new sgroup with that name. If a table is given, the first item will be used as the return sgroup. SquadBlueprint sbp - the blueprint for the new squads. Position location - where to spawn the squads (can be any parameter type whose position can be queried) SGroup - If the sgroup is a Hold Entity then the squad is spawned inside of it. EGroup - If the egroup is a hold entity then the squad is spawned inside of it. NOTE: if the hold is destroyed, or is full, or due to any other misc. failure case, then the squad is spawned at the player's map entry point. Pos - the squad is spawned at this location. Marker - the squad is spawned at the marker and facing the direciton of the marker. Position destination - (OPTIONAL) where the squads will move to, load into, or attack SGroup can mean two different things, if the Sgroup is owned by the player and a hold then try to enter it.  Or if the SGroup is an enemy squad, then the spawned squad should attack move the enemy.  If neither is true, then the squad just moves to the location. EGroup should be treated the same as the SGroup. Position/Marker: the squad moves to the location. Sync weapon: the squad captures the sync weapon. Integer numsquads - (OPTIONAL) how many squads to spawn Integer loadout - (OPTIONAL) max amount of units to spawn per squad Boolean attackmove - (OPTIONAL) in cases where the squads do a simple move to their destination (not attacking or loading into anything), this determines whether they attack move or not Position facing - (OPTIONAL) in cases where the squads do a simple move to their destination, this determines their facing once they reach their destination. If facing is not specified, and the squad is moving to a marker, the marker's facing is used. UpgradeBlueprint upgrades - (OPTIONAL) upgrade(s) to instantly apply to squads when they spawn Boolean useMarkerTransform -  (OPTIONAL) if no spawn_facing is passed in, this will determine if the marker's transform should be used (if true) for the squad spawn OR if the marker's direction should be used in which case it will face the same way as the marker.
---@param player Player
---@param sgroup SGroup
---@param sbp number
---@param spawn_point EGroup
---@param destination Position | nil
---@param numsquads number | nil
---@param loadout number | nil
---@param attackmove boolean | nil
---@param dest_facing Position | nil
---@param upgrades number | nil
---@param spawn_facing Position | nil
---@param spawntype string | nil
---@return unknown
function Util_CreateSquads(player, sgroup, sbp, spawn_point, destination, numsquads, loadout, attackmove, dest_facing, upgrades, spawn_facing, spawntype) end

--- Takes in a table and chooses the right variable for the difficulty setting. 1-4 elements. Acquires current difficulty by default.
---@param difficultyVariables table
---@param difficulty number | nil
---@return unknown
function Util_DifVar(difficultyVariables, difficulty) end

--- Returns the result of the dot product of two items in radians
--- The params must be 3D vectors
---@param vectorA table
---@param vectorB table
---@return unknown
function Util_DotProductRadians(vectorA, vectorB) end

--- Returns true if a Player/Team can see any or all of an SGroup/Squad/EGroup/Entity/Position/Marker
---@param playerID_teamID Player | TeamID
---@param element EGroup
---@return unknown
function Util_ElementCanSee(playerID_teamID, element) end

--- Checks the entity count for the world and returns true or false depending on the result. A specific value can be passed in to override the default amount.
---@param entityLimit number | nil
---@return unknown
function Util_EntityLimit(entityLimit) end

--- Try to garrison a loadable building within radius that is closer to the first squad of the sgroup than enemy
--- Returns the entity id of the building that the squad try to garrison into. Return nil if nothing is found The squad suppression would be resetted before fallling back so that they would not succumb to pinned state
---@param sgroupid SGroup
---@param radius number
---@return unknown
function Util_FallBackToGarrisonBuilding(sgroupid, radius) end

--- Finds a hidden position based on what the local player can and can't see
--- If no position is found, returns nil
---@param items EGroup
---@return unknown
function Util_FindHiddenItem(items) end

--- Following a path from origin to destination, finds the HS_CLOSEST/HS_FURTHEST hidden position to/from the destination
--- If no position is found, returns origin
---@param origin Position
---@param destination Position
---@param furthest boolean
---@return unknown
function Util_FindHiddenSpawn(origin, destination, furthest) end

--- Following a path from origin to destination, finds the HS_CLOSEST/HS_FURTHEST visible position to/from the destination
--- If no position is found, returns destination
---@param origin Position
---@param destination Position
---@param furthest boolean
---@return unknown
function Util_FindVisibleSpawn(origin, destination, furthest) end

--- Forces all squads given to retreat, regardless of whether they are on team weapons or not. Disables aiEncounters input (true disables all encounters).
---@param sgroup SGroup
---@param marker Marker
---@param aiEncounterDisable boolean
---@return unknown
function Util_ForceRetreatAll(sgroup, marker, aiEncounterDisable) end

--- Finds a nearby building to garrison. can ignore occupied [friendly] buildings. return ID of entity it found, or nil if not found
--- Can also filter out groups not to occupy
---@param sgroup SGroup
---@param pos Position
---@param radius number
---@param occupied boolean | nil
---@param filter SGroup | nil
---@return unknown
function Util_GarrisonNearbyBuilding(sgroup, pos, radius, occupied, filter) end

--- Finds a nearby vehicle to garrison. can ignore occupied [friendly] vehicles. return ID of vehicle it found, or nil if not found,
--- Can also filter out groups not to occupy
---@param sgroup SGroup
---@param pos Position
---@param radius number
---@param occupied boolean | nil
---@param filter SGroup | nil
---@return unknown
function Util_GarrisonNearbyVehicle(sgroup, pos, radius, occupied, filter) end

--- Returns the angle (in degrees) between two items
--- The items must of of types that can have a direction resolved on them with Util_GetDirection()
---@param item1 EGroup
---@param item2 EGroup
---@return unknown
function Util_GetAngleDifference(item1, item2) end

--- Returns the closest MarkerID to the entity/marker/pos/egroup/sgroup/squad from the table of markers provided
---@param var any
---@param markers table
---@return unknown
function Util_GetClosestMarker(var, markers) end

--- Returns the heading of an item.
---@param item EGroup
---@return unknown
function Util_GetDirection(item) end

--- Returns the direction heading from point a towards point b
---@param a EGroup
---@param b EGroup
---@return unknown
function Util_GetDirectionFromAtoB(a, b) end

--- Returns the distance between two objects
---@param Object1 EGroup
---@param Object2 EGroup
---@return unknown
function Util_GetDistance(Object1, Object2) end

--- Returns the _squared_ distance between two objects
--- This is much cheaper to calculate that Util_GetDistance(), and fine for when you're only comparing results against other squared distances (i.e. to find the closest item)
---@param Object1 EGroup
---@param Object2 EGroup
---@return unknown
function Util_GetDistanceSquared(Object1, Object2) end

--- Find all the entities with a given blueprint in sourcegroup and add them to destgroup.
--- See also: EGroup_Filter()
---@param sourcegroup EGroup
---@param destgroup EGroup
---@param ebp number
---@return unknown
function Util_GetEntitiesByBP(sourcegroup, destgroup, ebp) end

--- Converts a direction into a facing.
---@param pos Position
---@param direction Position
---@return unknown
function Util_GetFacingFromDirection(pos, direction) end

--- Determines the health percentage of a given object
--- Returns average health if the object is a group
---@param var EGroup
---@return unknown
function Util_GetHealth(var) end

--- Returns a unique SGroup used to hold mouseover squads obtained from Util_AddMouseoverSquadToSGroup
---@return unknown
function Util_GetMouseoverSGroup() end

--- Returns the player owner for any of: entity, squad, egroup, sgroup, player. for groups, the first item is used. Returns nil for world owned or empty groups
---@param Object EGroup
---@return unknown
function Util_GetPlayerOwner(Object) end

--- Returns a random position within an area that is not near a player
--- Useful for dropping artillery NEAR a player, but not on him, for example. searchRadius is the area to look for the location in.  Distance is how far from the player's units the position must be.
---@param pos EGroup
---@param player Player
---@param searchRadius number | nil
---@param distance number | nil
---@return unknown
function Util_GetPositionAwayFromPlayer(pos, player, searchRadius, distance) end

--- Returns a position that is distance metres from point A, headed in the direction of point B.
--- You can also pass in a percentage (0.0 to 1.0) instead of a distance in metres.
---@param a Marker | Position
---@param b Marker | Position
---@param distance number
---@return unknown
function Util_GetPositionFromAtoB(a, b, distance) end

--- Finds a hidden position based on what the local player can and can't see
--- If no position is found, returns nil
---@param items EGroup
---@return unknown
function Util_GetRandomHiddenPosition(items) end

--- Returns a random position either within the marker's proximity or with a pos and range provided. Range is ignored for rectangular markers
---@param range number | nil
---@param hidden boolean | nil
---@return unknown
function Util_GetRandomPosition(range, hidden) end

--- Gets the relationship between two of: entity, squad, egroup, sgroup, player. for groups, the first item is used. returns R_ENEMY, R_ALLY, R_NEUTRAL, R_UNDEFINED, or nil (if world owned or invalid parameters)
---@param Object_1 EGroup
---@param Object_2 EGroup
---@return unknown
function Util_GetRelationship(Object_1, Object_2) end

--- Returns a relative offset position to an element
---@param element EGroup
---@param pos EGroup
---@return unknown
function Util_GetRelativeOffset(element, pos) end

--- Find all the squads with a given blueprint in sourcegroup and add them to destgroup.
--- See also: SGroup_Filter()
---@param sourcegroup SGroup
---@param destgroup SGroup
---@param sbp number
---@return unknown
function Util_GetSquadsByBP(sourcegroup, destgroup, sbp) end

--- Returns trailing numbers from a string, if it exists, nil otherwise. E.G. "marker23" would return 23.
---@param val string
---@return unknown
function Util_GetTrailingNumber(val) end

--- Returns true if given entity/marker/pos/egroup/sgroup/squad has a position; if false, Util_GetPosition will fail.
---@param var any
---@return unknown
function Util_HasPosition(var) end

--- Hides all of a player's squads and/or buildings
--- Doesn't hide buildings a player is in, or any base structures. Only items like sandbags, tanktraps, mg nests, etc. Put multiple playerIDs in a table to hide many players together, or use ALL for the playerID to apply to all players at once.
---@param player Player
---@param hide boolean
---@return unknown
function Util_HidePlayerForNIS(player, hide) end

--- Returns whether the currently running sequence has been skipped
---@return unknown
function Util_IsSequenceSkipped() end

--- Kills a given object
---@param var EGroup
---@return unknown
function Util_Kill(var) end

--- Tracks a syncweapon ID and destroys it (by default) or makes it uncapturable (if kill is set to false)
---@param syncweapon SGroup
---@param kill boolean | nil
---@return unknown
function Util_LogSyncWpn(syncweapon, kill) end

--- Play an events file at a given markers location
---@param markername string
---@param eventfile string
---@return unknown
function Util_MarkerFX(markername, eventfile) end

--- Play the mission title fade.
---@param title string
---@param time_fade_in number | nil
---@param lifetime number | nil
---@param time_fade_out number | nil
---@return unknown
function Util_MissionTitle(title, time_fade_in, lifetime, time_fade_out) end

--- Calls UI_NewHUDFeature() as an IntelEvent. Will get queued as any other event. See UI_NewHUDFeature() for parameter details.
---@param newHUDFeature HUDFeatureType
---@param featureText string
---@param featureIcon string
---@param duration number
---@return unknown
function Util_NewHUDFeatureEvent(newHUDFeature, featureText, featureIcon, duration) end

--- Play a movie.
--- Plays a movie file after fading out the screen. Fades back in and triggers onComplete once it ends. If fadeIn < 0, does not face back in once complete. If onCompleteAfterMovie is true, the onComplete function will play as soon as the movie is over, instead of after the fade-in
---@param name string
---@param fadeOut number | nil
---@param fadeIn number | nil
---@param onComplete function | nil
---@param delay number | nil
---@param onCompleteAfterMovie boolean | nil
---@return unknown
function Util_PlayMovie(name, fadeOut, fadeIn, onComplete, delay, onCompleteAfterMovie) end

--- Plays music from the Data:Sound folder, and stores the music track so it can be resumed after a save/load
--- The new music will phase out the old one. There can only be one music playing at anytime.
---@param name string
---@return unknown
function Util_PlayMusic(name) end

--- Simply prints something if the first variable is true
---@return unknown
function Util_PrintIf() end

--- Prints out the entire contents of an Object
--- This is most useful when used in conjunction with fatal() or bug() to populate the log file. Objects can be anything (Player, SGroup, Int, Table, String, etc.), but this is most useful for Tables
---@param obj Object
---@param max_depth number | nil
---@param data_type string | nil
---@param print_func function | nil
---@return unknown
function Util_PrintObject(obj, max_depth, data_type, print_func) end

--- Simply prints out everything in a table including nested tables
---@return unknown
function Util_PrintTable() end

--- Prints out a unit table. indent is the number of tabs at the beginning of each line
---@return unknown
function Util_PrintUnitTable() end

--- Reloads the running scar script. Current running rules would also be updated to the redefined functioin.
---@return unknown
function Util_ReloadScript() end

--- Resumes playing the music track that was last triggered i.e. after a save/load
---@return unknown
function Util_RestoreMusic() end

--- Converts a 2D top down position to a 3D ScarPosition. returns Position, if y-height is nil, y-height = ground height, terrain ground or walkable
--- 3D ScarPositions have the x axis left to right, the z axis in to out, and the y axis down to up (y axis represents the height of the terrain).  Use this function to convert a top-down 2D position to a 3D world position.\n\n Note: (0,0) is in the center of the map.
---@param xpos number
---@param zpos number
---@param ypos number
---@return unknown
function Util_ScarPos(xpos, zpos, ypos) end

--- Sets it so that a player can skip a scripted sequence. When the skip key is pressed, calls back the given function as a post-sequence setup. noFadeIn stops the system from fading back into gameplay when finished. Call Util_SetPlayerUnableToSkipSequence() when the sequence is finished to disable
---@param event function
---@param skippedCallback function
---@param noFadeIn boolean
---@param fadeInTime number | nil
---@return unknown
function Util_SetPlayerCanSkipSequence(event, skippedCallback, noFadeIn, fadeInTime) end

--- Sets the player owner for an entity, squad, egroup or sgroup. Also sets player owner of whatever is garrisoned inside them
---@param Object EGroup
---@param owner Player
---@param bApplyToSquadsHeld_true boolean | nil
---@return unknown
function Util_SetPlayerOwner(Object, owner, bApplyToSquadsHeld_true) end

--- Disables Util_SetPlayerCanSkipSequence
---@param event function
---@param skippedCallback function
---@param noFadeIn boolean
---@return unknown
function Util_SetPlayerUnableToSkipSequence(event, skippedCallback, noFadeIn) end

--- Returns a table of positions sorted from closest to furthest (or furthes to closest if reverse is true) from the origin
---@param origin EGroup
---@param positions table
---@return unknown
function Util_SortPositionsByClosest(origin, positions) end

--- Play a Speech Ambient. These are the lowest priority, and will be bumped by Intel Events or NIS's.
--- This function should used instead of Event_Start because it handles priorities.
---@param func function
---@return unknown
function Util_StartAmbient(func) end

--- Play an Intel Event. These are medium priority, and will interrupt a ambient, but not an NIS.
--- This function should used instead of Event_Start because it handles priorities.
---@param func function
---@return unknown
function Util_StartIntel(func) end

--- Plays an NIS. The NIS should have a call to NIS_START(details) at the beginning, and NIS_END() at the end.
--- Example details table keys: {style = NIS_OPENING, NIS_MID or NIS_CLOSING, exemptions = {sg_unit_to_not_despawn}, revealFOW = true, callbackStart = func, callbackEnd = func}
---@param NIS function
---@return unknown
function Util_StartNIS(NIS) end

--- Play a quick, one-line Intel event.  These are medium priority, and will interrupt ambient, but not an NIS.
--- Use this when playing a single line.  For multi-line events, use Util_StartIntel
---@param actor string
---@param speech string
---@return unknown
function Util_StartQuickIntel(actor, speech) end

--- Splits a string into a table of substrings based on a given separator. Comma is used as the default separator if none is provided.
---@return unknown
function Util_StringSplit() end

--- Checks the first layer of a table and looks for a specified Object, returns true if found.
--- Objects can be anything (Player, SGroup, Int, Table, String, etc.)
---@param targetTable table
---@param obj Object
---@return unknown
function Util_TableContains(targetTable, obj) end

--- Debug function used to toggle whether or not IntelEvents are played. Only works with -dev parameter
---@return unknown
function Util_ToggleAllowIntelEvents() end

--- Library function to trigger NIS event under a certain sets of conditions.  NOTE: if checking against a marker DO NOT specify a range.  The range of the marker set in the WorldBuilder will be used.
--- triggering event when one of the player's squads come near a particular SGroup, EGroup, Marker, or Position and that squad is onscreen, and that squad is not in combat. 6 arguments when using marker, 7 arguments when using position, egroup and sgroup with the additional range value non_combat set to TRUE means the squad cannot be in combat if the event is to be triggered. onscreen_only set to TRUE means the squad must be onscreen if the event is to be triggered.
---@param playerid Player
---@param position EGroup
---@param range number
---@param func function
---@param non_combat boolean
---@param onscreen_only boolean
---@param onscreen_duration number
---@return unknown
function Util_TriggerEvent(playerid, position, range, func, non_combat, onscreen_only, onscreen_duration) end

--- Returns a table containing either the total or a specific player's squad count, entity count, and vehicle count.
--- table can be accessed as scene below Get Player Example:\n local t = Util_UnitCounts(player1)\n print(t.squad)\n print(t.entity)\n print(t.vehicle)\n Get World Example:\n local t = Util_UnitCounts(true)\n print(t.squad)\n print(t.entity)\n print(t.vehicle)\n Alternate Format:\n print(Util_UnitCounts(true).squad)\n
---@param world_OR_playerID_player boolean
---@return unknown
function Util_UnitCounts(world_OR_playerID_player) end

--- Kills ALL world entities near a marker
---@param marker Marker
---@return unknown
function World_KillAllNeutralEntitesNearMarker(marker) end

--- Kill off a specific player's dead bodies (enter ALL to clean them all up) in a marker radius
---@param player Player
---@param marker Marker
---@return unknown
function Marker_CleanUpTheDead(player, marker) end

--- Calculates the length of the provided vector
---@param pos Position
---@return unknown
function Vector_Length(pos) end

--- Linearly interpolates between the two provided vectors based on the provided factor
---@param factor number
---@param pos1 Position
---@param pos2 Position
---@return unknown
function Vector_Lerp(factor, pos1, pos2) end

--- Returns the normalized version of the provided vector
--- Returns a vector pointing the same direction as the provided vector, but shortened/elongated to a length of 1. Don't pass in a vector of length 0, or you'll get a divide-by-zero error!
---@param pos Position
---@return unknown
function Vector_Normalize(pos) end

--- Returns the average positions of the entities in the area
--- Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral It filters out entities not belonging to a squad, when onlyEntitiesInSquads is true
---@param player Player
---@param pos Position
---@param radius number
---@param ownerType OwnerType
---@param onlyEntitiesInSquads boolean
---@return unknown
function World_CalculateEntitiesAveragePositionInArea(player, pos, radius, ownerType, onlyEntitiesInSquads) end

--- Changes target interactivity zones to adjusted interactivity (255 max), probably only safe to use post NIS
---@param targetInteractivity number
---@param adjustedInteractivity number
---@return unknown
function World_ChangeZoneInteractivity(targetInteractivity, adjustedInteractivity) end

--- Kill off a specific player's dead bodies (enter ALL to clean them all up)
---@param player Player
---@return unknown
function World_CleanUpTheDead(player) end

--- Destroys walls (entities with a wall_ext) near a marker
---@param marker Marker
---@return unknown
function World_DestroyWallsNearMarker(marker) end

--- Get the distance between a squad group and a point.
--- Pass in true for 3rd parameter to get the closest point and pass in false to get the furthest point.  The closest/furthest point is calculated on a per entity basis.  So the closest distance would be that of the closest entity.\n Also note, it is an error to call this function with an empty group.\n
---@param egroup EGroup
---@param p1 Position
---@param closest boolean
---@return unknown
function World_DistanceEGroupToPoint(egroup, p1, closest) end

--- Get the distance between two points.
---@param p1 Position
---@param p2 Position
---@return unknown
function World_DistancePointToPoint(p1, p2) end

--- Get the distance between a squad group and a point.
--- Pass in true for 3rd parameter to get the closest point and pass in false to get the furthest point.  The closest/furthest point is calculated on a per squadron basis.  So the closest distance would be that of the closest squadron.\n It is an error to call this function with an empty group.  Check the group size with SquadGroup_Count( ) first.
---@param sgroup SGroup
---@param p1 Position
---@param closest boolean
---@return unknown
function World_DistanceSGroupToPoint(sgroup, p1, closest) end

--- Get the distance squared between two points.
---@param p1 Position
---@param p2 Position
---@return unknown
function World_DistanceSquaredPointToPoint(p1, p2) end

--- Determines whether empty players get converted to null resource points.
--- *** You must call this from OnGameSetup, otherwise it's too late *** see Attribute Editor under tuning/player/empty_player_replacement_object
---@param enable boolean
---@return unknown
function World_EnableReplacementObjectForEmptyPlayers(enable) end

--- Enables or disables shared line of sight between these two players
---@param p0 Player
---@param p1 Player
---@param enableSharedVision boolean
---@return unknown
function World_EnableSharedLineOfSight(p0, p1, enableSharedVision) end

--- Clears the egroup, then finds and adds all neutral entities to it
--- Returns the number of entities found
---@param egroup EGroup
---@return unknown
function World_GetAllNeutralEntities(egroup) end

--- Returns all entities with this blueprint - warning this function iterates over all entities so it is slow
---@param pbg Entity
---@param outEntities EGroup
---@return unknown
function World_GetBlueprintEntities(pbg, outEntities) end

--- Returns the closest object from the table of marker/pos/egroup/sgroup to the closest marker/pos/egroup/sgroup specified
--- The table may mix together objects of different types.
---@param var any
---@param items EGroup
---@return unknown
function World_GetClosest(var, items) end

--- Appends all cover points to an egroup.
--- Takes an egroup where you want to put the points. If this 'group' already contains a cover point, this cover point will not be added a second time. This function does not clear the contents of 'group'.\n
---@param group EGroup
---@return unknown
function World_GetCoverPoints(group) end

--- Clears the egroup, then finds and adds entities near the marker to the egroup
--- Returns the number of entities found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral Entities belonging to a squad would not be added to the egroup
---@param player Player
---@param egroup EGroup
---@param marker Marker
---@param ownerType OwnerType
---@return unknown
function World_GetEntitiesNearMarker(player, egroup, marker, ownerType) end

--- Clears the egroup, then finds and adds entities near the point to the egroup
--- Returns the number of entities found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral Entities belonging to a squad would not be added to the egroup
---@param player Player
---@param egroup EGroup
---@param pos Position
---@param radius number
---@param ownerType OwnerType
---@return unknown
function World_GetEntitiesNearPoint(player, egroup, pos, radius, ownerType) end

--- Clears the egroup, then finds and adds entities within the territory sector to the egroup
--- Returns the number of entities found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral Entities belonging to a squad would not be added to the egroup
---@param player Player
---@param egroup EGroup
---@param inSectorID number
---@param ownerType OwnerType
---@return unknown
function World_GetEntitiesWithinTerritorySector(player, egroup, inSectorID, ownerType) end

--- Returns the furthest object from the table of marker/pos/egroup/sgroup to the furthest marker/pos/egroup/sgroup specified.
--- The table may mix together objects of different types.
---@param var any
---@param items LuaTable
---@return unknown
function World_GetFurthest(var, items) end

--- Return the total number of game (simulation) ticks elapsed.
---@return unknown
function World_GetGameTicks() end

--- Return the total game time in seconds.
---@return unknown
function World_GetGameTime() end

--- returns the height of ground at 2D pos x,y
---@param x number
---@param y number
---@return unknown
function World_GetHeightAt(x, y) end

--- Returns the interaction stage of the cell in the provided position
--- Returns a value between 0 - 63
---@param position Position
---@return unknown
function World_GetInteractionStageAtPoint(position) end

--- Returns the total playable length of the game world (z coordinate)
--- Since the center of the map is 0,0 the world z range is (-l/2 -> l/2)
---@return unknown
function World_GetLength() end

--- Get the Biome PBG's name of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataBiomePBGName(layerName, x, y) end

--- Get the boolean value of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataLayerBoolean(layerName, x, y) end

--- Get the integer value of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataLayerInteger(layerName, x, y) end

--- Get the numeric value of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataLayerNumber(layerName, x, y) end

--- Get the PBG of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataLayerPBG(layerName, x, y) end

--- Get the PBG of the specified terrain metadata layer and the specified coordinates.
---@param layerName string
---@param x number
---@param y number
---@return unknown
function World_GetMetadataLayerString(layerName, x, y) end

--- returns the nearest intractable position to the supplied position
---@param position Position
---@return unknown
function World_GetNearestInteractablePoint(position) end

--- Find and add neutral entities near the marker to the egroup
--- Returns the number of entities found Entities belonging to a squad would not be added to the egroup
---@param egroup EGroup
---@param marker Marker
---@return unknown
function World_GetNeutralEntitiesNearMarker(egroup, marker) end

--- Find and add neutral entities near the point to the egroup
--- Returns the number of entities found Entities belonging to a squad would not be added to the egroup
---@param egroup EGroup
---@param pos Position
---@param radius number
---@return unknown
function World_GetNeutralEntitiesNearPoint(egroup, pos, radius) end

--- Find and add neutral entities within the territory sector to the egroup
--- Returns the number of entities found Entities belonging to a squad would not be added to the egroup
---@param egroup EGroup
---@param sectorID number
---@return unknown
function World_GetNeutralEntitiesWithinTerritorySector(egroup, sectorID) end

--- Return the number of entities of the same ebp in the sphere volume
---@param ebp Entity
---@param pos Position
---@param radius number
---@return unknown
function World_GetNumEntitiesNearPoint(ebp, pos, radius) end

--- Returns the number of strategic points on this map (does not count strat. objectives)
---@return unknown
function World_GetNumStrategicPoints() end

--- Returns the blueprint of a chosen squad for a race
---@param racePBG ScarRacePBG
---@param index number
---@return unknown
function World_GetPossibleSquadsBlueprint(racePBG, index) end

--- Returns the number of types of squads a race can build
---@param racePBG ScarRacePBG
---@return unknown
function World_GetPossibleSquadsCount(racePBG) end

--- Returns a random integer with range [min, max]
--- It is recommended you use this instead of luas math.random function
---@param min number
---@param max number
---@return unknown
function World_GetRand(min, max) end

--- Returns maximum number of players in this match
---@return unknown
function World_GetScenarioMaxPlayers() end

--- Given any position in the world, this function will return position safe for spawning a given entity
---@param around Position
---@param entity Entity
---@return unknown
function World_GetSpawnablePosition(around, entity) end

--- Clears the sgroup, then finds and adds squads near the marker to the sgroup
--- Returns the number of squads found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral This function is faster if radius is small and/or number of squads to search for is large
---@param player Player
---@param sgroup SGroup
---@param marker Marker
---@param ownerType OwnerType
---@return unknown
function World_GetSquadsNearMarker(player, sgroup, marker, ownerType) end

--- Clears the sgroup, then finds and adds squads near the point to the sgroup
--- Returns the number of squads found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral This function is faster if radius is small and/or number of squads to search for is large
---@param player Player
---@param sgroup SGroup
---@param pos Position
---@param radius number
---@param ownerType OwnerType
---@return unknown
function World_GetSquadsNearPoint(player, sgroup, pos, radius, ownerType) end

--- Clears the sgroup, then finds and adds squads within territory sector identified by sector ID
--- Returns the number of squads found Owner type could be OT_Player, OT_Ally, OT_Enemy or OT_Neutral
---@param player Player
---@param sgroup SGroup
---@param inSectorID number
---@param ownerType OwnerType
---@return unknown
function World_GetSquadsWithinTerritorySector(player, sgroup, inSectorID, ownerType) end

--- Appends all the strategic resource points to an egroup.
--- takes the egroup where you want to put the points, and 2nd parameter is a bool which indicates if you want to include VPs or not If 'group' already contains an entity from 'grouptoadd' it will not be added.\n This function does not clear the contents of 'group'.\n Example: World_GetStrategyPoints(mypointgroup, true) --puts all the points including vps into mypointgroup
---@param group EGroup
---@param bIncludeVP boolean
---@return unknown
function World_GetStrategyPoints(group, bIncludeVP) end

--- Returns one or more sector IDs that would connect two unconnected pieces of territory. return value is through a table (since there can be more than one way to connect territory) - each entry in this table is a table of sector IDs.
--- Currently only finds single gaps - i.e. if two territories are 'almost' connected.
---@param sectorID1 number
---@param sectorID2 number
---@param results StackVarTable
---@return unknown
function World_GetTeamTerritoryGaps(sectorID1, sectorID2, results) end

--- returns the cell type of the cell in the specified coordinates. 0 = Sky, 1 = Land, 2 = Water.
---@param x number
---@param y number
---@return unknown
function World_GetTerrainCellType(x, y) end

--- Return the sector ID from the position
---@param pos Position
---@return unknown
function World_GetTerritorySectorID(pos) end

--- Returns the position of a sectors generator point.
---@param inSectorID number
---@return unknown
function World_GetTerritorySectorPosition(inSectorID) end

--- Returns the total playable width of the game world (x coordinate)
--- Since the center of the map is 0,0 the world x range is (-w/2 -> w/2)
---@return unknown
function World_GetWidth() end

--- Returns whether the interaction stage is currently active
---@param stage number
---@return unknown
function World_IsCurrentInteractionStageActive(stage) end

--- Returns true if position is in-supply for the given player
---@param player Player
---@param pos Position
---@return unknown
function World_IsInSupply(player, pos) end

--- Returns whether or not the game type of this world is multiplayer
---@return unknown
function World_IsMultiplayerGame() end

--- Returns true if position if part of the entity territory
--- Note that this does not care if territory is in supply or not
---@param player Player
---@param position Position
---@return unknown
function World_IsPointInPlayerTerritory(player, position) end

--- Returns if a position is on walkable wall
---@param p Position
---@return unknown
function World_IsPosOnWalkableWall(p) end

--- Returns TRUE if the game is currently in a replay state.
---@return unknown
function World_IsReplay() end

--- Find if player has ownership to this territory sector.
--- Other players on the same team would also have the ownership to the sector
---@param player Player
---@param inSectorID number
---@return unknown
function World_IsTerritorySectorOwnedByPlayer(player, inSectorID) end

--- Returns whether ANY or ALL of the entities in the group are owned by the world (i.e. neutral)
---@param egroup EGroup
---@param all boolean
---@return unknown
function World_OwnsEGroup(egroup, all) end

--- Returns true if the squad is owned by the world
---@param entity Entity
---@return unknown
function World_OwnsEntity(entity) end

--- Returns whether ANY or ALL of the squads in the group are owned by the world (i.e. neutral)
---@param sgroup SGroup
---@param all boolean
---@return unknown
function World_OwnsSGroup(sgroup, all) end

--- Returns true if the squad is owned by the world
---@param squad Squad
---@return unknown
function World_OwnsSquad(squad) end

--- Returns true if two world positions are in proximity to each other
---@param p1 Position
---@param p2 Position
---@param prox number
---@return unknown
function World_PointPointProx(p1, p2, prox) end

--- Creates a new Position object.
--- A position object is basically a table with an x, y, and z attribute.  You can directly access the individual components in the same way that you would access a field in a table.\n\n Example:\n --* lua script snip\n local pos = World_Pos(2, 0, 0)\n pos.x = pos.x + 1\n print pos.x -- this will print 3\n --* lua script snip\n
---@param x number
---@param y number
---@param z number
---@return unknown
function World_Pos(x, y, z) end

--- Returns if given position is in playable area.
---@param pos Position
---@return unknown
function World_PosInBounds(pos) end

--- DO NOT CALL UNLESS YOU DO AUTOMATED TESTING
--- This resets the world into a state comparable to a fresh scenario start. Used in automated testing to avoid tests being dependent on each other.
---@return unknown
function World_Reset() end

--- Unlocks all the interaction stages
---@param visibilityStatus boolean
---@return unknown
function World_SetAllInteractiveStagesVisibility(visibilityStatus) end

--- Sets a particular sector in the world as a supply provider (or not)
---@param point Position
---@param bSupply boolean
---@return unknown
function World_SetDesignerSupply(point, bSupply) end

--- Set current interaction stage to value supplied, must be >= 0
---@param stage number
---@return unknown
function World_SetInteractionStage(stage) end

--- Enables or disables shared line of sight between these two players, and merges explored maps when needed
---@param p0 Player
---@param p1 Player
---@param enableSharedVision boolean
---@return unknown
function World_SetSharedLineOfSightEnabledAndMergeExploredMaps(p0, p1, enableSharedVision) end

--- spawn a demolitions charge at a position, 'player' is the one that owns the demolitions and can detonate them.
---@param player Player
---@param pos Position
---@return unknown
function World_SpawnDemolitionCharge(player, pos) end

--- Returns true if the two points are in the same territory region, and owned by the specified territory team, Returns false otherwise.
---@param team_index number
---@param p1 Position
---@param p2 Position
---@return unknown
function World_TeamTerritoryPointsConnected(team_index, p1, p2) end
